<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | Ranting @ 741 MHz]]></title>
  <link href="http://741MHz.com/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://741MHz.com/"/>
  <updated>2013-12-01T22:33:13-05:00</updated>
  <id>http://741MHz.com/</id>
  <author>
    <name><![CDATA[741MHz.com]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Read it Aloud to Yourself]]></title>
    <link href="http://741MHz.com/read-it-aloud/"/>
    <updated>2013-05-07T00:00:00-04:00</updated>
    <id>http://741MHz.com/read-it-aloud</id>
    <content type="html"><![CDATA[<p>Once in a while I like to learn a new technology, a programming language or a trick to entertain myself and, hopefully, keep the mind open. To shift the perception on programming languages a little, I’ve decided to code some Ruby. The mind shift attempt was not successful this time. The language itself didn’t really impress me a lot — it is nice, well designed, has quite a community and a lot of stuff is built around it. But that’s about all there is in it for me. Almost. One of the books about Ruby that I stumbled upon is too damn good. It is the most entertaining and interesting read about programming language that I had in quite some time. It is called “<a href="http://mislav.uniqpath.com/poignant-guide/book/">Why’s (poignant) Guide to Ruby</a>” and is freely available online under the <a href="http://creativecommons.org/licenses/by-sa/2.5/">Attribution-ShareAlike license</a>. Here is an excerpt from a beautiful introduction to Ruby on Chapter 3:</p>

<blockquote><p>My conscience won’t let me call Ruby a computer language. That would imply that the language works primarily on the computer’s terms. That the language is designed to accommodate the computer, first and foremost. That therefore, we, the coders, are foreigners, seeking citizenship in the computer’s locale. It’s the computer’s language and we are translators for the world.
But what do you call the language when your brain begins to think in that language? When you start to use the language’s own words and colloquialisms to express yourself. Say, the computer can’t do that. How can it be the computer’s language? It is ours, we speak it natively!
We can no longer truthfully call it a computer language. It is coderspeak. It is the language of our thoughts.
Read the following aloud to yourself:
5.times { print &ldquo;Odelay!&rdquo; }
In English sentences, punctuation (such as periods, exclamations, parentheses) are silent. Punctuation adds meaning to words, helps give cues as to what the author intended by a sentence. So let’s read the above as: Five times print “Odelay!”</p></blockquote>

<p>There were more examples that, if you read them aloud to yourself, totally make sense to any person:</p>

<p><code>ruby Exit unless the word restaurant includes the word aura:
exit unless "restaurant".include? "aura"
</code></p>

<p><code>ruby With the words ‘toast’, ‘cheese’, and ‘wine’: take each food and print it capitalized:
['toast', 'cheese', 'wine'].each { |food| print food.capitalize  }
</code></p>

<p>This is not to mention beautiful Cartoon Foxes:</p>

<p><img class="<a" src="href="http://mislav.uniqpath.com/poignant-guide/images/the.foxes-3.png">http://mislav.uniqpath.com/poignant-guide/images/the.foxes-3.png</a>"></p>

<p>For a moment I thought it was pretty cool. But then I got back to earth. You see, programming in a human language is not fun at all and we all know it. There is a good non-programming life analogy to programming in a human language. It is called “The Law”. If you don’t believe me, go read your country’s tax, labor, criminal or any other law. You could read it as much as you want but chances are that you would either not understand it at all or misinterpret it unless you have a degree from a good law school. And those laws are written in proper English that you can read aloud to yourself. The point is that when it comes to precisely describing what should happen under what circumstances, there will be a domain specific language for it, and you will have to either master it yourself or hire a professional. The language itself doesn’t make things simpler and I would probably get around the law much better if it was written in a formal <a href="http://en.wikipedia.org/wiki/Turing_completeness">Turing-complete</a> language. And after all, I don’t really think like Ruby. Perhaps I’ve been doing low-level programming for too long now, I don’t know. It is definitely not the language of my thoughts. Not even close.</p>

<p>At any rate, Ruby is still a programming language that leaves a good impression as simple, fun and powerful tool that gets a lot of things done. I really enjoyed it during my crash course and thought it would be cool to write a C++ program in a way that you could read it aloud to your friends who are not programmers and have them understand what it does. Here is what I came up with for those first three Ruby examples:</p>

<p>```c++</p>

<h1>include &ldquo;ruby.hh&rdquo;</h1>

<p>int main() {</p>

<pre><code>// 5.times { print "Odelay!" }
5_times ^ print("Odelay!");

// exit unless "restaurant".include? "aura"
exit_unless ^ "restaurant"_includes("aura");

// ['toast', 'cheese', 'wine'].each { |food| print food.capitalize  }
each({ "toast", "cheese", "wine" }) ^ (print | capitalized);
</code></pre>

<p>}
```</p>

<p>And as it often happens, C++ did not come with batteries included this time, so I had to come up with a little mess consisting of lambdas, function objects, user-defined literals and initializer lists in order for this mambo-jumbo to work. Most of those are part of C++11 and without them it would have been a lot worse. Here is my terrible code turning C++ into a crazy Ruby-like thing:</p>

<p>```c++</p>

<h1>ifndef RUBY_HH</h1>

<h1>define RUBY_HH</h1>

<h1>include <cstdlib></h1>

<h1>include <string></h1>

<h1>include &lt;initializer_list></h1>

<p>enum fmt_flags {</p>

<pre><code>none,
capitalized
</code></pre>

<p>};</p>

<p>struct Repeater {</p>

<pre><code>unsigned long long n;

explicit inline Repeater(unsigned long long n) : n(n) {}

template &lt;typename F&gt;
void operator ^ (const F &amp;f) const {
    for (unsigned long long i = 0; i &lt; n; ++i)
        f();
}
</code></pre>

<p>};</p>

<p>inline Repeater operator"&ldquo; _times (unsigned long long n) {</p>

<pre><code>return Repeater(n);
</code></pre>

<p>}</p>

<p>struct printer {</p>

<pre><code>std::string s;

explicit printer(const std::string &amp;s) : s(s) { }

inline void operator()() const {
    std::puts(s.c_str());
}
</code></pre>

<p>};</p>

<p>struct fmt_printer {</p>

<pre><code>fmt_flags f;

explicit fmt_printer(fmt_flags f) : f(f) {
}

inline void operator()(const std::string &amp;x) const {
    auto s = x;
    switch (f) {
      case capitalized:
          for (auto &amp;c : s)
              c = std::toupper(c);
      case none:
          break;
    }
    std::puts(s.c_str());
}
</code></pre>

<p>};</p>

<p>auto print = <a href="const%20std::string%20&amp;s"></a> {</p>

<pre><code>return printer(s);
</code></pre>

<p>};</p>

<p>struct StringIncludesCheck {</p>

<pre><code>const char *haystack;
explicit StringIncludesCheck(const char *haystack)
    : haystack(haystack) { }

inline bool operator()(const char *needle) const {
    return std::strstr(haystack, needle) != nullptr;
}
</code></pre>

<p>};</p>

<p>inline StringIncludesCheck operator"&ldquo;
_includes(const char *haystack, long unsigned int) {</p>

<pre><code>return StringIncludesCheck(haystack);
</code></pre>

<p>}</p>

<p>struct ExiterUnless {</p>

<pre><code>inline void operator ^ (bool v) const {
    if (!v)
        std::exit(0);
}
</code></pre>

<p>};</p>

<p>static ExiterUnless exit_unless;</p>

<p>template <typename T>
struct EachFunc {</p>

<pre><code>std::initializer_list&lt;T&gt; elems;
explicit EachFunc(std::initializer_list&lt;T&gt; elems) : elems(elems) {}
template &lt;typename F&gt;
void operator^(F &amp;&amp;f) const {
    for (auto &amp;x : elems)
        f(x);
}
</code></pre>

<p>};</p>

<p>template <typename T>
EachFunc<T> each(std::initializer_list<T> elems) {</p>

<pre><code>return EachFunc&lt;T&gt;(elems);
</code></pre>

<p>}</p>

<p>fmt_printer operator|(decltype(print) printer, fmt_flags flags)
{</p>

<pre><code>return fmt_printer(flags);
</code></pre>

<p>}</p>

<h1>endif</h1>

<p>```</p>

<p>Luckily, this kind of stuff is rarely needed in the real world C++ programming. Most folks simply code up a few classes, throw a few virtual functions on top and get the job done. But there are some good cases when such a mind-blowing complexity comes handy. <a href="http://www.boost.org/doc/libs/release/doc/html/xpressive.html">Xpressive</a> is an excellent examples — it is a template regular-expression library that pretty much builds regular expressions in compile-time. Just check this beautiful usage example:</p>

<p>```c++</p>

<h1>include <iostream></h1>

<h1>include &lt;boost/xpressive/xpressive.hpp></h1>

<p>using namespace boost::xpressive;</p>

<p>int main()
{</p>

<pre><code>char const *str = "I was born on 5/30/1973 at 7am.";

// define some custom mark_tags with names more meaningful than s1, s2, etc.
mark_tag day(1), month(2), year(3), delim(4);

// this regex finds a date
cregex date = (month= repeat&lt;1,2&gt;(_d))           // find the month ...
           &gt;&gt; (delim= (set= '/','-'))            // followed by a delimiter ...
           &gt;&gt; (day=   repeat&lt;1,2&gt;(_d)) &gt;&gt; delim  // and a day followed by the same delimiter ...
           &gt;&gt; (year=  repeat&lt;1,2&gt;(_d &gt;&gt; _d));    // and the year.

cmatch what;

if( regex_search( str, what, date ) )
{
    std::cout &lt;&lt; what[0]     &lt;&lt; '\n'; // whole match
    std::cout &lt;&lt; what[day]   &lt;&lt; '\n'; // the day
    std::cout &lt;&lt; what[month] &lt;&lt; '\n'; // the month
    std::cout &lt;&lt; what[year]  &lt;&lt; '\n'; // the year
    std::cout &lt;&lt; what[delim] &lt;&lt; '\n'; // the delimiter
}
</code></pre>

<p>}
```</p>

<p>Either way, I don’t think I can make a good Ruby programmer because I tend to write my C++ as if it was C with code-generation built into the compiler and stick to dataflow programming model rather than object-oriented one. And I love it. As my buddy often say, «Cobol programmer could write a Cobol program in pretty much any programming language.»</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Like Python]]></title>
    <link href="http://741MHz.com/cpp-like-python/"/>
    <updated>2013-05-06T00:00:00-04:00</updated>
    <id>http://741MHz.com/cpp-like-python</id>
    <content type="html"><![CDATA[<p>Today I ran into a somewhat classy piece of code that was analyzing user’s answer to a <a href="https://en.wikipedia.org/wiki/Yes%E2%80%93no_question">Yes or No question</a>. The idea was to compare input to various possible answers disregarding the case. The code looked something like this:</p>

<p>```c++</p>

<h1>include <string></h1>

<h1>include &lt;strings.h></h1>

<h1>include <iostream></h1>

<p>static bool positive(const char *s)
{</p>

<pre><code>return (strcasecmp(s, "Y") == 0 ||
        strcasecmp(s, "Yes") == 0 ||
        strcasecmp(s, "OK") == 0 ||
        strcasecmp(s, "True") == 0 ||
        strcasecmp(s, "Sure") == 0 ||
        strcasecmp(s, "Of Course") == 0 ||
        strcasecmp(s, "Why not?") == 0);
</code></pre>

<p>}</p>

<p>int main()
{</p>

<pre><code>std::string s;

for (;;) {
    std::cout &lt;&lt; "Could you please give me $100? " &lt;&lt; std::flush;
    std::getline(std::cin, s);
    if (positive(s.c_str())) {
        std::cout &lt;&lt; "Thank you!" &lt;&lt; std::endl;
        break;
    } else {
        std::cout &lt;&lt; "We don't take «No» for an answer. Did you mean «Yes»?"
                  &lt;&lt; std::endl;
    }
}
</code></pre>

<p>}
```</p>

<p>What I wanted was to extend that funky <code>positive()</code> function to add more possibilities and it made me sad a little. Since I am writing Python scripts once in a while, I remembered about Python’s “in” statement. If I were to write this in Python, I’d do something like this:</p>

<p>```python</p>

<h1>!/usr/bin/env python</h1>

<h1>&ndash;<em>&ndash; coding: utf-8 &ndash;</em>&ndash;</h1>

<p>while True:</p>

<pre><code>answer = raw_input('Could you please give me $100? ')
if answer.lower() in ('y', 'yes', 'ok', 'true', 'sure', 'of course', 'why not?'):
    print "Thank You!"
    break
else:
    print "We don't take «No» for an answer. Did you mean «Yes»?"
</code></pre>

<p>```</p>

<p>Then I though, “Hey, C++ is by far a lot more powerful than Python syntax-wise, does this program really have to be that long and ugly?” Challenge accepted. A minute later, it looked even shorter than my Python version:</p>

<p>```c++
while (!in(lower(raw_input(&ldquo;Could you please give me $100? &rdquo;)),</p>

<pre><code>       "y", "yes", "ok", "true", "sure", "of course", "why not?"))
std::cout &lt;&lt; "We don't take «No» for an answer. Did you mean «Yes»?" &lt;&lt; std::endl;
</code></pre>

<p>std::cout &lt;&lt; &ldquo;Thank you!&rdquo; &lt;&lt; std::endl;
```</p>

<p>Well, of course this took some “magic” to work, which went to a reusable header. The complete program is a bit larger if put into a single source file:</p>

<p>```c++</p>

<h1>include <string></h1>

<h1>include <cctype></h1>

<h1>include <iostream></h1>

<p>static std::string raw_input(const char *prompt)
{</p>

<pre><code>std::string answer;
std::cout &lt;&lt; prompt &lt;&lt; std::flush;
std::getline(std::cin, answer);
return answer;
</code></pre>

<p>}</p>

<p>static std::string &amp;&amp;lower(std::string &amp;&amp;s)
{</p>

<pre><code>for (auto &amp;c : s)
    c = std::tolower(c);
return std::forward&lt;std::string&gt;(s);
</code></pre>

<p>}</p>

<p>static bool in(const std::string &amp;)
{</p>

<pre><code>return false;
</code></pre>

<p>}</p>

<p>template &lt;size_t N, typename &hellip;Args>
static bool in(const std::string &amp;s, const char (&amp;arg0)[N], Args &amp;&amp; &hellip;argN)
{</p>

<pre><code>return s == arg0 || in(s, std::forward&lt;Args&gt;(argN)...);
</code></pre>

<p>}</p>

<p>int main()
{</p>

<pre><code>while (!in(lower(raw_input("Could you please give me $100? ")),
           "y", "yes", "ok", "true", "sure", "of course", "why not?"))
    std::cout &lt;&lt; "We don't take «No» for an answer. Did you mean «Yes»?"
              &lt;&lt; std::endl;
std::cout &lt;&lt; "Thank you!" &lt;&lt; std::endl;
</code></pre>

<p>}
```</p>

<p><a href="http://en.wikipedia.org/wiki/Variadic_templates">Variadic templates</a> and <a href="http://en.wikipedia.org/wiki/Tail_call">tail recursion</a> can do magic (and compiler unrolls everything, I’ve checked).</p>

<p>I don’t want to start a language war or anything, but my opinion is that Python’s beauty is not in its simple or powerful syntax. Not at all.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why C++ Member Function Pointers Are 16 Bytes Wide]]></title>
    <link href="http://741MHz.com/wide-pointers/"/>
    <updated>2013-04-28T00:00:00-04:00</updated>
    <id>http://741MHz.com/wide-pointers</id>
    <content type="html"><![CDATA[<p>When talking about pointers, we generally assume it is something that can be represented by <code>void*</code> pointer which has a size of 8 bytes on the x86_64 architecture. For instance, here is an excerpt from a <a href="http://en.wikipedia.org/wiki/X86-64#Architectural_features">Wikipedia article about x86_64</a>:</p>

<blockquote><p>Pushes and pops on the stack are always in 8-byte strides, and <strong>pointers are 8 bytes wide</strong>.</p></blockquote>

<p>From the CPU point of view, pointer is nothing but a memory address, and all memory addresses are represented by 64-bit on the x86_64, so the assumption about 8 bytes is correct. It is also not that hard to verify this by simply printing sizes of pointers of different types:</p>

<p>```c++</p>

<h1>include <iostream></h1>

<p>int main() {</p>

<pre><code>std::cout &lt;&lt;
    "sizeof(int*)      == " &lt;&lt; sizeof(int*) &lt;&lt; "\n"
    "sizeof(double*)   == " &lt;&lt; sizeof(double*) &lt;&lt; "\n"
    "sizeof(void(*)()) == " &lt;&lt; sizeof(void(*)()) &lt;&lt; std::endl;
</code></pre>

<p>}
```</p>

<p>Compile and run the above program, and it will tell that all pointers are of size 8:</p>

<p><code>
$ uname -i
x86_64
$ g++ -Wall ./example.cc
$ ./a.out
sizeof(int*)      == 8
sizeof(double*)   == 8
sizeof(void(*)()) == 8
</code></p>

<p>In C++, however, there is one exception — pointer to a member function. Interestingly enough, the size of a pointer to a member function is twice the size of any other pointer. This can be easily verified with this simple program which would print “16”:</p>

<p>```c++</p>

<h1>include <iostream></h1>

<p>struct Foo {</p>

<pre><code>void bar() const { }
</code></pre>

<p>};</p>

<p>int main() {</p>

<pre><code>std::cout &lt;&lt; sizeof(&amp;Foo::bar) &lt;&lt; std::endl;
</code></pre>

<p>}
```</p>

<p>Does this mean that Wikipedia is wrong? No, not at all. From the hardware point of view all pointers are still 8 bytes wide. So what is a pointer to a member function then? It is a feature of the C++ language, a concept that does not map directly to hardware and is being implemented in runtime (by compilers) resulting in a slight overhead that oftentimes incurs a performance penalty. The C++ language specification is not concerned with implementation details very much and there is nothing explaining this type of pointers. Luckily, there is Itanium C++ ABI specification that devotes itself to standardizing implementation details of the C++ runtime — it explains, for example, how virtual tables, RTTI and exceptions are implemented, and it also explains member pointers in §2.3:</p>

<blockquote><p>A pointer to member function is a pair as follows:</p>

<p>ptr:</p>

<p>For a non-virtual function, this field is a simple function pointer. For a virtual function, it is 1 plus the virtual table offset (in bytes) of the function, represented as a ptrdiff_t. The value zero represents a NULL pointer, independent of the adjustment field value below.</p>

<p>adj:</p>

<p>The required adjustment to this, represented as a ptrdiff_t.</p></blockquote>

<p>So a member function pointer is 16 bytes instead of 8 because along with a simple function pointer it also must store the information about how to adjust “this” pointer (something that is always passed to non-static member functions implicitly). What ABI spec does not say is why and when such an adjustment is required. It might not be that obvious at first. Let’s take a look at the following class hierarchy:</p>

<p>```c++
struct A {</p>

<pre><code>void foo() const { }
char pad0[32];
</code></pre>

<p>};</p>

<p>struct B {</p>

<pre><code>void bar() const { }
char pad2[64];
</code></pre>

<p>};</p>

<p>struct C : A, B
{ };
```</p>

<p>Both A and B have a non-static member functions and a data member. Both of those methods can access data member of their class through an implicitly passed “this” pointer. In order to access any data member, the offset from the base address of the class object containing it, represented as a ptrdiff_t, is applied to “this” pointer. Things start to get complicated with multiple inheritance. What happens when we have a class C inherit both A and B? The compiler would take A and B and place them together in memory, where B comes after A. Therefore, methods of class A and methods of class B would “see” a different value of “this” pointer. This can be easily verified in practice, for example:</p>

<p>```c++</p>

<h1>include <iostream></h1>

<p>struct A {</p>

<pre><code>void foo() const {
    std::cout &lt;&lt; "A's this: " &lt;&lt; this &lt;&lt; std::endl;
}
char pad0[32];
</code></pre>

<p>};</p>

<p>struct B {</p>

<pre><code>void bar() const {
    std::cout &lt;&lt; "B's this: " &lt;&lt; this &lt;&lt; std::endl;
}
char pad2[64];
</code></pre>

<p>};</p>

<p>struct C : A, B
{ };</p>

<p>int main()
{</p>

<pre><code>C obj;
obj.foo();
obj.bar();
</code></pre>

<p>}
```</p>

<p><code>
$ g++ -Wall -o test ./test.cc &amp;&amp; ./test
A's this: 0x7fff57ddfb48
B's this: 0x7fff57ddfb68
</code></p>

<p>As you can see, “this” pointer’s value passed to B’s method is greater than one passed to A’s method by 32 bytes – an exact size of class A. But what happens when we have the following function that calls a method of class C by pointer?</p>

<p>```c++
void call_by_ptr(const C &amp;obj, void (C::*mem_func)() const) {</p>

<pre><code>(obj.*mem_func)();
</code></pre>

<p>}
```</p>

<p>Depending on what method is being called, a different value of “this” must be passed. But the “call_by_ptr” function doesn’t know whether it got a pointer to “foo()” or a pointer to “bar()”. The only time when this information is available is when address of either of those methods is taken. And that’s why a pointer to a member function also has information about how to adjust “this” before calling a method. Now, let’s put all of that together into a simple program that demonstrates what is going on “under the hood”:</p>

<p>```c++</p>

<h1>include <iostream></h1>

<p>struct A {</p>

<pre><code>void foo() const {
    std::cout &lt;&lt; "A's this:\t" &lt;&lt; this &lt;&lt; std::endl;
}
char pad0[32];
</code></pre>

<p>};</p>

<p>struct B {</p>

<pre><code>void bar() const {
    std::cout &lt;&lt; "B's this:\t" &lt;&lt; this &lt;&lt; std::endl;
}
char pad2[64];
</code></pre>

<p>};</p>

<p>struct C : A, B
{ };</p>

<p>void call_by_ptr(const C &amp;obj, void (C::*mem_func)() const)
{</p>

<pre><code>void *data[2];
std::memcpy(data, &amp;mem_func, sizeof(mem_func));
std::cout &lt;&lt; "------------------------------\n"
    "Object ptr:\t" &lt;&lt; &amp;obj &lt;&lt;
    "\nFunction ptr:\t" &lt;&lt; data[0] &lt;&lt;
    "\nPointer adj:\t" &lt;&lt; data[1] &lt;&lt; std::endl;
(obj.*mem_func)();
</code></pre>

<p>}</p>

<p>int main()
{</p>

<pre><code>C obj;
call_by_ptr(obj, &amp;C::foo);
call_by_ptr(obj, &amp;C::bar);
</code></pre>

<p>}
```</p>

<p>The above program prints the following:</p>

<h2>```</h2>

<p>Object ptr: 0x7fff535dfb28
Function ptr:   0x10c620cac
Pointer adj:    0</p>

<h2>A&rsquo;s this:   0x7fff535dfb28</h2>

<p>Object ptr: 0x7fff535dfb28
Function ptr:   0x10c620cfe
Pointer adj:    0x20
B&rsquo;s this:   0x7fff535dfb48
```</p>

<p>Hopefully that clears things up a little bit.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Exceptions, Stack Trace and GDB Automation]]></title>
    <link href="http://741MHz.com/throw-stacktrace/"/>
    <updated>2013-04-16T00:00:00-04:00</updated>
    <id>http://741MHz.com/throw-stacktrace</id>
    <content type="html"><![CDATA[<p>The tricky part about any exception is that the stack is already unwinded by the time exception is caught and there is no easy way to figure out from which part of the code it was thrown. Have you ever caught an exception that has no information that can be used to find where the problem is? The one that says «this should never happen» or even has no text at all. Hopefully, this doesn’t happen to you very often. But if you work with a large C++ codebase with tons of different components written by different developers then sooner or later it would definitely happen. It can be quite disappointing and take a lot of time going through the pile of somebody else’s code trying to figure out what went wrong. So you must be prepared. I might be a little bit unlucky in this regard – this happened to me a lot, so I decided to share a few ways for overcoming this type of situations.</p>

<h2>Backtrace API</h2>

<p>Quite a few C runtime libraries provide a mechanism to examine the current thread’s call stack. It consists of three functions declared in <code>execinfo.h</code> header:</p>

<p>```c
int backtrace(void** array, int size);</p>

<p>char<em><em> backtrace_symbols(void</em> const</em> array, int size);</p>

<p>void backtrace_symbols_fd(void<em> const</em> array, int size, int fd);
```</p>

<p>Using those functions, one can access the stack trace at any given point of program execution. Here is a simple example that prints the stack to standard output:</p>

<p>```c++</p>

<h1>include &lt;execinfo.h></h1>

<h1>include <iostream></h1>

<p>int main()
{</p>

<pre><code>void *callstack[256];
int frames = ::backtrace(
    callstack, sizeof(callstack) / sizeof(callstack[0]));
char **symbols = ::backtrace_symbols(callstack, frames);
std::cout &lt;&lt; "Stack Trace:\n";
for (int i = 0; i &lt; frames; ++i) {
    std::cout &lt;&lt; '\t' &lt;&lt; symbols[i] &lt;&lt; '\n';
}
std::free(symbols);
</code></pre>

<p>}
```</p>

<p>This method can be used to get the stack trace before the exception is thrown and before the stack is unwinded. In order to do that, one could define a custom exception class that grabs the stack trace in its constructor. For example:</p>

<p>```c++</p>

<h1>include &lt;execinfo.h></h1>

<h1>include <string></h1>

<h1>include <stdexcept></h1>

<h1>include <cstdlib></h1>

<h1>include <iostream></h1>

<p>class Exception : public std::exception {
  public:</p>

<pre><code>Exception() {
    grab_backtrace();
}

explicit Exception(const std::string &amp;reason) : reason_(reason) {
    reason_.append(1, '\n');
    grab_backtrace();
}

virtual ~Exception() throw() { }

virtual const char *what() const throw() {
    return reason_.c_str();
}
</code></pre>

<p>  private:</p>

<pre><code>void grab_backtrace() {
    void *callstack[256];
    int frames = ::backtrace(
        callstack, sizeof(callstack) / sizeof(callstack[0]));
    char **symbols = backtrace_symbols(callstack, frames);
    try {
        reason_.append("Stack Trace:");
        for (int i = 0; i &lt; frames; ++i) {
            reason_.append("\n\t").append(symbols[i]);
        }
    } catch(const std::exception &amp;) {
        std::free(symbols);
        throw;
    }
    std::free(symbols);
}

std::string reason_;
</code></pre>

<p>};</p>

<p>static void do_something(int n, int i = 0)
{</p>

<pre><code>if (i &lt; n) {
    do_something(n, ++i);
} else {
    throw Exception("Recursion limit exceeded");
}
</code></pre>

<p>}</p>

<p>int main(int argc, char *argv[])
{</p>

<pre><code>try {
    do_something(argc &gt; 1 ? std::atoi(argv[1]) : 10, argc);
} catch(const std::exception &amp;e) {
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
    return EXIT_FAILURE;
}
</code></pre>

<p>}
```</p>

<p>So far so good! Here is an example of running the above program:</p>

<p>```
$ clang++ -Wall -pedantic ./test.cpp &amp;&amp; ./a.out 3
Recursion limit exceeded
Stack Trace:</p>

<pre><code>0   a.out                0x00000001034fa7af _ZN9Exception14grab_backtraceEv + 63
1   a.out                0x00000001034fa6f4 _ZN9ExceptionC2ERKSs + 116
2   a.out                0x00000001034fa56d _ZN9ExceptionC1ERKSs + 29
3   a.out                0x00000001034fa33c _Z12do_somethingii + 140
4   a.out                0x00000001034fa2df _Z12do_somethingii + 47
5   a.out                0x00000001034fa42d main + 93
6   libdyld.dylib        0x00007fff935e27e1 start + 0
</code></pre>

<p>```</p>

<p>Unfortunately, there are a few problems with this approach. Firstly, there no file names and no line numbers. Secondly, this approach requires to use the “Exception” class as a base class of all exceptions in the project (well, at least for those you want to get a stack trace for), which indeed can be very problematic if not impossible. But even if all of the above is fine with you, this approach may still not work out for you because frame pointers can be omitted in optimized builds. For example, omitting frame pointers is a default behavior of recent GCC compilers for x86_64 platforms (which can also be turned on/off using <code>-fomit-frame-pointer</code> option). Our call stack becomes useless if frame pointers are omitted:</p>

<p>```
$ clang++ -Wall -fomit-frame-pointer ./test.cpp &amp;&amp; ./a.out 3
Recursion limit exceeded
Stack Trace:</p>

<pre><code>0   a.out                0x0000000105eca82d _ZN9Exception14grab_backtraceEv + 61
</code></pre>

<p>```</p>

<p>Depending on the system, there could be other requirements in order to make this API work. For example, GNU runtime requires you to specify “-rdynamic” flag to instruct the linker to add all symbols, not only used ones, to the dynamic symbol table. So don’t forget to read a manual page for this API in your system before using this.</p>

<h2>__FILE__ and __LINE__</h2>

<p>C++ has many <a href="http://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html">standard predefined macros</a>. <code>__FILE__</code> and <code>__LINE__</code> macros are those two that come handy in order to identify a point in a program:</p>

<p><code>__FILE__</code>  macros expands to the name of the current input file, in the form of a C string constant. This is the path by which the preprocessor opened the file, not the short name specified in ‘#include’ or as the input file name argument. For example, “/usr/local/include/myheader.h” is a possible expansion of this macros.</p>

<p><code>__LINE__</code> macros expands to the current input line number, in the form of a decimal integer constant. While we call it a predefined macro, it’s a pretty strange macro, since its “definition” changes with each new line of source code.|</p>

<p>Using the above macros, it is possible to include both file and line information along with exception’s text, or maybe as additional member fields of any given exception class. There are multiple choices. Here is an example of one of possible implementations:</p>

<p>```c++</p>

<h1>include <stdexcept></h1>

<h1>include <cstdlib></h1>

<h1>include <iostream></h1>

<p>class Exception : public std::runtime_error {
  public:</p>

<pre><code>template &lt;unsigned int location_len&gt;
inline Exception(const char (&amp;location)[location_len],
                 const std::string &amp;reason)
    : std::runtime_error(reason + location)
{ }

virtual ~Exception() throw() { }
</code></pre>

<p>};</p>

<h1>define MY_THROW_STR_I(Arg) #Arg</h1>

<h1>define MY_THROW_STR(Arg) MY_THROW_STR_I(Arg)</h1>

<h1>define MY_THROW(Type, &hellip;)                                             \</h1>

<pre><code>do {                                                                \
    throw Type(" @ "; __FILE__ ";:" MY_THROW_STR(__LINE__), ##__VA_ARGS__); \
} while (0)
</code></pre>

<p>static void do_something(int n, int i = 0)
{</p>

<pre><code>if (i &lt; n) {
    do_something(n, ++i);
} else {
    MY_THROW(Exception, "Recursion limit exceeded");
}
</code></pre>

<p>}</p>

<p>int main(int argc, char *argv[])
{</p>

<pre><code>try {
    do_something(argc &gt; 1 ? std::atoi(argv[1]) : 10, argc);
} catch(const std::exception &amp;e) {
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
    return EXIT_FAILURE;
}
</code></pre>

<p>}
```</p>

<p>When the exception is caught and printed, the source file name and a line numbers are included, which makes it easy to trace the origins of such an exception:</p>

<p><code>
$ ./a.out
Recursion limit exceeded @ ./test.cpp:26
</code></p>

<p>Of course, this does not include a stack trace. But it works if frame pointers are omitted, tail recursion optimization is applied, or even if all symbol names are stripped out of the executable. There is one problem though — it may not be useful without a stack trace in certain cases. For example, one may declare a helper function used to throw an exception, like this:</p>

<p>```c++
<strong>attribute</strong>((noreturn)) void report_error(const std::string &amp;reason) {</p>

<pre><code>MY_THROW(Exception, reason);
</code></pre>

<p>}
```</p>

<p>In that case, the file and line of the exception origins will always be the same even if it was called from different places in the program. So this approach is also not a cure for all diseases.</p>

<h2>GDB Scripting: Automatic Backtrace on Exception Catchpoints</h2>

<p>And the last but not least method is to use <a href="http://www.gnu.org/software/gdb/">GDB debugger</a>. If you are not familiar with this debugger, you definitely should spend some time learning it. It is one of the most powerful tools out there. And it comes extremely handy when dealing with exceptions.</p>

<p><a href="http://sourceware.org/gdb/onlinedocs/gdb/Set-Catchpoints.html">GDB provides special catch points</a>, including those to catch exceptions being thrown, caught or even unhandled. We are interested in exceptions that are being thrown and so must use <code>catch throw</code> command. Here is an example of manually using GDB in order to examine a stack trace before the exception is thrown:</p>

<p>```
$ gdb -args ./a.out 5
Reading symbols from /tmp/a.out&hellip;done.
(gdb) catch throw
Catchpoint 1 (throw)
(gdb) run
Starting program: /tmp/a.out 5
Catchpoint 1 (exception thrown), <strong>cxxabiv1::</strong>cxa_throw (obj=0x6030d0, tinfo=0x401420 , dest=0x401198 )</p>

<pre><code>at ../../../../libstdc++-v3/libsupc++/eh_throw.cc:70
</code></pre>

<p>70    header->exc.unexpectedHandler = __unexpected_handler;
(gdb) backtrace</p>

<h1>0  <strong>cxxabiv1::</strong>cxa_throw (obj=0x6030d0, tinfo=0x401420 , dest=0x401198 )</h1>

<pre><code>at ../../../../libstdc++-v3/libsupc++/eh_throw.cc:70
</code></pre>

<h1>1  0x0000000000400fee in report_error (reason=&ldquo;Recursion limit exceeded&rdquo;) at ./test.cpp:25</h1>

<h1>2  0x000000000040105d in do_something (n=5, i=5) at ./test.cpp:33</h1>

<h1>3  0x000000000040102e in do_something (n=5, i=5) at ./test.cpp:31</h1>

<h1>4  0x000000000040102e in do_something (n=5, i=4) at ./test.cpp:31</h1>

<h1>5  0x000000000040102e in do_something (n=5, i=3) at ./test.cpp:31</h1>

<h1>6  0x00000000004010cb in main (argc=2, argv=0x7fffffffe1f8) at ./test.cpp:40</h1>

<p>(gdb) continue
Continuing.
Recursion limit exceeded @ ./test.cpp:25
[Inferior 1 (process 3865) exited with code 01]
(gdb) quit
```</p>

<p>At first, this might sound silly because in the real world a program may encounter a lot of exceptions and manually typing “backtrace” and “continue” every type that happens is nothing but a waste of time. But there is one trick — GDB can be automated. There are two ways of doing this — use a batch mode or a more sophisticated <a href="http://sourceware.org/gdb/wiki/PythonGdbTutorial">Python scripting</a>. For our purpose, a batch script will do just fine. Here is a simple script that turns off verbose output and paging, sets up a <code>throw</code> catch point and executes <code>backtrace</code> + <code>continue</code> commands every time the event is caught:</p>

<p><code>
set verbose off
set pagination off
catch throw
commands
backtrace
continue
end
run
quit
</code></p>

<p>Save the above script into a file, and then run GDB in batch mode telling it to use that file, which in my case is called “gdb_bt_script”:</p>

<p>```
$ gdb -n -batch -x ./gdb_bt_script &mdash;args ./a.out 5
Catchpoint 1 (throw)
Catchpoint 1 (exception thrown), <strong>cxxabiv1::</strong>cxa_throw (obj=0x6030d0, tinfo=0x401420 , dest=0x401198 ) at ../../../../libstdc++-v3/libsupc++/eh_throw.cc:70
70    header->exc.unexpectedHandler = __unexpected_handler;</p>

<h1>0  <strong>cxxabiv1::</strong>cxa_throw (obj=0x6030d0, tinfo=0x401420 , dest=0x401198 ) at ../../../../libstdc++-v3/libsupc++/eh_throw.cc:70</h1>

<h1>1  0x0000000000400fee in report_error (reason=&ldquo;Recursion limit exceeded&rdquo;) at ./test.cpp:25</h1>

<h1>2  0x000000000040105d in do_something (n=5, i=5) at ./test.cpp:33</h1>

<h1>3  0x000000000040102e in do_something (n=5, i=5) at ./test.cpp:31</h1>

<h1>4  0x000000000040102e in do_something (n=5, i=4) at ./test.cpp:31</h1>

<h1>5  0x000000000040102e in do_something (n=5, i=3) at ./test.cpp:31</h1>

<h1>6  0x00000000004010cb in main (argc=2, argv=0x7fffffffe1f8) at ./test.cpp:40</h1>

<p>Recursion limit exceeded @ ./test.cpp:25
[Inferior 1 (process 5849) exited with code 01]
$
```</p>

<p>Whoala! Now we get a full stack trace including function parameters, their values, and file and line numbers. If the program is optimized and has no debug symbols, however, we get a little bit less:</p>

<p>```
$ gdb -n -batch -x ./gdb_bt_script &mdash;args ./a.out 5
Catchpoint 1 (throw)
Catchpoint 1 (exception thrown), <strong>cxxabiv1::</strong>cxa_throw (obj=0x6030d0, tinfo=0x401470 , dest=0x401270 ) at ../../../../libstdc++-v3/libsupc++/eh_throw.cc:70
70    header->exc.unexpectedHandler = __unexpected_handler;</p>

<h1>0  <strong>cxxabiv1::</strong>cxa_throw (obj=0x6030d0, tinfo=0x401470 , dest=0x401270 ) at ../../../../libstdc++-v3/libsupc++/eh_throw.cc:70</h1>

<h1>1  0x00000000004010a8 in report_error(std::string const&amp;) ()</h1>

<h1>2  0x000000000040121e in do_something(int, int) ()</h1>

<h1>3  0x0000000000400ef6 in main ()</h1>

<p>Recursion limit exceeded @ ./test.cpp:25
[Inferior 1 (process 1877) exited with code 01]
```</p>

<p>Yet still a lot more than we get using backtrace API. But the most beautiful part is that this method does not require any code changes and works for pretty much any binary.</p>

<h2>The End</h2>

<p>Those were three fundamental methods that can help to identify a place where exception is thrown from. They are not mutually exclusive. Each has its cons and pros. I personally prefer to use GDB because it doesn’t require a code change, but use other two methods as well, depending on a situation. It is up to you to decide which one to use.</p>

<p>Hope it helps and Good Luck!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Two Different Languages - C and C++]]></title>
    <link href="http://741MHz.com/c-vs-cxx/"/>
    <updated>2013-04-15T00:00:00-04:00</updated>
    <id>http://741MHz.com/c-vs-cxx</id>
    <content type="html"><![CDATA[<p>Good news everyone, we are looking for a C/C++ developer! Wait, that’s not good news at all!</p>

<p>You see, the term «C/C++» is likely to piss off those who actually know both C and C++. On the other hand, majority of C++ developers mistakenly think they know C. And it would take at least a year or two for a C developer to learn C++. Yet «C/C++» is mentioned in way too many job postings. So who exactly are we looking for?</p>

<p>Let’s start by asking a simple question — what would the main() function return in the below C/C++ program?</p>

<p>```c++
extern int T;</p>

<p>int main()
{</p>

<pre><code>struct T { int a; int b; };
return sizeof(T) + sizeof('T');
</code></pre>

<p>}
```</p>

<p>Of course it depends on architecture. But let’s assume that size of int is 4 bytes and structure T has no extra padding. The code is legal in both C and C++. Yet the correct answer depends on whether this is a C or C++ program. If it is a C program then the correct answer is 8. In case of C++ the answer is 9.</p>

<h2>C is not C++</h2>

<p>C++ originated back in 1979 and at that time it was based on C. It wasn’t even called C++ — its first name was «C with Classes». The language was renamed to «C++» only in 1983. At that time, both languages were closely related. However, from that point both C and C++ took a different evolution path and today, some 30+ years later, both languages are as different as Objective-C and C++, Java and C#, Python and Ruby, OCaml and F#. There is only one catch — the basic syntax of both is very similar to such a degree that it is possible to have a program that is both legal C and legal C++, which may or may not behave differently. Generally, everyone knows that C++ has tons of features that are not available in C but any C code can be compiled as C++. Therefore, C++ developers also think that they know C. And in most cases they are dangerously mistaken. Below is a list of the most common features of C language serving as traps for C++ fellows.</p>

<h3>Casting void pointer</h3>

<p>In C, void pointer can be implicitly casted to a pointer of any other type. For example:</p>

<p><code>c
void *ptr = 0xDEADDEAD;
int *i = ptr;
</code></p>

<p>C developers use this convenient feature all the time. However, any C++ compiler would choke on that and die.</p>

<h3>Implicit function declaration</h3>

<p>In C, it is not always necessary to declare a function before using it. Using an undeclared function implicitly declares it. This feature has been declared deprecated since 1999 but is still used here and there. For example:</p>

<p>```c
int main() {</p>

<pre><code>    return foo();
</code></pre>

<p>}</p>

<p>int foo() {</p>

<pre><code>    return 0;
</code></pre>

<p>}
```</p>

<p>A perfectly legal C program that is illegal C++:</p>

<p><code>
$ gcc ./test.c
$ g++ ./test.cpp
./test.cpp: In function ‘int main()’:
./test.cpp:3: error: ‘foo’ was not declared in this scope
</code></p>

<h3>No arguments vs any arguments</h3>

<p>In C, function prototype without parameters imply that function accepts any number of arguments and it is legal to call such a function with one or more arguments. In C++, function prototype without parameters means that function accepts no arguments and it is illegal to call such function with arguments. For example:</p>

<p>```c
void foo();</p>

<p>int main() {</p>

<pre><code>    foo(1, "hello");
</code></pre>

<p>}</p>

<p>void foo() {
}
```</p>

<p>The above is absolutely legal C code that won’t compile as C++. As a matter of fact, I haven’t seen many C++ developers who can tell the difference between <code>void foo();</code> and <code>void foo(void);</code></p>

<h3>Crossing initialization with goto or switch</h3>

<p>```c
int main()
{</p>

<pre><code>goto out;
int i = 1;
</code></pre>

<p>  out:</p>

<pre><code>return 0;
</code></pre>

<p>}
```</p>

<p>The above is a perfectly legal C code but is rejected by C++ compiler as C++ does not allow to cross initialization:</p>

<p>```
$ clang++ ./test.cpp
./test.cpp:3:5: error: goto into protected scope</p>

<pre><code>goto out;
^
</code></pre>

<p>./test.cpp:4:9: note: jump bypasses variable initialization</p>

<pre><code>int i = 1;
    ^
</code></pre>

<p>1 error generated.
```</p>

<h3>Keywords clash</h3>

<p>C++ would fail to compile any legal C code that happen to use C++ keywords:</p>

<p>```c
struct foo {</p>

<pre><code>int old;
int new;
</code></pre>

<p>};
```</p>

<h2>More! More! More!</h2>

<p>Oh, you knew that? If you knew all of the above and still consider yourself a “C/C++” developer, hold on a second. Name at least 10 more differences. Huh?</p>

<ul>
<li>In C++, comma operator can yield an l-value. In C it cannot.</li>
<li>C does not allow duplicate typedefs while C++ does.</li>
<li>C++ does not allow non-prototype function declarations while C does.</li>
<li>C allows struct, union and enum to be declared in function prototypes, C++ doesn’t.</li>
<li>C allows for implicit discard of pointer const qualifiers. This trick won’t work in C++.</li>
<li>In C++, struct, union and enum declarations automatically imply a typedef with the same name. This is not the case in C.</li>
<li>Character literals in C are of type int. In C++ they are of type char.</li>
<li>C++ implicitly treats any const global as file scope unless it is explicitly declared extern, unlike C in which extern is the default.</li>
<li>Functions market as “inline” in C are of file scope whereas they have external linkage by default in C++.</li>
<li>C has VLA (Variable Length Arrays) support whereas C++ does not (until C++14).</li>
</ul>


<p>And the list of technical differences/incompatibilities of C and C++ can go on and on. The list is so big that it is impossible to fit it into a blog post. But if you are interested, check out References section in the bottom of this post.</p>

<p>Aside of technical differences, it would also be a mistake not to mention the coding style. Not a formatting style or using tabs versus spaces, but coding style. For example, C++ developers would always cast a result of <code>malloc()</code> whereas C developers would almost never do that.</p>

<h2>Grammar of «C/C++»</h2>

<p>Trying to figure out the meaning behind «C/C++», I dug the usage of slash as a punctuation sign in English text. I have never learn English grammar in school so you may want to check me on this one. Anyhow, according to Wikipedia the slash is most commonly used as the word substitute for “or” which indicates a choice (often mutually-exclusive) is present.</p>

<p>If that is the case, then companies are actually looking for either C or C++ developers, not both. Which doesn’t make any sense at all. Why nobody is looking for “Cobol/Ada” or “Lisp/Verilog” developers? Looking at other industries, there seem to be no companies searching for “Linguist/Plumber”-like people.</p>

<p>So the grammar doesn’t seem to back up the usage of «C/C++» term. This leaves everyone guessing as to what it actually means and the only way to figure out is from the context.</p>

<h2>What it actually means</h2>

<p>The actual meaning of «C/C++» depends. Here are some examples of what this means according to my observations.</p>

<p>In job postings, “We are looking for C/C++ developers” generally means “We are looking for C++ developers, nobody knows C here but why not put that in a title, too?”</p>

<p>When somebody brags about being a “C/C++” developers it means they don’t really know any of those languages but learned to write a “Hello, World!” application using printf() and compile it with C++ compiler.</p>

<p>In forums, «C/C++» section is usually dedicated for C++ crowd that might as well be able to answer some C-related questions if you get lucky.</p>

<h2>Tip: Don’t Use «C/C++»</h2>

<p>If you are looking for a developer, make sure you clearly specify requirements and avoid the use of «C/C++». If it so happens that you are actually looking for someone who knows both, say «C and C++». If you are willing to spend a few years teaching C developer C++ language, say «C++ developer or C developer willing to learn C++». Using «C/C++» will only bring confusion to those reading the job posting.</p>

<p>End of rant.</p>

<h2>References</h2>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Slash_(punctuation">Slash in English text.</a></li>
<li><a href="http://david.tribble.com/text/cdiffs.htm">Incompatibilities Between ISO C and ISO C++</a> by David R. Tribble</li>
<li><a href="http://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B">Compatibility of C and C++</a></li>
<li><a href="http://c-faq.com/malloc/mallocnocast.html">What’s wrong with casting malloc’s return value?</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
