<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | Ranting @ 741 MHz]]></title>
  <link href="http://741MHz.com/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://741MHz.com/"/>
  <updated>2013-12-08T17:44:13-05:00</updated>
  <id>http://741MHz.com/</id>
  <author>
    <name><![CDATA[741MHz.com]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Smart Command Line Options Parsing]]></title>
    <link href="http://741MHz.com/smart-getopt/"/>
    <updated>2013-12-03T08:47:00-05:00</updated>
    <id>http://741MHz.com/smart-getopt</id>
    <content type="html"><![CDATA[<p>A countless number of command line programs have been written since the invention of computers. Most of them parse command line options and spew out errors and usage messages if a user enters an unknown option or simply makes a typo. Examples are not far to seek. Make a typo trying to commit your changes into SVN repository and <a href="http://en.wikipedia.org/wiki/Apache_Subversion">Subversion</a> would bail out with errors:</p>

<p><code>bash
$ svn commir
Unknown command: 'commir'
Type 'svn help' for usage.
</code></p>

<p>There are command line tools that are standing out among others, impress with their intelligence and deliver unforgettable user experience.</p>

<p>One of them is <a href="http://git-scm.com/">Git</a>. If it encounters an unknown option, it can analyze it, guess what user meant and suggest correct options:</p>

<p>```bash
$ git commir
git: &lsquo;commir&rsquo; is not a git command. See &lsquo;git &mdash;help&rsquo;.</p>

<p>Did you mean this?</p>

<pre><code>commit
</code></pre>

<p>```</p>

<p>To see this kind of feature in a command line tool is a pleasant surprise and could catch user’s attention. But if we take one step back and try to reckon programs with similar features, there will be a lot. Any decent word processors would have spell-checking feature that not only can detect mistakes but also suggest a correct spelling. Proofreading tools. Search engines often guess what we are looking for as well.</p>

<p><img src="/images/levenshtein-getopt/kute.png"></p>

<p>So what kind of sorcery is this?</p>

<h2>String Metrics</h2>

<p>All of the similar algorithms are based on string metric algorithms that measure similarity or dissimilarity between two strings for <a href="http://en.wikipedia.org/wiki/Approximate_string_matching">approximate matching</a> or comparison and in <a href="http://en.wikipedia.org/wiki/Approximate_string_matching">fuzzy string searching</a>. The similarity or dissimilarity between two strings of text is commonly known as string distance.</p>

<p>There are <a href="http://en.wikipedia.org/wiki/String_metrics">a number of different string metrics algorithms</a>. The most widely known string metric is the Levenshtein Distance, also known as Edit Distance.</p>

<p>Informally, the Levenshtein distance between two words is the minimum number of single-character edits (insertion, deletion, substitution) required to change one word into the other. One could apply this algorithm to determine which one of the possible words is the most similar by comparing a number of character edits it requires to transform one word into another.</p>

<h2>How Git Does This</h2>

<p>Since <a href="http://git-scm.com">Git</a> is <a href="http://git-scm.com/about/free-and-open-source">free and open source</a>, we can check how it does the command line argument suggestion, and what algorithm is being used for that.</p>

<p>The Git source code can be downloaded or viewed online at <a href="https://github.com/git/git">https://github.com/git/git</a>. All of the command line options handling is implemented in <a href="https://github.com/git/git/blob/master/help.c">help.c</a> file, and the suggestion is being made by <code>help_unknown_cmd()</code> function on line 293.</p>

<p>After quickly grasping through the code, it turns out that Git is using a <a href="http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance">Damerau–Levenshtein distance algorithm</a> to calculate similarities between an unknown command and a list of supported commands. The implementation of this algorithm consists of two small files &ndash; <a href="https://github.com/git/git/blob/master/levenshtein.h">levenshtein.h</a> and <a href="https://github.com/git/git/blob/master/levenshtein.c">levenshtein.c</a>.</p>

<h2>Use It In Your Program</h2>

<p>To see how hard it would be to implement something similar, we have decided to borrow the algorithm implementation and use it to implement a simple command line tool in C++.</p>

<p>The basic idea is to accept command line options from a user and function that corresponds to a command name. In case the command name is unknown, use Damerau-Levenshtein algorithm and compare the unknown command to a list of supported ones. The algorithm returns an integer number that is a string distance. The bigger it is, less similar two strings are. Therefore, after comparing all of the strings, we simply store a result in <code>std::map</code> and take the first element as the most likely command user meant to type, but didn’t quite get it right.</p>

<p>Since we are more focused on C++ rather than C, the first is to transform levenshtein.c into a C++ code (alternatively, a <a href="http://www.parashift.com/c++-faq/mixing-c-and-cpp.html">mixing of C and C++</a> code could have been used) and get rid of Git-specific <code>xmalloc()</code> function. Here are the changes:</p>

<p>```diff
&mdash;&ndash; ../git/levenshtein.c    2013-12-03 19:09:52.000000000 -0500
+++ levenshtein.cc  2013-12-03 19:49:40.000000000 -0500
@@ -1,5 +1,6 @@
&ndash;#include &ldquo;cache.h&rdquo;
&ndash;#include &ldquo;levenshtein.h&rdquo;
+#include &ldquo;levenshtein.hh&rdquo;
+#include <cstdlib> // for malloc and free
+#include <cstring> // for strlen</p>

<p> /*
  * This function implements the Damerau-Levenshtein algorithm to
@@ -42,9 +43,9 @@</p>

<pre><code>    int w, int s, int a, int d)
</code></pre>

<p> {</p>

<pre><code>int len1 = strlen(string1), len2 = strlen(string2);
</code></pre>

<ul>
<li>int *row0 = xmalloc(sizeof(int) * (len2 + 1));</li>
<li>int *row1 = xmalloc(sizeof(int) * (len2 + 1));</li>
<li>int *row2 = xmalloc(sizeof(int) * (len2 + 1));</li>
<li>int <em>row0 = (int</em>)malloc(sizeof(int) * (len2 + 1));</li>
<li>int <em>row1 = (int</em>)malloc(sizeof(int) * (len2 + 1));</li>
<li><p>int <em>row2 = (int</em>)malloc(sizeof(int) * (len2 + 1));
int i, j;</p>

<p>for (j = 0; j &lt;= len2; j++)
```</p></li>
</ul>


<p>And a simple command line tool that uses Git&rsquo;s <code>levenshtein()</code> function:</p>

<p>```c++
//
// An example of using Damerau-Levenshtein algorithm
// to suggest a correct command if user enters something
// that we don&rsquo;t know how to handle.
//</p>

<h1>include <cstdlib></h1>

<h1>include <string></h1>

<h1>include <map></h1>

<h1>include &lt;unordered_map></h1>

<h1>include <iostream></h1>

<h1>include &ldquo;levenshtein.h&rdquo;</h1>

<p>// Define command handler function type.
static void on_help() {</p>

<pre><code>std::cout &lt;&lt; "Sure thing! What can I do for you?\n";
</code></pre>

<p>}</p>

<p>static void on_version() {</p>

<pre><code>std::cout &lt;&lt; "I am not versioned, sorry.\n";
</code></pre>

<p>}</p>

<p>static void on_verbose() {</p>

<pre><code>std::cout &lt;&lt; "If you need verbose, go read Twitter!\n";
</code></pre>

<p>}</p>

<p>static void on_say() {</p>

<pre><code>std::cout &lt;&lt; "Oops, my speech speed synthesizer is broken :(\n";
</code></pre>

<p>}</p>

<p>// This function does not need an introduction.
int main(int argc, const char *argv[]) {</p>

<pre><code>// Check that we have at least one argument.
if (argc &lt; 2) {
    std::cerr &lt;&lt; "Please enter a command\n";
    return EXIT_FAILURE;
}

// Deduce command from command line.
std::string cmd{argv[1]};

// Create a list of commands.
const std::unordered_map&lt;
    std::string,
    std::function&lt;void()&gt;
&gt; cmd_map{
    { "help", &amp;on_help },
    { "say", &amp;on_say },
    { "version", &amp;on_version },
    { "verbose", &amp;on_verbose }
};

// Find a command.
auto cmd_it = cmd_map.find(cmd);
if (cmd_it != cmd_map.end()) {
    // Command was found. Run the handler and exit.
    (cmd_it-&gt;second)();
    return EXIT_SUCCESS;
}

// If we get there, the command is unknown.
// First, tell it to the user.
std::cerr &lt;&lt; "Unknown command: " &lt;&lt; cmd &lt;&lt; '\n';

// Use Damerau-Levenshtein algorithm to get similarity
// score with all of the commands we support, then pick
// the best few to suggest to the user.
std::multimap&lt;
    int /* Levenshtein distance, less is better. */,
    std::string /* Supported command */
&gt; dist;

for (auto&amp; p : cmd_map) {
    dist.emplace(
        levenshtein(
            cmd.c_str(), // Command entered by the user.
            p.first.c_str(), // One of the supported commands.
            0, // swap cost
            2, // substitution cost
            1, // insertion cost
            3  // deletion cost
        ),
        p.first
    );
}

// Take the first best guess (lowest distance = better match).
// Suggest a list of commands with the same Levenshtein distance.
// This can be tweaked to show more options, etc..
if (!dist.empty()) {
    auto best_score = dist.begin()-&gt;first;
    std::cerr &lt;&lt; "Did you mean one of these?\n";
    for (auto&amp; p : dist) {
        if (p.first != best_score) {
            // For more option, one could use something like
            // `p.first - best_score &gt; N` where N is max.
            // allowed difference.
            break;
        }
        std::cout &lt;&lt; '\t' &lt;&lt; p.second &lt;&lt; '\n';
    }
}

return EXIT_FAILURE;
</code></pre>

<p>}
```</p>

<p>Compile two files into a binary using Clang:</p>

<p><code>bash
clang++ -Wall -Wextra -pedantic -std=c++11 -o test ./smart_help.cc
</code></p>

<p>The tool supports only three commands — &ldquo;help&rdquo;, &ldquo;version&rdquo;, &ldquo;verbose&rdquo; and &ldquo;say&rdquo;. Let&rsquo;s say user only types &ldquo;ver&rdquo;, in that case it correctly suggest two possible alternatives:</p>

<p>```bash
$ ./test ver
Unknown command: ver
Did you mean one of these?</p>

<pre><code>verbose
version
</code></pre>

<p>```</p>

<p>It doesn&rsquo;t lose face when handling &ldquo;he&rdquo; and &ldquo;s&rdquo; as well:</p>

<p>```
$ ./test he
Unknown command: he
Did you mean one of these?</p>

<pre><code>help
</code></pre>

<p>$ ./test s
Unknown command: s
Did you mean one of these?</p>

<pre><code>say
</code></pre>

<p>```</p>

<p>Of course, it is possible to tweak and tune this program further &ndash; do more error checking, play with different cost weights, do less or more aggressive guessing and so one.</p>

<p>The main point is – it isn’t all that difficult to make your command line option parsing more intelligent and user friendly by using this or similar algorithms. A great <a href="http://en.wikipedia.org/wiki/User_experience">user experience</a> matters a lot.</p>

<p>Maybe one day this would become a standard feature of option parsing libraries like <a href="http://www.boost.org/doc/libs/release/doc/html/program_options.html">Boost’s Program Options</a>, Python’s <a href="http://docs.python.org/2.7/library/argparse.html">argparse</a> and even GNU <a href="http://www.gnu.org/software/libc/manual/html_node/Getopt.html">getopt</a>.</p>

<p>As always, thanks for reading!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Range-Based For Loop]]></title>
    <link href="http://741MHz.com/range-for/"/>
    <updated>2013-11-23T09:23:00-05:00</updated>
    <id>http://741MHz.com/range-for</id>
    <content type="html"><![CDATA[<p>How do you write a &ldquo;for&rdquo; loop in C++? This could be done in many different ways. One could write it like this:</p>

<p>```c++
for (int i = 0; i &lt; N; ++i) {</p>

<pre><code>// ...
</code></pre>

<p>}
```</p>

<p>&hellip; or like this:</p>

<p>```c++
for (iterator_type it = data.begin(); it != data.end(); ++it) {</p>

<pre><code>// ...
</code></pre>

<p>}
```</p>

<p>The most hand-crafted loops though usually looks like this:</p>

<p>```c++
for (iterator_type it = data.begin(), eit = data.end(); it != eit; ++it) {</p>

<pre><code>reference_type&amp; value = *it;
// ...
</code></pre>

<p>}
```</p>

<p>And although professional C++ developers, after years of training their left cerebral hemisphere, quickly grasp any of the above variations of the loop, one cannot not agree that a syntax is a bit inefficient and hard to read, especially for novice developers. So why such a simple thing should be that complicated? Can we do this simpler?</p>

<h2>Range-Based For Loop (Since C++11)</h2>

<p>C++11 provides a new, more readable syntax for iterating over a range of values, which is called a &ldquo;range-based for&rdquo;. Its syntax is very simple:</p>

<p>```c++
for (range_declaration : range_expression)</p>

<pre><code>loop_statement;
</code></pre>

<p>```</p>

<p>For the above syntax, the compiler will produce code similar to the following:</p>

<p>```c++
auto&amp;&amp; <strong>range = range_expression ;
for (auto </strong>begin = begin_expr, <strong>end = end_expr;  </strong>begin != <strong>end; ++</strong>begin) {</p>

<pre><code>range_declaration = *__begin; 
loop_statement;
</code></pre>

<p>}
```</p>

<p>The generated code looks very similar to that of professionally hand-crafted for-loops. But it is a lot easier to both read and write. Let&rsquo;s go over a few code snippets demonstrating how to use this new for loop syntax.</p>

<h2>Examples</h2>

<p>A very simple iteration over a vector:</p>

<p>```c++
std::vector<int> vec { 1, 2, 3, 4, 5 };
for (int v : vec) {</p>

<pre><code>std::cout &lt;&lt; v &lt;&lt; std::endl;
</code></pre>

<p>}
```</p>

<p>For more generic programming, using <a href="/c/auto">&ldquo;auto&rdquo; keyword</a> to let compiler automatically deduce the type is also possible:</p>

<p>```c++</p>

<h1>include <iostream></h1>

<h1>include <vector></h1>

<p>template <typename Range>
void print(const Range&amp; range) {</p>

<pre><code>for (auto&amp; element : range) { // Using "auto" with range-based for loop.
    std::cout &lt;&lt; element &lt;&lt; std::endl;
}
</code></pre>

<p>}</p>

<p>int main() {</p>

<pre><code>std::vector&lt;int&gt; vec { 1, 2, 3, 4, 5 };
print(vec);
</code></pre>

<p>}
```</p>

<p>The range-based for loop also works with plain arrays:</p>

<p>```c++
const int data[] = { 1, 2, 3, 4, 5 };
for (auto&amp; v : data)</p>

<pre><code>std::cout &lt;&lt; v &lt;&lt; std::endl;
</code></pre>

<p>```</p>

<h3>Range-Based For With Custom Types</h3>

<p>One of the questions that is often raised is how to use this new syntax with custom types. There are two possible ways to do this.</p>

<p>The first is to make your custom class provide two member functions: <code>begin()</code> and <code>end()</code>. They should return beginning of the iterate-able range as well as its end, respectively (both should be of the same type). For example:</p>

<p>```c++</p>

<h1>include <iostream></h1>

<h1>include <string></h1>

<p>class custom_container {
public:</p>

<pre><code>const char* begin() const {
    return data_.c_str();
}

const char* end() const {
    return data_.c_str() + data_.size();
}
</code></pre>

<p>private:</p>

<pre><code>std::string data_ = "Hello, Range-Based For!";
</code></pre>

<p>};</p>

<p>int main() {</p>

<pre><code>custom_container container;
for (auto&amp; element : container)
    std::cout &lt;&lt; element;
std::cout &lt;&lt; std::endl;
</code></pre>

<p>}
```</p>

<p>The second approach is to provide freestanding <code>begin()</code> and <code>end()</code> functions for a data type:</p>

<p>```c++</p>

<h1>include <iostream></h1>

<h1>include <string></h1>

<p>class custom_container {
public:</p>

<pre><code>const std::string&amp; data() const { return data_; }
</code></pre>

<p>private:</p>

<pre><code>std::string data_ = "Hello, Range-Based For!";
</code></pre>

<p>};</p>

<p>const char* begin(const custom_container&amp; c) {</p>

<pre><code>return c.data().c_str();
</code></pre>

<p>}</p>

<p>const char* end(const custom_container&amp; c) {</p>

<pre><code>return c.data().c_str() + c.data().size();
</code></pre>

<p>}</p>

<p>int main() {</p>

<pre><code>custom_container container;
for (auto&amp; element : container)
    std::cout &lt;&lt; element;
std::cout &lt;&lt; std::endl;
</code></pre>

<p>}
```</p>

<p>Note that compiler will first look for member functions, then for free-standing functions. This is described in 6.5.4/1 of the C++ standard.</p>

<h2>Old Style Still Apply</h2>

<p>So can we switch to use a new range-based for loops everywhere? Where possible, it could simplify the code and theoretically even make it faster (only if optimizing compiler is way too silly and does not handle loop optimizations well). But in cases where we do need an iterator or perhaps some other loop type like <code>while</code>, the range-based for loop won&rsquo;t work. For example, the below loop cannot be substituted for a new one:</p>

<p>```c++
auto it = map.begin(), eit = map.end();
while (it != eit) {</p>

<pre><code>if (it-&gt;second &gt; 0)
    ++it;
else
    it = map.erase(it);
</code></pre>

<p>}
```</p>

<h2>See Also</h2>

<ul>
<li><a href="/auto-type">C++, Type Safety and Automatic Type Deduction With “auto” Keyword</a></li>
</ul>


<h3>References</h3>

<ul>
<li><a href="http://en.cppreference.com/w/cpp/language/range-for">Range-based for loop @ cppreference.com</a></li>
<li><a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2930.html">N2930 &ndash; Range-Based For Loop Wording (Without Concepts)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Inheriting constructors in C++11]]></title>
    <link href="http://741MHz.com/inheriting-constructors/"/>
    <updated>2013-11-17T13:00:00-05:00</updated>
    <id>http://741MHz.com/inheriting-constructors</id>
    <content type="html"><![CDATA[<p>We have previously reviewed a feature introduced in C++11 that allows a class to delegate work between multiple constructors constructors of a class, called &ldquo;<a href="/delegating-constructors">Delegating Constructors</a>&rdquo; that allows one constructor to call another:</p>

<p>```c++
struct A {</p>

<pre><code>explicit A(int i) : x(i), n(x * (x - 1)) {}
explicit A(double f) : A((int)lround(f)) {}

int x;
int n;
</code></pre>

<p>};
```</p>

<p>Although extremely useful in boosting efficiency, it does not solve the problem when programmer wants to create a derived class that has exactly the same set of constructor as its base class or classes. In which case programmers are forced to tediously duplicate constructors of the base class, for example:</p>

<p>```c++
struct A {</p>

<pre><code>A(int) {}
A(double) {}
A(int, double) {}
</code></pre>

<p>};</p>

<p>struct B : A {</p>

<pre><code>// Programmers are forced to define at least one
// if not all of the following constructors:
B(int v) : A(v) {}
B(double v) : A(v) {}
B(int x, double y) : A(x, y) {}
</code></pre>

<p>};
```</p>

<p>C++11 solves this problem by introducing constructor inheritance. In a derived class, programmers can write a single <code>using T::T;</code> statement that makes a derived class automatically inherit constructors of a base class. For example:</p>

<p>```c++
struct A {</p>

<pre><code>A(int) {}
A(double) {}
A(int, double) {}
</code></pre>

<p>};</p>

<p>struct B : A {</p>

<pre><code>using A::A;
</code></pre>

<p>};
```</p>

<p>How this works is obvious for utmost simple cases. It might not be as clear when multiple inheritance is involved. For those cases, inheriting constructors would only work if all but one base classes have default constructors. For example, the following would work:</p>

<p>```c++
struct A {</p>

<pre><code>A() {}
</code></pre>

<p>};</p>

<p>struct B {</p>

<pre><code>B(int) {}
</code></pre>

<p>};</p>

<p>struct C : A, B {</p>

<pre><code>using B::B;
</code></pre>

<p>};
```</p>

<p>And will be an equivalent of the following hand-crafted constructor:</p>

<p>```c++
struct C : A, B {</p>

<pre><code>C(int v) : A(), B(v) {}
</code></pre>

<p>};
```</p>

<p>But if <code>A</code> does not have default constructor (even if the signature is the same as <code>B</code>), it won&rsquo;t work, so the below code is ill-formed:</p>

<p>```c++
struct A {</p>

<pre><code>A(int) {}
</code></pre>

<p>};</p>

<p>struct B {</p>

<pre><code>B(int) {}
</code></pre>

<p>};</p>

<p>struct C : A, B {</p>

<pre><code>using B::B;
</code></pre>

<p>};
```</p>

<p>There is also another catch that programmers should be aware of. It is the same old problem as forgetting to initialize class fields:</p>

<p>```c++
struct A {</p>

<pre><code>A(int) {}
</code></pre>

<p>};</p>

<p>struct B : A {</p>

<pre><code>using A::A;
int x;
</code></pre>

<p>};
```</p>

<p>With the above code, class <code>B</code> introduces <code>B(int)</code> constructor through inheritance of <code>A</code>&rsquo;s constructor(s), but it leaves <code>x</code> uninitialized. This means that inherited constructors might be useless if we need to initialize POD types. But do not rush with writing a custom constructor in this case. One can use non-static data member initializers, another new C++11 feature that we have reviewed before, to initialize <code>x</code>. For example:</p>

<p>```c++
struct A {</p>

<pre><code>A(int) {}
</code></pre>

<p>};</p>

<p>struct B : A {</p>

<pre><code>using A::A; // Inheriting A's constructor to create B::B(int){}
int x = 0;  // Initializing "x" using non-static field initializer.
</code></pre>

<p>};
```</p>

<h3>See Also</h3>

<ul>
<li><a href="/delegating-constructors">Delegating constructors in C++11</a></li>
<li><a href="/member-initializers/">Non-Static Data Member Initializers</a></li>
</ul>


<h3>References</h3>

<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2540.htm">N2540 &ndash; Inheriting Constructors (revision 5)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Default Template Arguments For Functions]]></title>
    <link href="http://741MHz.com/default-function-template-arguments/"/>
    <updated>2013-11-14T20:35:00-05:00</updated>
    <id>http://741MHz.com/default-function-template-arguments</id>
    <content type="html"><![CDATA[<p>One of the features that C++ provides to its users is the ability to write code in an object-oriented manner. The first object-oriented system was created in 1960 by <a href="http://en.wikipedia.org/wiki/Ivan_Sutherland">Ivan Sutherland</a>. 32 years later, when C++ first appeared back in 1983, object-oriented paradigm was so popular that everything that was not a class or a method was treated as a defective entity.</p>

<p>The beauty of C++ compared to many other languages like Java, where there can be no freestanding methods or global variables, is the fact that C++ neither tries to limit its users in terms of ideas they can have, nor does it force any specific ideas or ideals upon its users. It always allowed programmers to make their creations follow object-oriented, procedural, data-oriented designs, or have no design whatsoever.</p>

<p>In practice, however, there will always be limits. But C++ honestly tries not to stand in a way and help us, the programmers, to code anything that we could possibly have in our heads. And C++11 have proved this one more time with a lot of changes over the previous revision effectively improving the language to allow us to achieve more with less labor, focus on our current ideas rather than overcoming limitations of our tools and programming language, and come up with even more ideas, because ideas are most important.</p>

<blockquote><p>It is not labor, not capital, not land, that has created modern wealth or is creating it today. It is <em>ideas</em> that create wealth, and what is wanted is more ideas&hellip;</p>

<p>— <a href="http://en.wikipedia.org/wiki/Emerson_Harrington">Harrington Emerson</a></p></blockquote>

<p>Back in a day, freestanding functions, as well as freestanding function templates, did not get a lot of attention because people fell for the hype of object-oriented design. As a consequence, it was never possible to have seemingly simple and intuitive things such as a default template argument for a function template. It was allowed for classes, but not for functions. To give an example, the following would work:</p>

<p>```c++
template <typename X, typename Y = int>
struct A {</p>

<pre><code>static void func(X x, Y y) {
    // ...
}
</code></pre>

<p>};
```</p>

<p>But the function template like this would not compile:</p>

<p><code>c++
template &lt;typename X, typename Y = int&gt;
void func(X x, Y y) {
}
</code></p>

<p>Seems a little bit odd. Bjarne Stroustrup answered why this was happening in April 2000 when <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#226">he wrote</a>:</p>

<blockquote><p>The prohibition of default template arguments for function templates is a misbegotten remnant of the time where freestanding functions were treated as second-class citizens and required all template arguments to be deduced from the function arguments rather than specified.</p>

<p>The restriction seriously cramps programming style by unnecessarily making freestanding functions different from member functions, thus making it harder to write STL-style code.</p>

<p>— <a href="http://www.stroustrup.com">Bjarne Stroustrup</a></p></blockquote>

<p>Luckily, this was written along with a proposal on how to fix it, and after a couple of meetings with the core language working group, all of the small details were thought through and the final resolution was proposed in October 2002. It consisted of seven changes to different sections and paragraphs to the C++ standard.</p>

<p>If you are interested in details, you can check them out at <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#226">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#226</a>.</p>

<p>What&rsquo;s important is that today we need to waste our time no more working around this limitation as all of the production quality C++ compilers and tools support default template arguments for function templates, and we we can write our code like this:</p>

<p><code>c++
template &lt;class T, class U = double&gt;
void f(T t = 0, U u = 0);
</code></p>

<p>Long live C++!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Automatic Type Deduction With 'auto' Keyword]]></title>
    <link href="http://741MHz.com/auto-type/"/>
    <updated>2013-11-13T23:20:00-05:00</updated>
    <id>http://741MHz.com/auto-type</id>
    <content type="html"><![CDATA[<p>Programming languages matter. Type theory matters, too. Some say that C++ programming language is a type-safe language. But is that really so?</p>

<p>There is an alternative opinion on type safety where type safety is considered to be a property of a computer program rather than the language in which that program is written. That is, type-safety features of the language can be worked around to write a type unsafe program.</p>

<p>C++ does not make it impossible to cast types (i.e. convert a void pointer to a pointer of other type), so writing extremely unsafe programs is still possible. However, as a language it tries its best to help programmers write type safe programs. Yet it is still easy to make a mistake. Consider the following example:</p>

<p>```c++</p>

<h1>include <iostream></h1>

<p>int main() {</p>

<pre><code>int x = 2;
float y = 1.5;
int z = x / y;
std::cout &lt;&lt; z &lt;&lt; std::endl;
</code></pre>

<p>}
```</p>

<p>The above program will print &ldquo;1&rdquo;. But why? An alternative scenario could have been <code>1.333...</code> Is this a bug? Or is this behavior intended?</p>

<p>We do not know what was the programmer&rsquo;s intention here and therefore we cannot know. According to the language specification, however, the <code>x / y</code> expression in the above example yields a result of type <code>float</code>. This is described in §5/9 of the C++ standard and may also be referred to as &ldquo;implicit type conversion&rdquo;.</p>

<blockquote><p>Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield result types in a similar way. The purpose is to yield a common type, which is also the type of the result.</p>

<p>This pattern is called the usual arithmetic conversions, which are defined as follows:</p>

<p>If either operand is of type long double, the other shall be converted to long double.</p>

<p>— Otherwise, if either operand is double, the other shall be converted to double.</p>

<p>— Otherwise, if either operand is float, the other shall be converted to float.</p>

<p>— Otherwise, the integral promotions (4.5) shall be performed on both operands.54)</p>

<p>— Then, if either operand is unsigned long the other shall be converted to unsigned long.</p>

<p>— Otherwise, if one operand is a long int and the other unsigned int, then if a long int can represent all the values of an unsigned int, the unsigned int shall be converted to a long int; otherwise both operands shall be converted to unsigned long int.</p>

<p>— Otherwise, if either operand is long, the other shall be converted to long.</p>

<p>— Otherwise, if either operand is unsigned, the other shall be converted to unsigned.</p>

<p>[Note: otherwise, the only remaining case is that both operands are int ]</p></blockquote>

<p>So what actually happened is an explicit type casting where a <code>float</code> was casted back to to <code>int</code> when programmer wrote <code>int z = x / y</code>. If he or she wrote <code>float z = x / y</code> instead, then output of the program would have been <code>1.333</code>.</p>

<p>But how many programmers remember all of the type conversion rules for binary operators? How to figure out whether a type cast was intentional or not?</p>

<p>But more importantly, what type to choose when writing a generic code, such as a template function? Like in this case, for example:</p>

<p>```c++
template <typename A, typename B>
void foo(A a, B b) {</p>

<pre><code>A /* or B? or something else? */ c = a + b;
</code></pre>

<p>}
```</p>

<p>In other words, every time programmers specify a type explicitly, they oftentimes may accidentally introduce violate type safety theory. And this is a problem.</p>

<p>Fortunately, C++11 provides a way to solve it in a uniform way though the introduction of a &ldquo;old&rdquo; new <code>auto</code> keyword.</p>

<h3>The &ldquo;auto&rdquo; keyword. Reloaded.</h3>

<p>The reason &ldquo;old&rdquo; is in a previous sentence is because C++ always had an <code>auto</code> keyword. It basically meant that a variable has automatic storage duration. However, because a special keyword for type-safety was needed and the old <code>auto</code> keyword was not that useful (and the research has shown that it was almost never used), it was decided to give <code>auto</code> keyword a new meaning not to introduce any new keywords.</p>

<p>Since the introduction of C++11, the <code>auto</code> keyword is used to indicate that the type of a variable is to be deduced from its initializer expression. For example:</p>

<p><code>c++
auto x = 3.14; // x has type double
</code></p>

<p>In other words, <code>auto</code> let&rsquo;s the compiler figure out / deduce the type automatically. Getting back to our old template problem, it can be now solved by using <code>auto</code>:</p>

<p>```c++
template <typename A, typename B>
void foo(A a, B b) {</p>

<pre><code>auto c = a + b;
//  ^^^^ we now let compiler worry about the type here.
</code></pre>

<p>}
```</p>

<p>Jumping a little bit upfront, a major concern in discussions of <code>auto</code> features prior to proposing it into a standard was the potential difficulty in figuring out whether the declared variable will be of a reference type or not. And it was decided that the rules of type deduction in case with <code>auto</code> should be the exactly the same as the rules of template argument deduction. Examples (the notation x : T in the comments is read as &ldquo;x has type T&rdquo;):</p>

<p>```c++
A foo();
A&amp; bar();</p>

<p>A x1 = foo(); // &ldquo;x1&rdquo; is of type &ldquo;A&rdquo;
auto x1 = foo(); // &ldquo;x1&rdquo; is of type &ldquo;A&rdquo;</p>

<p>A&amp; x2 = foo();  // error, we cannot bind a non−lvalue to a non-const reference
auto&amp; x2 = foo();  // error</p>

<p>A y1 = bar(); // &ldquo;y1&rdquo; is of type &ldquo;A&rdquo;
auto y1 = bar(); // &ldquo;y1&rdquo; is of type &ldquo;A&rdquo;</p>

<p>A&amp; y2 = bar(); // &ldquo;y2&rdquo; is of type &ldquo;A&amp;&rdquo;
auto&amp; y2 = bar(); // &ldquo;y2&rdquo; is of type &ldquo;A&amp;&rdquo;
```</p>

<p>The <code>auto</code> keyword can also be used to declare more than one variable. The requirement in this case is that both deductions must lead to the same type. For example:</p>

<p><code>c++
auto a = 2;
auto b = 1.2;
auto c = 1, *d = &amp;a; // OK: "c" is of type "int", "d" is "int*"
auto e = 1, *f = &amp;b; // ERROR: "e" is of type "int", "f" is "float*"
</code></p>

<h4>Auto in function declarations</h4>

<p>For a moment, let&rsquo;s get back to our template example:</p>

<p>```c++
template <typename A, typename B>
void foo(A a, B b) {</p>

<pre><code>auto c = a + b;
</code></pre>

<p>}
```</p>

<p>Using auto has solved a problem of determining a type of &ldquo;c&rdquo;. However, there is potentially another problem. Let&rsquo;s say that we now want to return a result of addition from <code>foo()</code>, what should we specify as its return type?</p>

<p>Luckily, folks designing C++ language has thought about this problem and put a special provision into the language that allows <code>auto</code> to be used with functions as part of the trailing notation syntax. The basic idea is to allow &ldquo;auto&rdquo; be specified in place of a return type, and then specify the actual type later. For example:</p>

<p>```c++
template <typename A, typename B>
void foo(A a, B b) &ndash;> void {</p>

<pre><code>auto c = a + b;
</code></pre>

<p>}
```</p>

<p>This alone does not solve the problem. However, a <code>decltype</code> keyword that we have talked about in the <a href="/decltype">previous article</a>, can now be used to perform type deduction. For example:</p>

<p>```c++
template <typename A, typename B>
auto foo(A a, B b) &ndash;> decltype(a + b) {</p>

<pre><code>return a + b;
</code></pre>

<p>}
```</p>

<p>Note that <code>decltype</code> alone can be used in some cases, for example:</p>

<p>```
template <typename A, typename B>
decltype(1 + 2) foo(A a, B b) {</p>

<pre><code>return a + b;
</code></pre>

<p>}
```</p>

<p>However, if used without <code>auto</code> and is not placed into &ldquo;trailing&rdquo; part, function arguments cannot be used in inside <code>decltype()</code> as they have not even been declared yet (at the time of parsing).</p>

<h3>Summary</h3>

<p>All in all, <code>auto</code> is very similar to <code>decltype</code> but is &ldquo;prettier&rdquo; in terms of syntax,  allows for special case with return type deduction, and has reference-dropping semantics (similar to that of <a href="http://en.wikipedia.org/wiki/Typeof"><code>typeof</code> GCC extension</a>).</p>

<p>Programmers are encouraged to use auto where possible unless explicit type conversion/cast is required &ndash; this would make the program even more type safe which in turn will help eliminate bugs related to type errors.</p>

<h3>See Also</h3>

<ul>
<li><a href="/decltype/">Determining Type of Expression in C++</a></li>
</ul>


<h3>References</h3>

<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1984.pdf">N1984 &ndash; Deducing the type of variable from its initializer expression</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/vstudio/6k3ybftz.aspx">&ldquo;auto&rdquo; keyword</a> @ MSDN</li>
<li><a href="http://en.wikipedia.org/wiki/Type_safety#C.2B.2B">C++ type safety</a> @ Wikipedia</li>
<li><a href="http://jameso.be/2012/02/11/language-matters.html">Why programming languages matter</a> by James O'Beirne</li>
<li><a href="http://en.cppreference.com/w/cpp/language/auto">&ldquo;auto&rdquo; specifier</a> @ cppreference.com</li>
<li><a href="http://stackoverflow.com/questions/5563000/implicit-type-conversion-rules-in-c-operators">Implicit type conversion rules in C++ operators</a> via Stack Overflow</li>
<li><a href="http://en.wikipedia.org/wiki/Typeof">Typeof keyword</a> @ Wikipedia</li>
</ul>

]]></content>
  </entry>
  
</feed>
