<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | Ranting @ 741 MHz]]></title>
  <link href="http://741MHz.com/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://741MHz.com/"/>
  <updated>2013-12-01T22:07:58-05:00</updated>
  <id>http://741MHz.com/</id>
  <author>
    <name><![CDATA[741MHz.com]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++ Exceptions, Stack Trace and GDB Automation]]></title>
    <link href="http://741MHz.com/throw-stacktrace/"/>
    <updated>2013-04-16T00:00:00-04:00</updated>
    <id>http://741MHz.com/throw-stacktrace</id>
    <content type="html"><![CDATA[<p>The tricky part about any exception is that the stack is already unwinded by the time exception is caught and there is no easy way to figure out from which part of the code it was thrown. Have you ever caught an exception that has no information that can be used to find where the problem is? The one that says «this should never happen» or even has no text at all. Hopefully, this doesn’t happen to you very often. But if you work with a large C++ codebase with tons of different components written by different developers then sooner or later it would definitely happen. It can be quite disappointing and take a lot of time going through the pile of somebody else’s code trying to figure out what went wrong. So you must be prepared. I might be a little bit unlucky in this regard – this happened to me a lot, so I decided to share a few ways for overcoming this type of situations.</p>

<h2>Backtrace API</h2>

<p>Quite a few C runtime libraries provide a mechanism to examine the current thread’s call stack. It consists of three functions declared in <code>execinfo.h</code> header:</p>

<p>```c
int backtrace(void** array, int size);</p>

<p>char<em><em> backtrace_symbols(void</em> const</em> array, int size);</p>

<p>void backtrace_symbols_fd(void<em> const</em> array, int size, int fd);
```</p>

<p>Using those functions, one can access the stack trace at any given point of program execution. Here is a simple example that prints the stack to standard output:</p>

<p>```c++</p>

<h1>include &lt;execinfo.h></h1>

<h1>include <iostream></h1>

<p>int main()
{</p>

<pre><code>void *callstack[256];
int frames = ::backtrace(
    callstack, sizeof(callstack) / sizeof(callstack[0]));
char **symbols = ::backtrace_symbols(callstack, frames);
std::cout &lt;&lt; "Stack Trace:\n";
for (int i = 0; i &lt; frames; ++i) {
    std::cout &lt;&lt; '\t' &lt;&lt; symbols[i] &lt;&lt; '\n';
}
std::free(symbols);
</code></pre>

<p>}
```</p>

<p>This method can be used to get the stack trace before the exception is thrown and before the stack is unwinded. In order to do that, one could define a custom exception class that grabs the stack trace in its constructor. For example:</p>

<p>```c++</p>

<h1>include &lt;execinfo.h></h1>

<h1>include <string></h1>

<h1>include <stdexcept></h1>

<h1>include <cstdlib></h1>

<h1>include <iostream></h1>

<p>class Exception : public std::exception {
  public:</p>

<pre><code>Exception() {
    grab_backtrace();
}

explicit Exception(const std::string &amp;reason) : reason_(reason) {
    reason_.append(1, '\n');
    grab_backtrace();
}

virtual ~Exception() throw() { }

virtual const char *what() const throw() {
    return reason_.c_str();
}
</code></pre>

<p>  private:</p>

<pre><code>void grab_backtrace() {
    void *callstack[256];
    int frames = ::backtrace(
        callstack, sizeof(callstack) / sizeof(callstack[0]));
    char **symbols = backtrace_symbols(callstack, frames);
    try {
        reason_.append("Stack Trace:");
        for (int i = 0; i &lt; frames; ++i) {
            reason_.append("\n\t").append(symbols[i]);
        }
    } catch(const std::exception &amp;) {
        std::free(symbols);
        throw;
    }
    std::free(symbols);
}

std::string reason_;
</code></pre>

<p>};</p>

<p>static void do_something(int n, int i = 0)
{</p>

<pre><code>if (i &lt; n) {
    do_something(n, ++i);
} else {
    throw Exception("Recursion limit exceeded");
}
</code></pre>

<p>}</p>

<p>int main(int argc, char *argv[])
{</p>

<pre><code>try {
    do_something(argc &gt; 1 ? std::atoi(argv[1]) : 10, argc);
} catch(const std::exception &amp;e) {
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
    return EXIT_FAILURE;
}
</code></pre>

<p>}
```</p>

<p>So far so good! Here is an example of running the above program:</p>

<p>```
$ clang++ -Wall -pedantic ./test.cpp &amp;&amp; ./a.out 3
Recursion limit exceeded
Stack Trace:</p>

<pre><code>0   a.out                0x00000001034fa7af _ZN9Exception14grab_backtraceEv + 63
1   a.out                0x00000001034fa6f4 _ZN9ExceptionC2ERKSs + 116
2   a.out                0x00000001034fa56d _ZN9ExceptionC1ERKSs + 29
3   a.out                0x00000001034fa33c _Z12do_somethingii + 140
4   a.out                0x00000001034fa2df _Z12do_somethingii + 47
5   a.out                0x00000001034fa42d main + 93
6   libdyld.dylib        0x00007fff935e27e1 start + 0
</code></pre>

<p>```</p>

<p>Unfortunately, there are a few problems with this approach. Firstly, there no file names and no line numbers. Secondly, this approach requires to use the “Exception” class as a base class of all exceptions in the project (well, at least for those you want to get a stack trace for), which indeed can be very problematic if not impossible. But even if all of the above is fine with you, this approach may still not work out for you because frame pointers can be omitted in optimized builds. For example, omitting frame pointers is a default behavior of recent GCC compilers for x86_64 platforms (which can also be turned on/off using <code>-fomit-frame-pointer</code> option). Our call stack becomes useless if frame pointers are omitted:</p>

<p>```
$ clang++ -Wall -fomit-frame-pointer ./test.cpp &amp;&amp; ./a.out 3
Recursion limit exceeded
Stack Trace:</p>

<pre><code>0   a.out                0x0000000105eca82d _ZN9Exception14grab_backtraceEv + 61
</code></pre>

<p>```</p>

<p>Depending on the system, there could be other requirements in order to make this API work. For example, GNU runtime requires you to specify “-rdynamic” flag to instruct the linker to add all symbols, not only used ones, to the dynamic symbol table. So don’t forget to read a manual page for this API in your system before using this.</p>

<h2>__FILE__ and __LINE__</h2>

<p>C++ has many <a href="http://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html">standard predefined macros</a>. <code>__FILE__</code> and <code>__LINE__</code> macros are those two that come handy in order to identify a point in a program:</p>

<p><code>__FILE__</code>  macros expands to the name of the current input file, in the form of a C string constant. This is the path by which the preprocessor opened the file, not the short name specified in ‘#include’ or as the input file name argument. For example, “/usr/local/include/myheader.h” is a possible expansion of this macros.</p>

<p><code>__LINE__</code> macros expands to the current input line number, in the form of a decimal integer constant. While we call it a predefined macro, it’s a pretty strange macro, since its “definition” changes with each new line of source code.|</p>

<p>Using the above macros, it is possible to include both file and line information along with exception’s text, or maybe as additional member fields of any given exception class. There are multiple choices. Here is an example of one of possible implementations:</p>

<p>```c++</p>

<h1>include <stdexcept></h1>

<h1>include <cstdlib></h1>

<h1>include <iostream></h1>

<p>class Exception : public std::runtime_error {
  public:</p>

<pre><code>template &lt;unsigned int location_len&gt;
inline Exception(const char (&amp;location)[location_len],
                 const std::string &amp;reason)
    : std::runtime_error(reason + location)
{ }

virtual ~Exception() throw() { }
</code></pre>

<p>};</p>

<h1>define MY_THROW_STR_I(Arg) #Arg</h1>

<h1>define MY_THROW_STR(Arg) MY_THROW_STR_I(Arg)</h1>

<h1>define MY_THROW(Type, &hellip;)                                             \</h1>

<pre><code>do {                                                                \
    throw Type(" @ "; __FILE__ ";:" MY_THROW_STR(__LINE__), ##__VA_ARGS__); \
} while (0)
</code></pre>

<p>static void do_something(int n, int i = 0)
{</p>

<pre><code>if (i &lt; n) {
    do_something(n, ++i);
} else {
    MY_THROW(Exception, "Recursion limit exceeded");
}
</code></pre>

<p>}</p>

<p>int main(int argc, char *argv[])
{</p>

<pre><code>try {
    do_something(argc &gt; 1 ? std::atoi(argv[1]) : 10, argc);
} catch(const std::exception &amp;e) {
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
    return EXIT_FAILURE;
}
</code></pre>

<p>}
```</p>

<p>When the exception is caught and printed, the source file name and a line numbers are included, which makes it easy to trace the origins of such an exception:</p>

<p><code>
$ ./a.out
Recursion limit exceeded @ ./test.cpp:26
</code></p>

<p>Of course, this does not include a stack trace. But it works if frame pointers are omitted, tail recursion optimization is applied, or even if all symbol names are stripped out of the executable. There is one problem though — it may not be useful without a stack trace in certain cases. For example, one may declare a helper function used to throw an exception, like this:</p>

<p>```c++
<strong>attribute</strong>((noreturn)) void report_error(const std::string &amp;reason) {</p>

<pre><code>MY_THROW(Exception, reason);
</code></pre>

<p>}
```</p>

<p>In that case, the file and line of the exception origins will always be the same even if it was called from different places in the program. So this approach is also not a cure for all diseases.</p>

<h2>GDB Scripting: Automatic Backtrace on Exception Catchpoints</h2>

<p>And the last but not least method is to use <a href="http://www.gnu.org/software/gdb/">GDB debugger</a>. If you are not familiar with this debugger, you definitely should spend some time learning it. It is one of the most powerful tools out there. And it comes extremely handy when dealing with exceptions.</p>

<p><a href="http://sourceware.org/gdb/onlinedocs/gdb/Set-Catchpoints.html">GDB provides special catch points</a>, including those to catch exceptions being thrown, caught or even unhandled. We are interested in exceptions that are being thrown and so must use <code>catch throw</code> command. Here is an example of manually using GDB in order to examine a stack trace before the exception is thrown:</p>

<p>```
$ gdb -args ./a.out 5
Reading symbols from /tmp/a.out&hellip;done.
(gdb) catch throw
Catchpoint 1 (throw)
(gdb) run
Starting program: /tmp/a.out 5
Catchpoint 1 (exception thrown), <strong>cxxabiv1::</strong>cxa_throw (obj=0x6030d0, tinfo=0x401420 , dest=0x401198 )</p>

<pre><code>at ../../../../libstdc++-v3/libsupc++/eh_throw.cc:70
</code></pre>

<p>70    header->exc.unexpectedHandler = __unexpected_handler;
(gdb) backtrace</p>

<h1>0  <strong>cxxabiv1::</strong>cxa_throw (obj=0x6030d0, tinfo=0x401420 , dest=0x401198 )</h1>

<pre><code>at ../../../../libstdc++-v3/libsupc++/eh_throw.cc:70
</code></pre>

<h1>1  0x0000000000400fee in report_error (reason=&ldquo;Recursion limit exceeded&rdquo;) at ./test.cpp:25</h1>

<h1>2  0x000000000040105d in do_something (n=5, i=5) at ./test.cpp:33</h1>

<h1>3  0x000000000040102e in do_something (n=5, i=5) at ./test.cpp:31</h1>

<h1>4  0x000000000040102e in do_something (n=5, i=4) at ./test.cpp:31</h1>

<h1>5  0x000000000040102e in do_something (n=5, i=3) at ./test.cpp:31</h1>

<h1>6  0x00000000004010cb in main (argc=2, argv=0x7fffffffe1f8) at ./test.cpp:40</h1>

<p>(gdb) continue
Continuing.
Recursion limit exceeded @ ./test.cpp:25
[Inferior 1 (process 3865) exited with code 01]
(gdb) quit
```</p>

<p>At first, this might sound silly because in the real world a program may encounter a lot of exceptions and manually typing “backtrace” and “continue” every type that happens is nothing but a waste of time. But there is one trick — GDB can be automated. There are two ways of doing this — use a batch mode or a more sophisticated <a href="http://sourceware.org/gdb/wiki/PythonGdbTutorial">Python scripting</a>. For our purpose, a batch script will do just fine. Here is a simple script that turns off verbose output and paging, sets up a <code>throw</code> catch point and executes <code>backtrace</code> + <code>continue</code> commands every time the event is caught:</p>

<p><code>
set verbose off
set pagination off
catch throw
commands
backtrace
continue
end
run
quit
</code></p>

<p>Save the above script into a file, and then run GDB in batch mode telling it to use that file, which in my case is called “gdb_bt_script”:</p>

<p>```
$ gdb -n -batch -x ./gdb_bt_script &mdash;args ./a.out 5
Catchpoint 1 (throw)
Catchpoint 1 (exception thrown), <strong>cxxabiv1::</strong>cxa_throw (obj=0x6030d0, tinfo=0x401420 , dest=0x401198 ) at ../../../../libstdc++-v3/libsupc++/eh_throw.cc:70
70    header->exc.unexpectedHandler = __unexpected_handler;</p>

<h1>0  <strong>cxxabiv1::</strong>cxa_throw (obj=0x6030d0, tinfo=0x401420 , dest=0x401198 ) at ../../../../libstdc++-v3/libsupc++/eh_throw.cc:70</h1>

<h1>1  0x0000000000400fee in report_error (reason=&ldquo;Recursion limit exceeded&rdquo;) at ./test.cpp:25</h1>

<h1>2  0x000000000040105d in do_something (n=5, i=5) at ./test.cpp:33</h1>

<h1>3  0x000000000040102e in do_something (n=5, i=5) at ./test.cpp:31</h1>

<h1>4  0x000000000040102e in do_something (n=5, i=4) at ./test.cpp:31</h1>

<h1>5  0x000000000040102e in do_something (n=5, i=3) at ./test.cpp:31</h1>

<h1>6  0x00000000004010cb in main (argc=2, argv=0x7fffffffe1f8) at ./test.cpp:40</h1>

<p>Recursion limit exceeded @ ./test.cpp:25
[Inferior 1 (process 5849) exited with code 01]
$
```</p>

<p>Whoala! Now we get a full stack trace including function parameters, their values, and file and line numbers. If the program is optimized and has no debug symbols, however, we get a little bit less:</p>

<p>```
$ gdb -n -batch -x ./gdb_bt_script &mdash;args ./a.out 5
Catchpoint 1 (throw)
Catchpoint 1 (exception thrown), <strong>cxxabiv1::</strong>cxa_throw (obj=0x6030d0, tinfo=0x401470 , dest=0x401270 ) at ../../../../libstdc++-v3/libsupc++/eh_throw.cc:70
70    header->exc.unexpectedHandler = __unexpected_handler;</p>

<h1>0  <strong>cxxabiv1::</strong>cxa_throw (obj=0x6030d0, tinfo=0x401470 , dest=0x401270 ) at ../../../../libstdc++-v3/libsupc++/eh_throw.cc:70</h1>

<h1>1  0x00000000004010a8 in report_error(std::string const&amp;) ()</h1>

<h1>2  0x000000000040121e in do_something(int, int) ()</h1>

<h1>3  0x0000000000400ef6 in main ()</h1>

<p>Recursion limit exceeded @ ./test.cpp:25
[Inferior 1 (process 1877) exited with code 01]
```</p>

<p>Yet still a lot more than we get using backtrace API. But the most beautiful part is that this method does not require any code changes and works for pretty much any binary.</p>

<h2>The End</h2>

<p>Those were three fundamental methods that can help to identify a place where exception is thrown from. They are not mutually exclusive. Each has its cons and pros. I personally prefer to use GDB because it doesn’t require a code change, but use other two methods as well, depending on a situation. It is up to you to decide which one to use.</p>

<p>Hope it helps and Good Luck!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Two Different Languages - C and C++]]></title>
    <link href="http://741MHz.com/c-vs-cxx/"/>
    <updated>2013-04-15T00:00:00-04:00</updated>
    <id>http://741MHz.com/c-vs-cxx</id>
    <content type="html"><![CDATA[<p>Good news everyone, we are looking for a C/C++ developer! Wait, that’s not good news at all!</p>

<p>You see, the term «C/C++» is likely to piss off those who actually know both C and C++. On the other hand, majority of C++ developers mistakenly think they know C. And it would take at least a year or two for a C developer to learn C++. Yet «C/C++» is mentioned in way too many job postings. So who exactly are we looking for?</p>

<p>Let’s start by asking a simple question — what would the main() function return in the below C/C++ program?</p>

<p>```c++
extern int T;</p>

<p>int main()
{</p>

<pre><code>struct T { int a; int b; };
return sizeof(T) + sizeof('T');
</code></pre>

<p>}
```</p>

<p>Of course it depends on architecture. But let’s assume that size of int is 4 bytes and structure T has no extra padding. The code is legal in both C and C++. Yet the correct answer depends on whether this is a C or C++ program. If it is a C program then the correct answer is 8. In case of C++ the answer is 9.</p>

<h2>C is not C++</h2>

<p>C++ originated back in 1979 and at that time it was based on C. It wasn’t even called C++ — its first name was «C with Classes». The language was renamed to «C++» only in 1983. At that time, both languages were closely related. However, from that point both C and C++ took a different evolution path and today, some 30+ years later, both languages are as different as Objective-C and C++, Java and C#, Python and Ruby, OCaml and F#. There is only one catch — the basic syntax of both is very similar to such a degree that it is possible to have a program that is both legal C and legal C++, which may or may not behave differently. Generally, everyone knows that C++ has tons of features that are not available in C but any C code can be compiled as C++. Therefore, C++ developers also think that they know C. And in most cases they are dangerously mistaken. Below is a list of the most common features of C language serving as traps for C++ fellows.</p>

<h3>Casting void pointer</h3>

<p>In C, void pointer can be implicitly casted to a pointer of any other type. For example:</p>

<p><code>c
void *ptr = 0xDEADDEAD;
int *i = ptr;
</code></p>

<p>C developers use this convenient feature all the time. However, any C++ compiler would choke on that and die.</p>

<h3>Implicit function declaration</h3>

<p>In C, it is not always necessary to declare a function before using it. Using an undeclared function implicitly declares it. This feature has been declared deprecated since 1999 but is still used here and there. For example:</p>

<p>```c
int main() {</p>

<pre><code>    return foo();
</code></pre>

<p>}</p>

<p>int foo() {</p>

<pre><code>    return 0;
</code></pre>

<p>}
```</p>

<p>A perfectly legal C program that is illegal C++:</p>

<p><code>
$ gcc ./test.c
$ g++ ./test.cpp
./test.cpp: In function ‘int main()’:
./test.cpp:3: error: ‘foo’ was not declared in this scope
</code></p>

<h3>No arguments vs any arguments</h3>

<p>In C, function prototype without parameters imply that function accepts any number of arguments and it is legal to call such a function with one or more arguments. In C++, function prototype without parameters means that function accepts no arguments and it is illegal to call such function with arguments. For example:</p>

<p>```c
void foo();</p>

<p>int main() {</p>

<pre><code>    foo(1, "hello");
</code></pre>

<p>}</p>

<p>void foo() {
}
```</p>

<p>The above is absolutely legal C code that won’t compile as C++. As a matter of fact, I haven’t seen many C++ developers who can tell the difference between <code>void foo();</code> and <code>void foo(void);</code></p>

<h3>Crossing initialization with goto or switch</h3>

<p>```c
int main()
{</p>

<pre><code>goto out;
int i = 1;
</code></pre>

<p>  out:</p>

<pre><code>return 0;
</code></pre>

<p>}
```</p>

<p>The above is a perfectly legal C code but is rejected by C++ compiler as C++ does not allow to cross initialization:</p>

<p>```
$ clang++ ./test.cpp
./test.cpp:3:5: error: goto into protected scope</p>

<pre><code>goto out;
^
</code></pre>

<p>./test.cpp:4:9: note: jump bypasses variable initialization</p>

<pre><code>int i = 1;
    ^
</code></pre>

<p>1 error generated.
```</p>

<h3>Keywords clash</h3>

<p>C++ would fail to compile any legal C code that happen to use C++ keywords:</p>

<p>```c
struct foo {</p>

<pre><code>int old;
int new;
</code></pre>

<p>};
```</p>

<h2>More! More! More!</h2>

<p>Oh, you knew that? If you knew all of the above and still consider yourself a “C/C++” developer, hold on a second. Name at least 10 more differences. Huh?</p>

<ul>
<li>In C++, comma operator can yield an l-value. In C it cannot.</li>
<li>C does not allow duplicate typedefs while C++ does.</li>
<li>C++ does not allow non-prototype function declarations while C does.</li>
<li>C allows struct, union and enum to be declared in function prototypes, C++ doesn’t.</li>
<li>C allows for implicit discard of pointer const qualifiers. This trick won’t work in C++.</li>
<li>In C++, struct, union and enum declarations automatically imply a typedef with the same name. This is not the case in C.</li>
<li>Character literals in C are of type int. In C++ they are of type char.</li>
<li>C++ implicitly treats any const global as file scope unless it is explicitly declared extern, unlike C in which extern is the default.</li>
<li>Functions market as “inline” in C are of file scope whereas they have external linkage by default in C++.</li>
<li>C has VLA (Variable Length Arrays) support whereas C++ does not (until C++14).</li>
</ul>


<p>And the list of technical differences/incompatibilities of C and C++ can go on and on. The list is so big that it is impossible to fit it into a blog post. But if you are interested, check out References section in the bottom of this post.</p>

<p>Aside of technical differences, it would also be a mistake not to mention the coding style. Not a formatting style or using tabs versus spaces, but coding style. For example, C++ developers would always cast a result of <code>malloc()</code> whereas C developers would almost never do that.</p>

<h2>Grammar of «C/C++»</h2>

<p>Trying to figure out the meaning behind «C/C++», I dug the usage of slash as a punctuation sign in English text. I have never learn English grammar in school so you may want to check me on this one. Anyhow, according to Wikipedia the slash is most commonly used as the word substitute for “or” which indicates a choice (often mutually-exclusive) is present.</p>

<p>If that is the case, then companies are actually looking for either C or C++ developers, not both. Which doesn’t make any sense at all. Why nobody is looking for “Cobol/Ada” or “Lisp/Verilog” developers? Looking at other industries, there seem to be no companies searching for “Linguist/Plumber”-like people.</p>

<p>So the grammar doesn’t seem to back up the usage of «C/C++» term. This leaves everyone guessing as to what it actually means and the only way to figure out is from the context.</p>

<h2>What it actually means</h2>

<p>The actual meaning of «C/C++» depends. Here are some examples of what this means according to my observations.</p>

<p>In job postings, “We are looking for C/C++ developers” generally means “We are looking for C++ developers, nobody knows C here but why not put that in a title, too?”</p>

<p>When somebody brags about being a “C/C++” developers it means they don’t really know any of those languages but learned to write a “Hello, World!” application using printf() and compile it with C++ compiler.</p>

<p>In forums, «C/C++» section is usually dedicated for C++ crowd that might as well be able to answer some C-related questions if you get lucky.</p>

<h2>Tip: Don’t Use «C/C++»</h2>

<p>If you are looking for a developer, make sure you clearly specify requirements and avoid the use of «C/C++». If it so happens that you are actually looking for someone who knows both, say «C and C++». If you are willing to spend a few years teaching C developer C++ language, say «C++ developer or C developer willing to learn C++». Using «C/C++» will only bring confusion to those reading the job posting.</p>

<p>End of rant.</p>

<h2>References</h2>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Slash_(punctuation">Slash in English text.</a></li>
<li><a href="http://david.tribble.com/text/cdiffs.htm">Incompatibilities Between ISO C and ISO C++</a> by David R. Tribble</li>
<li><a href="http://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B">Compatibility of C and C++</a></li>
<li><a href="http://c-faq.com/malloc/mallocnocast.html">What’s wrong with casting malloc’s return value?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Use free and delete correctly.]]></title>
    <link href="http://741MHz.com/free-delete/"/>
    <updated>2013-03-13T00:00:00-04:00</updated>
    <id>http://741MHz.com/free-delete</id>
    <content type="html"><![CDATA[<p>The Internet is full of programming jokes <a href="http://bash.org/?946461">like this one</a>:</p>

<blockquote><p>&lt;@joosa> how do you say float in java? just 1.5f?<br/>
&lt;@Gliptic> FloatFactoryFactory.getInstance (FloatFactoryFactory.defaultInstanceDescriptionString).getFactory (Locale.getLocale (“en-US”)).createBuilder ().setString (“1.5″).getResult ()</p></blockquote>

<p>Java people please read on, that’s only a joke! More often than not the jokes are directed at those using higher-level programming languages. This is a little unfair because C programmers (and C++ ones for that matter) write some funny code, too. For example:</p>

<p>```c
void foo(void *ptr) {</p>

<pre><code>if (ptr)
    free(ptr);
</code></pre>

<p>}
```</p>

<p>This perhaps could be a joke or maybe even an interview question. What’s wrong with the above C code (assuming everything else including the usage is correct)? It turns out that many can’t spot anything. If you do — congratulations! For those who don’t, let’s read the <a href="http://man7.org/linux/man-pages/man3/free.3.html">documentation of <code>free()</code> function</a>:</p>

<blockquote><p>The free() function frees the memory space pointed to by ptr, which must have been returned by a previous call to malloc(), calloc() or realloc(). Otherwise, or if free(ptr) has already been called before, undefined behavior occurs. If ptr is NULL, no operation is performed.</p></blockquote>

<p>In other words, there is no need to check if pointer is not NULL. The same applies to C++ programmers who often check for <strike><code>NULL</code></strike> <code>nullptr</code> before calling <code>delete</code>. If you don’t trust manual pages, check out §7.20.3/2 of the C standard that states the following:</p>

<blockquote><p>The free function causes the space pointed to by ptr to be deallocated, that is, made available for further allocation. If ptr is a null pointer, no action occurs. Otherwise, if the argument does not match a pointer earlier returned by the calloc, malloc, or realloc function, or if the space has been deallocated by a call to free or realloc, the behavior is undefined.</p></blockquote>

<p>For C++, see §5.3.5/2:</p>

<blockquote><p>… if the value of the operand of delete is the null pointer the operation has no effect.</p></blockquote>

<p>Possibly, an extra checking for NULL was a necessity some 20 years ago, according to some Internet rumors claiming that a few implementations of the standard C library had a bug back then and free() could crash the program when passed a NULL pointer. I couldn’t find any information about what it was. But no matter what was going on two decades ago — it is pretty hard to find pre-ANSI C code these days. Yet unnecessary NULL checking can be seen a lot. For example, <a href="http://krugle.org/">krugle.org</a> shows the following three projects right away:</p>

<ul>
<li><a href="http://opensearch.krugle.org/document/view_filecontent/apache_http_server1945779753/scmi_filer2-scmi.ofc.krugle.net_8799/scmi_305/tags/1.3/djg_nspr_split/src/regex/regfree.c">Apache Web Server</a></li>
<li><a href="http://opensearch.krugle.org/document/view_filecontent/apache_hadoop618243895/scmi_filer2-scmi.ofc.krugle.net_8799/scmi_528/trunk/hadoop-common-project/hadoop-common/src/main/native/src/org/apache/hadoop/security/getGroup.c">Apache Hadoop</a></li>
<li><a href="http://opensearch.krugle.org/document/view_filecontent/miranda1067994304/scmi_filer2-scmi.ofc.krugle.net_8799/scmi_705/miranda/protocols/Gadu-Gadu/ownerinfo.c">Miranda</a> (an ICQ client popular in ex-USSR countries)</li>
</ul>


<p>I thought that maybe people are worrying about performance too much and don’t want to do an extra function call (extra cycles, procedure linkage tables, etc). But then using <code>malloc()</code> and <code>free()</code> in performance critical path would have been even more silly.</p>

<p>So is it paranoia, a failure to read documentation, or maybe a thoughtless copy-paste that went too far?</p>

<p>Who knows.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Automatic Resource Management in Programming Languages]]></title>
    <link href="http://741MHz.com/raii/"/>
    <updated>2013-02-27T00:00:00-05:00</updated>
    <id>http://741MHz.com/raii</id>
    <content type="html"><![CDATA[<p>Many high-level programming languages provide software developers with the ability to automatically cleanup resources — automatically closing an open file when it is no longer used, freeing dynamically allocated memory, or anything else for that matter. This article touches on automatic resource management features available in modern programming languages. It shows some examples demonstrating why having this feature make it easier to write code, or how not using this feature may lead to potentially critical failures of the program. The primary focus is on C++ and C (surprise!) languages.</p>

<h2>C</h2>

<p>There are a few ways to automatically clean up resources in C# — a <code>finally</code> block and a <code>using</code> statement.</p>

<p>A <code>finally</code> block is a bit lower level than a using. It guarantees that all statements inside a <code>finally</code> block will be executed when the try block exists, even if unexpected exception occurs. For example:</p>

<p>```c#
ResourceType resource = expression; // Allocate, initialize or acquire some resource.
try {</p>

<pre><code>// Do something with it.
statement;
</code></pre>

<p>} finally {</p>

<pre><code>// Free, destroy or release a resource.
// This is guaranteed to happen.
((IDisposable)resource).Dispose();
</code></pre>

<p>}
```</p>

<p>Another and more convenient way of doing the same is to employ a <code>using</code> statement which guarantees that <code>Dispose()</code> method is called automatically upon leaving the scope of using block:</p>

<p>```c#
using (ResourceType resource = expression) {</p>

<pre><code>statement;
</code></pre>

<p>}
```</p>

<h2>Java</h2>

<p>Java also provides a finally block similar to that seen in C#:</p>

<p>```java
FileReader reader = null;
try {</p>

<pre><code>reader = new FileReader("/dev/null");
// Do something with a file...
</code></pre>

<p>} finally {</p>

<pre><code>if (reader != null)
reader.close();
</code></pre>

<p>}
```</p>

<p>Starting from version 7 Java introduces an AutoCloseable concept along with automatic resource cleanup, which are basically the same things as IDisposable and a using statement in C#:</p>

<p>```java
try (FileReader reader = new FileReader(&ldquo;/dev/null&rdquo;))
{</p>

<pre><code>// Do something with a file...
</code></pre>

<p>}
```</p>

<h2>Other Languages</h2>

<p>Since the concept of something being done automatically is quite popular, it is present in many other languages. Python has both a <a href="http://docs.python.org/2/reference/compound_stmts.html#finally"><code>finally</code> statement</a> and a <a href="http://docs.python.org/release/2.5.3/ref/with.html"><code>with</code> statement</a>. The same goes for Ruby. Of course, this is also available in derivative languages like Visual Basic that is built on top of .NET technology, Groovy that is built on Java, etc.</p>

<h2>C++ — The King of RAII</h2>

<p>As we have seen, many languages provide different syntax to do essentially the same thing. It is a great concept indeed. It changed the way programmers write code, significantly improved productivity. And behind every invention that we cannot imagine our lives without there is an author. So who is behind the automatic resource management?</p>

<p>The real name of this concept is <strong>Resource Acquisition Is Initialization</strong>, or simply <strong>RAII</strong>. It was invented by Bjarne Stroustrup, the original author of C++ programming language. And of course this concept first appeared in C++, way before C# or Java were created.</p>

<p>C++ is the king of RAII. Many concepts are built upon it. RAII is the reason why object destructors are called automatically. It is the reason why C++ developers don’t need to care much about freeing dynamically allocated memory or close a file descriptor that is no longer used. It is why, when handling an error, it is enough to simply throw an exception, or return an error code from a function, without writing tons of “cleanup” code or even thinking about the order in which resources must be cleaned up (which is usually done in opposite order of allocation). In fact, RAII should be used whenever possible to avoid serious errors or even cause a denial of service. For example, consider the following code:</p>

<p>```c++</p>

<h1>include <mutex></h1>

<h1>include <vector></h1>

<p>// Data structure that is supposed to be accessed by multiple threads.
struct shared_resource {</p>

<pre><code>std::mutex       mutex;
std::vector&lt;int&gt; data;
</code></pre>

<p>};</p>

<p>void foo(shared_resource &amp; res)
{</p>

<pre><code>// Acquire an exclusive lock to protect access to
// the object in multi-threaded environment.
res.mutex.lock();

// Modify the contents of the vector by adding 10 integers into it.
for (int i = 0; i &lt; 10; ++i)
    res.data.emplace_back(i);

// Once done changing the object, release the lock so that other threads
// can work with it. If we forget to unlock it, the process will basically
// hang trying to lock the mutex again, rendering our program useless.
res.mutex.unlock();
</code></pre>

<p>}
```</p>

<p>The above code is a classic example of an error that could lead to serious consequences. The problem is that anything could happen in between of <code>mutex.lock()</code> and <code>mutex.unlock()</code> statements, and the <code>mutex.unlock()</code> statement may not be executed shall <code>data.emplace_back()</code> throw an exception, leaving the program in the locked-up state.</p>

<p>Taking a good care of exceptions is a concept called <strong>exception safety</strong>. The above code is indeed not exception safe. However, this is not only about exceptions. For instance, if <code>emplace_back()</code> method was not throwing an exception and return code was used to signal an error, the erroneous code could have looked like this:</p>

<p>```c++
int foo(shared_resource &amp; res)
{</p>

<pre><code>res.mutex.lock();
for (int i = 0; i &lt; 10; ++i) {
    if (res.data.emplace_back(i) != 0) {
        return -1;
    }
}
res.mutex.unlock();
return 0;
</code></pre>

<p>}
```</p>

<p>Exception safety is out of the equation, yet the code is buggy. This is why RAII should (almost) always be used. The correct code should look like this:</p>

<p>```c++
void foo(shared_resource &amp; res)
{</p>

<pre><code>std::lock_guard&lt;std::mutex&gt; lock(res.mutex);
for (int i = 0; i &lt; 10; ++i)
    res.data.emplace_back(i);
</code></pre>

<p>}
```</p>

<p>In the above example, <a href="http://en.cppreference.com/w/cpp/thread/lock_guard"><code>std::lock_guard</code></a> object is locking a mutex in its constructor and unlocks it in its destructor. Thanks to RAII, the destructor is guaranteed to be called when the object goes out of scope no matter what. C++ is full of such “guard” objects. Many of them are part of the standard library, but developers can always create their own.</p>

<p>```c++</p>

<h1>include <cctype></h1>

<h1>include <fstream></h1>

<h1>include <iostream></h1>

<p>int main()
{</p>

<pre><code>std::ifstream file("test.txt");
char c;
while ((file &gt;&gt; c))
    std::cout &lt;&lt; (std::isalpha(c) ? c : '*');
</code></pre>

<p>}
```</p>

<p>In the above example, the file object will automatically close the file. In other words, C++ clearly wins this battle over RAII with all other languages since there is no need for any finally blocks, using statements or event Java’s new <code>try()</code> blocks.</p>

<p>What is interesting is that C#, Java, Python and other similar languages did not even have “using”-like statements for a long time. There was only <em>try-catch-finally</em> construct and programmers had no choice but to write a lot of boilerplate code. Albeit some programmers have consciously suffered from the lack of proper RAII support, many didn’t know that C++ not only supports RAII but also is the only language that does it properly. One day those guys wanted to write something in C++ and of course started to look for similar self-torture methods. Not able to find it, they asked Bjarne Stroustrup why doesn’t C++ provide a <code>finally</code> construct, and <a href="http://www.stroustrup.com/bs_faq2.html#finally">here is what he had to say</a>:</p>

<blockquote><p>Because C++ supports an alternative that is almost always better: The “resource acquisition is initialization” technique (TC++PL3 section 14.4). The basic idea is to represent a resource by a local object, so that the local object’s destructor will release the resource. That way, the programmer cannot forget to release the resource.
…
In a system, we need a “resource handle” class for each resource. However, we don’t have to have an “finally” clause for each acquisition of a resource. In realistic systems, there are far more resource acquisitions than kinds of resources, so the “resource acquisition is initialization” technique leads to less code than use of a “finally” construct.</p></blockquote>

<p>Boy was he right. Most today’s languages are now trying to resemble the same.</p>

<h2>RAII in C</h2>

<p>Everyone knows that C neither support exceptions nor it has a concept of RAII. That is not entirely true, but for the most part it is. You will not find anything about those features in C89, C99 or even C11 language standard specifications. Therefore, C developers have to be careful, disciplined, and clean up after themselves. Oftentimes, especially in somewhat low-level code like device driver, we can run into the code like this:</p>

<p>```c
static int pci_probe(struct pci_dev *pci_dev,</p>

<pre><code>                 const struct pci_device_id *dev_id)
</code></pre>

<p>{</p>

<pre><code>struct my_dev *dev;
int r;

dev = kzalloc(sizeof(struct my_dev), GFP_KERNEL);
if (unlikely(!dev))
    goto on_err;
pci_set_drvdata(pci_dev, dev);
dev-&gt;pci_dev = pci_dev;
r = pci_enable_device(pci_dev);
if (unlikely(r))
    goto on_enable_err;
pci_set_master(pci_dev);
pci_try_set_mwi(pci_dev);
dev-&gt;bar0 = ioremap_nocache(pci_resource_start(pci_dev, 0),
                            pci_resource_len(pci_dev, 0));
if (unlikely(!dev-&gt;bar0))
    goto on_bar0_map_err;
dev-&gt;bar2 = ioremap_nocache(pci_resource_start(pci_dev, 2),
                            pci_resource_len(pci_dev, 2));
if (unlikely(!dev-&gt;bar2))
    goto on_bar2_map_err;
r = a2gx_add_cdev(dev);
if (r)
    goto on_cdev_err;
return 0;
</code></pre>

<p>  on_cdev_err:</p>

<pre><code>iounmap(dev-&gt;bar2);
</code></pre>

<p>  on_bar2_map_err:</p>

<pre><code>iounmap(dev-&gt;bar0);
</code></pre>

<p>  on_bar0_map_err:</p>

<pre><code>pci_disable_device(pci_dev);
</code></pre>

<p>  on_enable_err:</p>

<pre><code>kfree(dev);
</code></pre>

<p>  on_err:</p>

<pre><code>return -1;
</code></pre>

<p>}
```</p>

<p>Many will find the above code difficult to read, hard to write, or both. Some would love to punch the author in the face for using goto. Others may not understand what is going on in there at all. But C is not just a programming language. C is a religion. For some, C code is a lot cleaner than anything else — nothing is hiding behind the scenes, what you see is what you get. The C code is usually thought trough — you have to think twice before you write it. In fact, some wouldn’t substitute it for anything else. At any rate, C developers usually cleanup after themselves.</p>

<p>On the other hand, the benefits or RAII are also obvious and there are people who would love to see a concept of RAII in C. But it is not a part of the language specification. However, imagine a world when programmers were not using things that are not standard. That world would have been terrible. Just imagine for a second that C++ developers wouldn’t have multi-threaded programs until C++11 standard was ratified with all of its quirks and perks like <code>std::thread</code>, <code>std::mutex</code>, <em>thread local storage</em> and so on.</p>

<p>Or how about not being able to specify symbol’s visibility or use other attributes? Luckily, being a non-standard feature doesn’t restrain people from using it. And as more people use some feature, more chances it has to be standardized. That said, C++11 now allows for generalized yet compiler-specific attributes, threading, static assertions, and tons of other stuff that was available before, was used before, too, but wasn’t a part of the standard. Well, now it is.</p>

<p>That being said, C also supports RAII. However, it is not part of the standard, at least not yet. Here is how it works — it is possible to specify a cleanup function for any auto function scope variable. In order to do that, a non-standard cleanup attribute must be specified. If you remember the example of a buggy non-exception-safe C++ function that uses a <em>mutex</em>, that code would look something like this in C:</p>

<p>```c
struct shared_resource {</p>

<pre><code>pthread_mutex_t   mutex;
struct int_vector data;
</code></pre>

<p>};</p>

<p>struct shared_resource {</p>

<pre><code>pthread_mutex_t   mutex;
struct int_vector data;
</code></pre>

<p>};</p>

<p>int int_vector_push_back(struct int_vector *data, int value);</p>

<p>int foo(struct shared_resource *res)
{</p>

<pre><code>int i;

if (pthread_mutex_lock(&amp;res-&gt;mutex) != 0)
    return -1; /* Oops, cannot lock the mutex. */
for (i = 0; i &lt; 10; ++i) {
    if (int_vector_push_back(&amp;res-&gt;data, i) != 0) {
        /* Oops, cannot add data into the vector! */
        return -1;
    }
}
pthread_mutex_unlock(&amp;res-&gt;mutex);
return 0; /* All is good */
</code></pre>

<p>}
```</p>

<p>Though it is a little bit hard to imagine that C programmer could write code like that. The code would probably look more like this (which is also functionally correct this time):</p>

<p>```c
int test(struct shared_resource *res)
{</p>

<pre><code>int r;
int i;

r = pthread_mutex_lock(&amp;res-&gt;mutex);
if (r)
    goto out;
for (i = 0; i &lt; 10; ++i) {
    r = int_vector_push_back(&amp;res-&gt;data, i);
    if (r)
        break;
}
pthread_mutex_unlock(&amp;res-&gt;mutex);
</code></pre>

<p>  out:</p>

<pre><code>return r;
</code></pre>

<p>}
```</p>

<p>Below is a RAII-like version of the code where mutex is guaranteed to be unlocked automatically, so it is possible to simply return from the function at any given point without worrying about it. This code closely resembles the behavior of a C++ example using <code>std::lock_guard</code> where <code>lock_guard_ctor</code> mimics <code>std::lock_guard::lock_guard</code> constructor that locks a <em>mutex</em>, and the <code>lock_guard_dtor</code> function is like <code>std::lock_guard::~lock_guard</code> destructor that unlocks the <em>mutex</em> (if it was locked) and is guaranteed to be called automatically:</p>

<p>```c
pthread_mutex_t <em>lock_guard_ctor(pthread_mutex_t </em>mutex) {</p>

<pre><code>return pthread_mutex_lock(mutex) == 0 ? mutex : NULL;
</code></pre>

<p>}</p>

<p>void lock_guard_dtor(pthread_mutex_t **mutex_ptr) {</p>

<pre><code>pthread_mutex_t *mutex = *mutex_ptr;
if (mutex != NULL)
    pthread_mutex_unlock(mutex);
</code></pre>

<p>}</p>

<p>int foo(struct shared_resource *res) {</p>

<pre><code>int i;
pthread_mutex_t *lock_guard
    __attribute__((cleanup(lock_guard_dtor)))
    = lock_guard_ctor(&amp;res-&gt;mutex);
if (lock_guard == NULL)
    return -1;
for (i = 0; i &lt; 10; ++i) {
    if (int_vector_push_back(&amp;res-&gt;data, i) != 0)
        return -1;
}
return 0;
</code></pre>

<p>}
```</p>

<p>The above code can also be simplified a bit with two simple steps. Step one is to have <code>lock_guard_ctor</code> and <code>lock_guard_dtor</code> functions defined somewhere else and be reusable. Because nobody writes custom constructors and destructor for a class every time they use it. Step number two is to get rid of a lot of typing by having a macro. For example, the common code that is written once could be:</p>

<p>```c</p>

<h1>include &lt;pthread.h></h1>

<p>extern pthread_mutex_t <em>lock_guard_ctor(pthread_mutex_t </em>mutex);
extern void lock_guard_dtor(pthread_mutex_t **mutex_ptr);</p>

<h1>define LOCK_GUARD(name, mutex)                   \</h1>

<pre><code>pthread_mutex_t * name                        \
    __attribute__((cleanup(lock_guard_dtor))) \
    = lock_guard_ctor((mutex))
</code></pre>

<p>```</p>

<p>And the code using this feature becomes a lot simpler:</p>

<p>```c
int foo(struct shared_resource *res)
{</p>

<pre><code>int i;
LOCK_GUARD(lock, &amp;res-&gt;mutex);
if (!lock)
    return -1;
for (i = 0; i &lt; 10; ++i) {
    if (int_vector_push_back(&amp;res-&gt;data, i) != 0)
        return -1;
}
return 0;
</code></pre>

<p>}
```</p>

<p>There are two possible ways for a compiler to implement a cleanup attribute. If exceptions are not enabled, it would generate the boilerplate code similar to that otherwise written by the programmer manually. If exceptions are enabled then compiler would generate the code that executes a cleanup function during the stack unwinding (yes, there are exceptions in C, too).</p>

<p>Note that cleanup attribute cannot be used for global variables. constructor and destructor attributes should be used instead. The constructor attribute causes the function to be called automatically before execution enters <code>main()</code>. Similarly, the destructor attribute causes the function to be called automatically after <code>main()</code> completes or <code>exit()</code> is called. Functions with these attributes are useful for initializing data that is used implicitly during the execution of the program. It is also possible to manually control the order of execution by specifying priority number (optional).</p>

<p>The techniques described above are available at least in today’s leading C compilers — GCC and Clang. Remember, the future of the language is in hands of its users. If you really like the feature and it is not standard — use it, spread the world, write a feedback to compiler developers and language standard committee. It will definitely help to make it into the next standard revision.</p>

<p>Let the force be with you!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11 Final Override]]></title>
    <link href="http://741MHz.com/final-override/"/>
    <updated>2013-02-27T00:00:00-05:00</updated>
    <id>http://741MHz.com/final-override</id>
    <content type="html"><![CDATA[<h2>Preface</h2>

<p>The alternative name for this article is “How to protect yourself from others when it comes to polymorphism.” That is pretty much the primary purpose of two brand new C++ keywords introduced in C++11 — the <code>override</code> and <code>final</code>.</p>

<p>Those who have at least some experience in team-based C++ development must be aware of at least one of many pitfalls of polymorphism and virtual methods in particular. Let’s go over some of real-world problems that could easily force developers to run a debugger or read the code over and over again trying to figure out why the program is not working as expected.</p>

<h2>A Missing Virtual Function</h2>

<p>This could happen to anyone — there was a base class with a virtual function and developer has decided to overload it for a good reason. Everything was fine and the program worked as expected. But one day after, a fresh build simply stopped working, and the reason is not obvious. After spending some time debugging the program, it turned out that a function that should have been called does not appear to be called at all. What could be wrong?</p>

<p>Consider the following code where the Foo class is written by one developer while Bar was written by someone else and could even be part of another project:</p>

<p>```c++
class Foo {
public:</p>

<pre><code>Foo() { }
virtual ~Foo() { }

virtual int init() {
    do_very_important_stuff();
}
</code></pre>

<p>};</p>

<p>class Bar : public Foo {
public:</p>

<pre><code>Bar() { }
virtual ~Bar() { }

virtual int init() {
    Foo::init();
    do_some_more_important_stuff();
}
</code></pre>

<p>};
```</p>

<p>A few years later a new developer joins the company and accidentally removes a virtual keyword from the <code>init()</code> method’s declaration of class <em>Foo</em>. How that could even happen, you may ask? Maybe he was learning Emacs and executed a <em>replace-regexp</em> command without noticing all of the changes. Or maybe he just read the <em>Code Refactoring</em> book and decided to improve the code but couldn’t check all of the usages of class <em>Foo</em> because they were in a different repository that he didn’t have access to. Who knows? Things happen. As a result, the <code>Bar::init()</code> is no longer called because it does no longer override its base method. For example:</p>

<p>```c++</p>

<h1>include <iostream></h1>

<h1>include <memory></h1>

<p>class Foo {
public:</p>

<pre><code>Foo() { }
virtual ~Foo() { }

int init() {
    std::cout &lt;&lt; "Hello, World!\n";
}
</code></pre>

<p>};</p>

<p>class Bar : public Foo {
public:</p>

<pre><code>Bar() { }
virtual ~Bar() { }

virtual int init() {
    Foo::init();
    std::cout &lt;&lt; "The code is working!\n";
}
</code></pre>

<p>};</p>

<p>int main() {</p>

<pre><code>std::unique_ptr&lt;Foo&gt; foo(new Bar());
foo-&gt;init();
</code></pre>

<p>}
```</p>

<p>The above program will not print an expected “The code is working!” line and someone would definitely waste some time trying to figure out why, especially if the project has a few million lines of code.</p>

<h2>A Million Dollars Typo</h2>

<p>Typos can also cause a lot of troubles. For example, developers can misspell the name of the method when overriding:</p>

<p>```c++</p>

<h1>include <iostream></h1>

<h1>include <memory></h1>

<p>class Foo {
public:</p>

<pre><code>Foo() { }
virtual ~Foo() { }

virtual void doSomeVeryImportantWork() {
}
</code></pre>

<p>};</p>

<p>class Bar : public Foo {
public:</p>

<pre><code>Bar() { }
virtual ~Bar() { }

virtual void doSomeVeryInportantWork() {
    std::cout &lt;&lt; "The code is working!\n";
}
</code></pre>

<p>};</p>

<p>int main() {</p>

<pre><code>std::unique_ptr&lt;Foo&gt; foo(new Bar());
foo-&gt;doSomeVeryImportantWork();
</code></pre>

<p>}
```</p>

<p>The above program prints nothing despite the expectations and the reason is not immediately obvious.</p>

<h2>Signature Changes</h2>

<p>Signature change is another seemingly innocent change that may potentially waste a log of valuable time when not accounted for properly. For example, the base class’s <code>init()</code> function is changed from this:</p>

<pre><code>virtual void init() { }
</code></pre>

<p>… to this:</p>

<pre><code>virtual void init(int x = 0) {
}
</code></pre>

<p>The whole project still compiles just fine. Yet the program doesn’t work as expected anymore.</p>

<p>It’s also possible to accidentally override someone’s virtual function, etc. The list of such gotchas can go on and on. For those who can relate to this — you must know that you are not alone! C++ developers including myself have dealt with this and similar problems for the past few decades.</p>

<p>Luckily, since introduction of the C++11 the sun is shining on our side of the fence!</p>

<h2>We Override!</h2>

<p>Instead of using (or not using) a <code>virtual</code> keyword and assuming the base class has the method being overridden, we can now use the brand new <code>override</code> keyword. The compiler will then make sure that a method declared with that keyword really overrides the base method. And if that turns out to be not the case, the code won’t compile and the error would be caught during compilation, which is a lot better than debugging. The following is the new version of the first example:</p>

<p>```c++
class Bar : public Foo {
public:</p>

<pre><code>Bar() { }
virtual ~Bar() { }

int init() override {
    Foo::init();
    std::cout &lt;&lt; "The code is working!\n";
}
</code></pre>

<p>};
```</p>

<p>The compilation fails if the base class`s init() method is no longer there:</p>

<pre><code>error: ‘int Bar::init()’ marked override, but does not override
</code></pre>

<h2>It’s Final!</h2>

<p>The second keyword is <code>final</code>. It is a little bit less useful but is still a good self-defense mechanism against unintended usage and/or code changes.</p>

<p>What it means is that a method marked as final is not only virtual and must override its base but that nobody else can further override it. For example:</p>

<p>```c++</p>

<h1>include <iostream></h1>

<h1>include <memory></h1>

<p>class Foo {
public:</p>

<pre><code>Foo() { }
virtual ~Foo() { }

virtual int init() {
    std::cout &lt;&lt; "Hello, World!\n";
}
</code></pre>

<p>};</p>

<p>class Bar : public Foo {
public:</p>

<pre><code>Bar() { }
~Bar() override { }

int init() final {
    Foo::init();
    std::cout &lt;&lt; "This code works!\n";
}
</code></pre>

<p>};</p>

<p>int main() {</p>

<pre><code>std::unique_ptr&lt;Foo&gt; foo(new Bar());
foo-&gt;init();
</code></pre>

<p>}
```</p>

<p>The above code is sound and secure. But if somebody else would try to write a class like this:</p>

<p>```c++
class BetterBar : public Bar {
public:</p>

<pre><code>BetterBar() { }
~BetterBar() override { }

int init() override {
    Bar::init();
    std::cout &lt;&lt; "Even better init() function!\n";
}
</code></pre>

<p>};
```</p>

<p>… a compiler would tell them that they are wrong by issuing an error: </p>

<pre><code>error: virtual function ‘virtual int BetterBar::init()’
error: overriding final function ‘virtual int Bar::init()’
</code></pre>

<p>The <code>final</code> keyword can also be applied to the whole class in order to prevent further derivation from it. For example:</p>

<p>```c++
class Bar final : public Foo {
  public:</p>

<pre><code>Bar() {}
</code></pre>

<p>&hellip;
```</p>

<p>If anyone tries to inherit from Bar, the compiler issues an error: </p>

<pre><code>error: cannot derive from ‘final’ base ‘Bar’ in derived type ‘BetterBar’
</code></pre>

<p>What is interesting is that almost the same effect can be achieved in a less obvious way by applying the <code>final</code> keyword to a virtual destructor of either base (which is not the same as <code>final</code> in this case because it introduces a virtual table) or any derived class:</p>

<p>```c++
class Foo { // You cannot derive from me!
public:</p>

<pre><code>Foo() { }
virtual ~Foo() final { }
</code></pre>

<p>};
```</p>

<p>Template containers from the standard C++ library might be good candidates to be marked with a final keyword, as it is generally not a good idea to derive from them in almost every case.</p>

<h2>Conclusion</h2>

<p>C++11 introduces two important keywords in relation to polymorphism and inheritance — the <code>override</code> and <code>final</code>. Using those keywords should become a habit of any C++ developer. It is worth using every time except when writing a base class. This will make the code clear, maintainable, and potentially save hours that would have been otherwise wasted chasing an error in debugger.</p>

<h2>References</h2>

<ul>
<li><a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2928.htm">N2928</a> &ndash; Explicit Virtual Overrides</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3206.htm">N3206</a> &ndash; Override control: Eliminating Attributes</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3272.htm">N3272</a> &ndash; Follow-up on override control</li>
<li><a href="http://clang.llvm.org/cxx_status.html">Clang C++11 Status Report</a></li>
<li><a href="http://gcc.gnu.org/projects/cxx0x.html">GCC C++11 Status Report</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
