<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tech | Ranting @ 741 MHz]]></title>
  <link href="http://741MHz.com/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://741MHz.com/"/>
  <updated>2013-12-15T21:28:14-05:00</updated>
  <id>http://741MHz.com/</id>
  <author>
    <name><![CDATA[741MHz.com]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++ Devirtualization]]></title>
    <link href="http://741MHz.com/devirtualize/"/>
    <updated>2013-12-15T21:12:00-05:00</updated>
    <id>http://741MHz.com/devirtualize</id>
    <content type="html"><![CDATA[<p>Using a virtual dispatch might get relatively expensive in terms of clock cycles due to multiple levels of <a href="http://en.wikipedia.org/wiki/Indirection">indirections</a> including <a href="http://en.wikipedia.org/wiki/Indirect_branch">indirect branching</a> as well as <a href="http://gcc.gnu.org/onlinedocs/gcc/Bound-member-functions.html"><code>this</code> pointer adjustment</a>. Wise programmers do not use virtual dispatch without a good reason but oftentimes it is required either by design or when creating non-template reusable components/libraries and the final implementation of some parts of the program is not known.</p>

<p>Optimizing compilers do a great deal of work trying to optimize virtual dispatch as much as possible, sometimes even eliminating it in the end program entirely.  Let&rsquo;s take a quick look at how compilers implement virtual dispatch, how it can be optimized away and go over a few tricks that programmers can do to achieve better runtime performance.</p>

<h2>Virtual Dispatch Mechanics</h2>

<p>Implementation of the virtual dispatch in C++ is not covered by the language standard. It is up to compiler to decide how to implement it. All of the compilers that I&rsquo;ve worked with implement it using a <a href="http://en.wikipedia.org/wiki/Virtual_method_table">virtual method table</a> concept. The details of an exact implementation tend to get very complex once multiple inheritance, virtual inheritance and optimization gets involved. For utmost simple cases, one can think of a straightforward implementation where a base class has a pointer to an array of function pointers. To demonstrate this, let&rsquo;s write a functional equivalent of the below C++ program in C.</p>

<p>```c++ Simple C++ Example Using Virtual Dispatch
struct A {</p>

<pre><code>virtual ~A() {}
virtual int foo() { return 0; }
</code></pre>

<p>};</p>

<p>int main() {</p>

<pre><code>A a;
return a.foo();
</code></pre>

<p>}
```</p>

<p>Assuming that no optimization is performed, the above code can be described in C like this:</p>

<p><a name="c_vtable_example"></a>
```c Simple Virtual Table Example in C
struct A;</p>

<p>/<em>
 * A virtual table for class A implicitly generated by C++ compiler.
 * It consists of two &ldquo;methods&rdquo; &ndash; a pointer to a destructor of class A
 * and a pointer to A&rsquo;s &ldquo;foo&rdquo; virtual method implementation. In both cases
 * &ldquo;this&rdquo; pointer is a pointer to base class A which is passed to methods
 * implicitly.
 </em>/
struct A_vtable {</p>

<pre><code>    void (*destructor)(struct A *this);
    int (*foo)(struct A *this);
</code></pre>

<p>};</p>

<p>struct A {</p>

<pre><code>    /* A class implicitly gets a "vtable" pointer as its first field */
    const struct A_vtable *vtable;
</code></pre>

<p>};</p>

<p>/<em> Implementation of A&rsquo;s destructor </em>/
void A_destructor(struct A *this) {
}</p>

<p>/<em> Implementation of A&rsquo;s foo method. </em>/
int A_foo(struct A *this) {</p>

<pre><code>    return 0;
</code></pre>

<p>}</p>

<p>/<em> Virtual table for class A generated by the compiler </em>/
static const struct A_vtable A_vtable_instance = {</p>

<pre><code>    &amp;A_destructor,
    &amp;A_foo
</code></pre>

<p>};</p>

<p>int main() {</p>

<pre><code>    int ret;
    struct A a;

    /*
     * Initialize class A by setting its virtual table pointer.
     * This pointer can be set to a different "table" instance
     * in case of derived classes. This happens implicitly during
     * class construction.
     */
    a.vtable = &amp;A_vtable_instance;

    /* Invoke A's foo method through the virtual table. */
    ret = (a.vtable-&gt;foo)(&amp;a);

    /*
     * Call A's destructor. In our case this happens implicitly
     * because of RAII.
     * http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization
     */
    (a.vtable-&gt;destructor)(&amp;a);

    /* Return from main */
    return ret;
</code></pre>

<p>}
```</p>

<p>By looking at how virtual functions are called, it becomes apparent that invocation of a virtual function has some overhead. Basically, three steps need to be performed to call a virtual function:</p>

<ol>
<li>Offset must be applied to a virtual table in order to obtain an address of a function to call.</li>
<li>A pointer to a virtual table must be dereferenced to read the address of a function.</li>
<li>An <a href="http://en.wikipedia.org/wiki/Indirect_branch">indirect call</a> must be made to call a function by address stored in register.</li>
</ol>


<h3>x86_64 Machine Code</h3>

<p>To demonstrate this, let&rsquo;s look at the disassembled function that gets an instance of class <code>A</code> by reference and calls its virtual <code>foo()</code> method:</p>

<p>```c++ Simple Invocation of Virtual Method in C++
int call(A&amp; obj) {</p>

<pre><code>return obj.foo();
</code></pre>

<p>}
```</p>

<p>GCC would generate the following code for x86_64 with all optimizations turned off:</p>

<p><code>nasm Equivalent code in x86_64 assembler (unoptimised)
push   %rbp
mov    %rsp,%rbp
sub    $0x10,%rsp
mov    %rdi,-0x8(%rbp)
mov    -0x8(%rbp),%rax
mov    (%rax),%rax
add    $0x10,%rax
mov    (%rax),%rax
mov    -0x8(%rbp),%rdx
mov    %rdx,%rdi
callq  *%rax
leaveq
retq   
</code></p>

<p>Putting irrelevant parts aside, there are four instructions involved in virtual function call:</p>

<ol>
<li>Load vtable base address: <code>mov    (%rax),%rax</code></li>
<li>Apply offset to get address of the function to call: <code>add    $0x10,%rax</code></li>
<li>Read the address of the function: <code>mov    (%rax),%rax</code></li>
<li>Perform indirect call: <code>callq  *%rax</code></li>
</ol>


<p>With optimization turned on, GCC omits a frame pointer, gets rid of one extra memory load, does not move around parameters on the stack. The code is much better, yet the most expensive operations are still there:</p>

<p><code>nasm Equivalent code in x86_64 assembler (optimised)
   mov    (%rdi),%rax
   mov    0x10(%rax),%rax
   jmpq   *%rax
</code></p>

<p>In more complex scenarios, such as multiple inheritance, compiler might also need to adjust an the value of <code>this</code> pointer that is implicitly passed to the virtual function so that it points to a correct base class in the inheritance hierarchy. One more extra level of indirection might also be needed in case of virtual inheritance.</p>

<h2>Optimizations</h2>

<p>There are a few optimizations that compilers can do to improve the runtime performance when it comes to virtual dispatch.</p>

<h3>Extracting the Function Pointer</h3>

<p>Calling a virtual function involves multiple steps. In case when virtual function is called multiple times, such as calling the function in a loop or subsequently calling the same function of the same object, compiler optimizes the code by performing the following steps just once:</p>

<ol>
<li>Loading the member pointer from a virtual table. It consists of a function pointer and information needed to adjust <code>this</code> pointer.</li>
<li>Adjusting <code>this</code> pointer.</li>
<li>Extracting a function pointer from member pointer.</li>
</ol>


<p>Then compilers simply perform the fourth step by calling a function using an extracted function pointer with adjusted <code>this</code> pointer.</p>

<h4>GCC Extension</h4>

<p>The function pointer extraction is &ldquo;unsafe&rdquo; and &ldquo;dangerous&rdquo; and done by the compiler automatically, behind the scenes. GCC, unlike other compilers, provides a non-standard extension for brave developers who know what they are doing, so that they can do this manually. It is part of pointer-to-member function (PMF) conversion functionality and is described in ยง7.6:</p>

<blockquote><p><strong>7.6 Extracting the function pointer from a bound pointer to member function</strong></p>

<p>In C++, pointer to member functions (PMFs) are implemented using a wide pointer of sorts to handle all the possible call mechanisms; the PMF needs to store information about how to adjust the <code>this</code> pointer, and if the function pointed to is virtual, where to find the vtable, and where in the vtable to look for the member function. If you are using PMFs in an inner loop, you should really reconsider that decision. If that is not an option, you can extract the pointer to the function that would be called for a given object/PMF pair and call it directly inside the inner loop, to save a bit of time.</p>

<p>Note that you still pay the penalty for the call through a function pointer; on most modern architectures, such a call defeats the branch prediction features of the CPU. This is also true of normal virtual function calls.</p>

<p>The syntax for this extension is</p>

<pre><code>extern A a;
extern int (A::*fp)();
typedef int (*fptr)(A *);

fptr p = (fptr)(a.*fp);
</code></pre>

<p>For PMF constants (i.e. expressions of the form <code>&amp;Klasse::Member</code>), no object is needed to obtain the address of the function. They can be converted to function pointers directly:</p>

<pre><code>fptr p1 = (fptr)(&amp;A::foo);
</code></pre>

<p>You must specify <code>-Wno-pmf-conversions</code> to use this extension.</p></blockquote>

<h4>Manual PMF</h4>

<p>This is also possible to do with other compilers, though in a lot more dangerous manner. For example, having a member pointer and knowing the ABI of a given platform (for example, Itanium C++  ABI describes member pointers &ldquo;layout&rdquo; in ยง2.3 <a href="http://refspecs.linuxbase.org/cxxabi-1.83.html#member-pointers"><em>Member Pointers</em></a>), programmers can &ldquo;extract&rdquo; <code>this</code> adjustment information as well as raw function pointer, essentially performing PMF manually.</p>

<h3>Devirtualization</h3>

<p>In order to reduce the overhead and improve runtime performance, optimizing compilers attempt to convert calls to virtual functions to direct calls. This is done both within a procedure and interprocedurally as part of indirect inlining and interprocedural constant propagation.</p>

<p>This optimization technique is implemented by most production grade C++ compilers. For example, both GCC and clang perform this optimization. To demonstrate what it does, let&rsquo;s say we got a piece of code written by a third-party company that does a lot of great things and looks like this:</p>

<p>```c++ A great API
struct A {</p>

<pre><code>virtual ~A() {}
virtual int foo() { return 0; }
</code></pre>

<p>};</p>

<p>inline int do_something(A&amp; obj) {</p>

<pre><code>return obj.foo();
</code></pre>

<p>}
```</p>

<p>At this point, there isn&rsquo;t much that can be done because the end-user use case is unknown at this stage. But let&rsquo;s say the user of the above API writes the following program:</p>

<p>```c++ A great API end-usage
struct B : A {</p>

<pre><code>virtual ~B() {}
virtual int foo() { return 1; }
</code></pre>

<p>};</p>

<p>int main() {</p>

<pre><code>B b;
return do_something(b);
</code></pre>

<p>}
```</p>

<p>By looking at the code, it is obvious that class <code>B</code> is the final class in the inheritance hierarchy. Therefore, when <code>do_something()</code> function is called, calling <code>B</code>&rsquo;s <code>foo()</code> method directly would result in a functional equivalent of calling it through the virtual table.</p>

<p>When compiling the above program with optimization turned on, compiler takes that information into account. Since compilers has a definition of <code>do_something()</code> function body, a wise compiler chooses to perform a direct call or even inline the body of a derived class&rsquo;s virtual function, which in the above case is <code>B::foo()</code>.</p>

<p>Interestingly enough, since all of the code is known to the compiler, it optimizes the program further, eventually reducing it to just a few CPU instructions:</p>

<p>```nasm
_main:</p>

<pre><code>mov    eax,0x1
ret    
</code></pre>

<p>```</p>

<p>From the above observation we can draw a conclusion that when compiler has all of the information needed, it optimizes away the virtual dispatch.</p>

<h3>Link Time Optimization</h3>

<p>Needless to say that the above example is very simple and naive. In real-life it is unlikely that <code>do_something()</code> function body will be known. Because it was chosen to use virtual dispatch instead of template meta-programming, body of the function is likely complex and resides in a compiled object file. In that case compiler would not be able to deduce the information it needs to perform devirtualization. This makes this optimization unlikely to occur in real-life.</p>

<p>There is a way to make it work though. Both GCC and clang provide a feature called Link Time Optimization (aka LTO). When this feature is enabled, compilers generate object files in intermediate language. GCC uses <a href="http://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html">GIMPLE</a>  for this purpose while Clang is using <a href="http://llvm.org/docs/BitCodeFormat.html">LLVM bitcode</a>. Such &ldquo;intermediate&rdquo; object files can later be used by the compiler to perform intermodular optimizations. At the same time, source code is not required to be distributed shown, which makes it great for paranoid software vendors. Intermodular optimizations, which in case of LTO are performed at linking stage, allow the compiler to inline functions defined in separate object files or, what&rsquo;s most important in our case, perform devirtualization across different translation units.</p>

<p>Getting back to our simple example, given that user program is stored in <code>file1.cc</code> and <code>do_something()</code> function is defined in <code>file2.cc</code>, compiler does not perform devirtualization. However, when both files are compiled with LTO enabled, the resulting program is optimized down to two CPU instructions. Here is an example of compiling and linking two separate files with LTO using GCC:</p>

<p><code>sh
$ g++ -Wall -O3 -flto -c ./file1.cc
$ g++ -Wall -O3 -flto -c ./file2.cc
$ g++ -Wall -O3 -flto ./file1.o ./file2.o -o prog
</code></p>

<p>The only time when this won&rsquo;t work is when the code is provided in a form of shared object because LTO does not work across shared object boundaries.</p>

<p>So if you plan on providing a library that must use a virtual dispatch and is performance critical to the point where tradeoffs of the virtual dispatch start to matter, consider distributing the code in a form of pre-compiled static library built with LTO support.</p>

<h3>C++11 Final Keyword</h3>

<p>Sometimes compilers are not able to determine that a class is a final instance in the inheritance hierarchy. Consider the following code:</p>

<p>```c++
struct A {</p>

<pre><code>virtual ~A() {}
virtual int foo() { return 0; }
</code></pre>

<p>};</p>

<p>struct B : A {</p>

<pre><code>virtual ~B() {}
virtual int foo() { return 1; }
</code></pre>

<p>};</p>

<p>int do_something(B&amp; b) {</p>

<pre><code>b.foo();
</code></pre>

<p>}
```</p>

<p>In the above example, compiler does not know whether some other classes could inherit from class <code>B</code> or not. Therefore, it would not devirtualize the invocation of <code>b.foo()</code> when generating the code for <code>do_something()</code> function body.</p>

<p>If, however, nothing else inherits from <code>B</code>, then programmers might want to consider using a <code>final</code> keyword that was introduced in C++11. Once the class <code>B</code> is marked as <code>final</code>, compiler knows that <code>B</code> is the final instance in the inheritance tree and immediately optimizes away all indirect calls.</p>

<p>```c++
struct B final : A {</p>

<pre><code>virtual ~B() {}
virtual int foo() { return 1; }
</code></pre>

<p>};
```</p>

<h3>Devirtualization in C</h3>

<p>Even though C language does not have a concept of virtual dispatch built into the language, compilers do recognize this concept and can still optimize away all indirect calls. Both GCC and clang have compiled a simple <a href="#c_vtable_example">C virtual dispatch example</a> program into, well, almost nothing. Here is what Clang generated:</p>

<p><code>
00000000004004b0 &lt;main&gt;:
  4004b0:       31 c0                   xor    eax,eax
  4004b2:       c3                      ret    
  4004b3:       66 2e 0f 1f 84 00 00    nop    WORD PTR cs:[rax+rax*1+0x0]
  4004ba:       00 00 00
  4004bd:       0f 1f 00                nop    DWORD PTR [rax]
</code></p>

<p>And here is what GCC have done:</p>

<p><code>
0000000000400400 &lt;main&gt;:
  400400:       31 c0                   xor    eax,eax
  400402:       c3                      ret    
  400403:       90                      nop
</code></p>

<p>```nasm Thanks for reading!
_the_end:</p>

<pre><code>as always
thanks for
reading
nop
nop
</code></pre>

<p>```</p>

<h2>See Also</h2>

<ul>
<li><a href="/wide-pointers/">Why C++ Member Function Pointers Are 16 Bytes Wide</a></li>
<li><a href="/final-override/">C++11 Final Override</a></li>
<li><a href="/switch/">From Switch Statement Down to Machine Code</a></li>
<li><a href="/blog/categories/c-plus-plus-11">Posts about C++11 features</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Smart Command Line Options Parsing]]></title>
    <link href="http://741MHz.com/smart-getopt/"/>
    <updated>2013-12-03T08:47:00-05:00</updated>
    <id>http://741MHz.com/smart-getopt</id>
    <content type="html"><![CDATA[<p>A countless number of command line programs have been written since the invention of computers. Most of them parse command line options and spew out errors and usage messages if a user enters an unknown option or simply makes a typo. Examples are not far to seek. Make a typo trying to commit your changes into SVN repository and <a href="http://en.wikipedia.org/wiki/Apache_Subversion">Subversion</a> would bail out with errors:</p>

<p><code>bash
$ svn commir
Unknown command: 'commir'
Type 'svn help' for usage.
</code></p>

<p>There are command line tools that are standing out among others, impress with their intelligence and deliver unforgettable user experience.</p>

<p>One of them is <a href="http://git-scm.com/">Git</a>. If it encounters an unknown option, it can analyze it, guess what user meant and suggest correct options:</p>

<p>```bash
$ git commir
git: &lsquo;commir&rsquo; is not a git command. See &lsquo;git &mdash;help&rsquo;.</p>

<p>Did you mean this?</p>

<pre><code>commit
</code></pre>

<p>```</p>

<p>To see this kind of feature in a command line tool is a pleasant surprise and could catch userโs attention. But if we take one step back and try to reckon programs with similar features, there will be a lot. Any decent word processors would have spell-checking feature that not only can detect mistakes but also suggest a correct spelling. Proofreading tools. Search engines often guess what we are looking for as well.</p>

<p><img src="/images/levenshtein-getopt/kute.png"></p>

<p>So what kind of sorcery is this?</p>

<h2>String Metrics</h2>

<p>All of the similar algorithms are based on string metric algorithms that measure similarity or dissimilarity between two strings for <a href="http://en.wikipedia.org/wiki/Approximate_string_matching">approximate matching</a> or comparison and in <a href="http://en.wikipedia.org/wiki/Approximate_string_matching">fuzzy string searching</a>. The similarity or dissimilarity between two strings of text is commonly known as string distance.</p>

<p>There are <a href="http://en.wikipedia.org/wiki/String_metrics">a number of different string metrics algorithms</a>. The most widely known string metric is the Levenshtein Distance, also known as Edit Distance.</p>

<p>Informally, the Levenshtein distance between two words is the minimum number of single-character edits (insertion, deletion, substitution) required to change one word into the other. One could apply this algorithm to determine which one of the possible words is the most similar by comparing a number of character edits it requires to transform one word into another.</p>

<h2>How Git Does This</h2>

<p>Since <a href="http://git-scm.com">Git</a> is <a href="http://git-scm.com/about/free-and-open-source">free and open source</a>, we can check how it does the command line argument suggestion, and what algorithm is being used for that.</p>

<p>The Git source code can be downloaded or viewed online at <a href="https://github.com/git/git">https://github.com/git/git</a>. All of the command line options handling is implemented in <a href="https://github.com/git/git/blob/master/help.c">help.c</a> file, and the suggestion is being made by <code>help_unknown_cmd()</code> function on line 293.</p>

<p>After quickly grasping through the code, it turns out that Git is using a <a href="http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance">DamerauโLevenshtein distance algorithm</a> to calculate similarities between an unknown command and a list of supported commands. The implementation of this algorithm consists of two small files &ndash; <a href="https://github.com/git/git/blob/master/levenshtein.h">levenshtein.h</a> and <a href="https://github.com/git/git/blob/master/levenshtein.c">levenshtein.c</a>.</p>

<h2>Use It In Your Program</h2>

<p>To see how hard it would be to implement something similar, we have decided to borrow the algorithm implementation and use it to implement a simple command line tool in C++.</p>

<p>The basic idea is to accept command line options from a user and function that corresponds to a command name. In case the command name is unknown, use Damerau-Levenshtein algorithm and compare the unknown command to a list of supported ones. The algorithm returns an integer number that is a string distance. The bigger it is, less similar two strings are. Therefore, after comparing all of the strings, we simply store a result in <code>std::map</code> and take the first element as the most likely command user meant to type, but didnโt quite get it right.</p>

<p>Since we are more focused on C++ rather than C, the first is to transform levenshtein.c into a C++ code (alternatively, a <a href="http://www.parashift.com/c++-faq/mixing-c-and-cpp.html">mixing of C and C++</a> code could have been used) and get rid of Git-specific <code>xmalloc()</code> function. Here are the changes:</p>

<p>```diff
&mdash;&ndash; ../git/levenshtein.c    2013-12-03 19:09:52.000000000 -0500
+++ levenshtein.cc  2013-12-03 19:49:40.000000000 -0500
@@ -1,5 +1,6 @@
&ndash;#include &ldquo;cache.h&rdquo;
&ndash;#include &ldquo;levenshtein.h&rdquo;
+#include &ldquo;levenshtein.hh&rdquo;
+#include <cstdlib> // for malloc and free
+#include <cstring> // for strlen</p>

<p> /*
  * This function implements the Damerau-Levenshtein algorithm to
@@ -42,9 +43,9 @@</p>

<pre><code>    int w, int s, int a, int d)
</code></pre>

<p> {</p>

<pre><code>int len1 = strlen(string1), len2 = strlen(string2);
</code></pre>

<ul>
<li>int *row0 = xmalloc(sizeof(int) * (len2 + 1));</li>
<li>int *row1 = xmalloc(sizeof(int) * (len2 + 1));</li>
<li>int *row2 = xmalloc(sizeof(int) * (len2 + 1));</li>
<li>int <em>row0 = (int</em>)malloc(sizeof(int) * (len2 + 1));</li>
<li>int <em>row1 = (int</em>)malloc(sizeof(int) * (len2 + 1));</li>
<li><p>int <em>row2 = (int</em>)malloc(sizeof(int) * (len2 + 1));
int i, j;</p>

<p>for (j = 0; j &lt;= len2; j++)
```</p></li>
</ul>


<p>And a simple command line tool that uses Git&rsquo;s <code>levenshtein()</code> function:</p>

<p>```c++
//
// An example of using Damerau-Levenshtein algorithm
// to suggest a correct command if user enters something
// that we don&rsquo;t know how to handle.
//</p>

<h1>include <cstdlib></h1>

<h1>include <string></h1>

<h1>include <map></h1>

<h1>include &lt;unordered_map></h1>

<h1>include <iostream></h1>

<h1>include &ldquo;levenshtein.h&rdquo;</h1>

<p>// Define command handler function type.
static void on_help() {</p>

<pre><code>std::cout &lt;&lt; "Sure thing! What can I do for you?\n";
</code></pre>

<p>}</p>

<p>static void on_version() {</p>

<pre><code>std::cout &lt;&lt; "I am not versioned, sorry.\n";
</code></pre>

<p>}</p>

<p>static void on_verbose() {</p>

<pre><code>std::cout &lt;&lt; "If you need verbose, go read Twitter!\n";
</code></pre>

<p>}</p>

<p>static void on_say() {</p>

<pre><code>std::cout &lt;&lt; "Oops, my speech speed synthesizer is broken :(\n";
</code></pre>

<p>}</p>

<p>// This function does not need an introduction.
int main(int argc, const char *argv[]) {</p>

<pre><code>// Check that we have at least one argument.
if (argc &lt; 2) {
    std::cerr &lt;&lt; "Please enter a command\n";
    return EXIT_FAILURE;
}

// Deduce command from command line.
std::string cmd{argv[1]};

// Create a list of commands.
const std::unordered_map&lt;
    std::string,
    std::function&lt;void()&gt;
&gt; cmd_map{
    { "help", &amp;on_help },
    { "say", &amp;on_say },
    { "version", &amp;on_version },
    { "verbose", &amp;on_verbose }
};

// Find a command.
auto cmd_it = cmd_map.find(cmd);
if (cmd_it != cmd_map.end()) {
    // Command was found. Run the handler and exit.
    (cmd_it-&gt;second)();
    return EXIT_SUCCESS;
}

// If we get there, the command is unknown.
// First, tell it to the user.
std::cerr &lt;&lt; "Unknown command: " &lt;&lt; cmd &lt;&lt; '\n';

// Use Damerau-Levenshtein algorithm to get similarity
// score with all of the commands we support, then pick
// the best few to suggest to the user.
std::multimap&lt;
    int /* Levenshtein distance, less is better. */,
    std::string /* Supported command */
&gt; dist;

for (auto&amp; p : cmd_map) {
    dist.emplace(
        levenshtein(
            cmd.c_str(), // Command entered by the user.
            p.first.c_str(), // One of the supported commands.
            0, // swap cost
            2, // substitution cost
            1, // insertion cost
            3  // deletion cost
        ),
        p.first
    );
}

// Take the first best guess (lowest distance = better match).
// Suggest a list of commands with the same Levenshtein distance.
// This can be tweaked to show more options, etc..
if (!dist.empty()) {
    auto best_score = dist.begin()-&gt;first;
    std::cerr &lt;&lt; "Did you mean one of these?\n";
    for (auto&amp; p : dist) {
        if (p.first != best_score) {
            // For more option, one could use something like
            // `p.first - best_score &gt; N` where N is max.
            // allowed difference.
            break;
        }
        std::cout &lt;&lt; '\t' &lt;&lt; p.second &lt;&lt; '\n';
    }
}

return EXIT_FAILURE;
</code></pre>

<p>}
```</p>

<p>Compile two files into a binary using Clang:</p>

<p><code>bash
clang++ -Wall -Wextra -pedantic -std=c++11 -o test ./smart_help.cc
</code></p>

<p>The tool supports only three commands โ &ldquo;help&rdquo;, &ldquo;version&rdquo;, &ldquo;verbose&rdquo; and &ldquo;say&rdquo;. Let&rsquo;s say user only types &ldquo;ver&rdquo;, in that case it correctly suggest two possible alternatives:</p>

<p>```bash
$ ./test ver
Unknown command: ver
Did you mean one of these?</p>

<pre><code>verbose
version
</code></pre>

<p>```</p>

<p>It doesn&rsquo;t lose face when handling &ldquo;he&rdquo; and &ldquo;s&rdquo; as well:</p>

<p>```
$ ./test he
Unknown command: he
Did you mean one of these?</p>

<pre><code>help
</code></pre>

<p>$ ./test s
Unknown command: s
Did you mean one of these?</p>

<pre><code>say
</code></pre>

<p>```</p>

<p>Of course, it is possible to tweak and tune this program further &ndash; do more error checking, play with different cost weights, do less or more aggressive guessing and so one.</p>

<p>The main point is โ it isnโt all that difficult to make your command line option parsing more intelligent and user friendly by using this or similar algorithms. A great <a href="http://en.wikipedia.org/wiki/User_experience">user experience</a> matters a lot.</p>

<p>Maybe one day this would become a standard feature of option parsing libraries like <a href="http://www.boost.org/doc/libs/release/doc/html/program_options.html">Boostโs Program Options</a>, Pythonโs <a href="http://docs.python.org/2.7/library/argparse.html">argparse</a> and even GNU <a href="http://www.gnu.org/software/libc/manual/html_node/Getopt.html">getopt</a>.</p>

<p>As always, thanks for reading!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Range-Based For Loop]]></title>
    <link href="http://741MHz.com/range-for/"/>
    <updated>2013-11-23T09:23:00-05:00</updated>
    <id>http://741MHz.com/range-for</id>
    <content type="html"><![CDATA[<p>How do you write a &ldquo;for&rdquo; loop in C++? This could be done in many different ways. One could write it like this:</p>

<p>```c++
for (int i = 0; i &lt; N; ++i) {</p>

<pre><code>// ...
</code></pre>

<p>}
```</p>

<p>&hellip; or like this:</p>

<p>```c++
for (iterator_type it = data.begin(); it != data.end(); ++it) {</p>

<pre><code>// ...
</code></pre>

<p>}
```</p>

<p>The most hand-crafted loops though usually looks like this:</p>

<p>```c++
for (iterator_type it = data.begin(), eit = data.end(); it != eit; ++it) {</p>

<pre><code>reference_type&amp; value = *it;
// ...
</code></pre>

<p>}
```</p>

<p>And although professional C++ developers, after years of training their left cerebral hemisphere, quickly grasp any of the above variations of the loop, one cannot not agree that a syntax is a bit inefficient and hard to read, especially for novice developers. So why such a simple thing should be that complicated? Can we do this simpler?</p>

<h2>Range-Based For Loop (Since C++11)</h2>

<p>C++11 provides a new, more readable syntax for iterating over a range of values, which is called a &ldquo;range-based for&rdquo;. Its syntax is very simple:</p>

<p>```c++
for (range_declaration : range_expression)</p>

<pre><code>loop_statement;
</code></pre>

<p>```</p>

<p>For the above syntax, the compiler will produce code similar to the following:</p>

<p>```c++
auto&amp;&amp; <strong>range = range_expression ;
for (auto </strong>begin = begin_expr, <strong>end = end_expr;  </strong>begin != <strong>end; ++</strong>begin) {</p>

<pre><code>range_declaration = *__begin; 
loop_statement;
</code></pre>

<p>}
```</p>

<p>The generated code looks very similar to that of professionally hand-crafted for-loops. But it is a lot easier to both read and write. Let&rsquo;s go over a few code snippets demonstrating how to use this new for loop syntax.</p>

<h2>Examples</h2>

<p>A very simple iteration over a vector:</p>

<p>```c++
std::vector<int> vec { 1, 2, 3, 4, 5 };
for (int v : vec) {</p>

<pre><code>std::cout &lt;&lt; v &lt;&lt; std::endl;
</code></pre>

<p>}
```</p>

<p>For more generic programming, using <a href="/c/auto">&ldquo;auto&rdquo; keyword</a> to let compiler automatically deduce the type is also possible:</p>

<p>```c++</p>

<h1>include <iostream></h1>

<h1>include <vector></h1>

<p>template <typename Range>
void print(const Range&amp; range) {</p>

<pre><code>for (auto&amp; element : range) { // Using "auto" with range-based for loop.
    std::cout &lt;&lt; element &lt;&lt; std::endl;
}
</code></pre>

<p>}</p>

<p>int main() {</p>

<pre><code>std::vector&lt;int&gt; vec { 1, 2, 3, 4, 5 };
print(vec);
</code></pre>

<p>}
```</p>

<p>The range-based for loop also works with plain arrays:</p>

<p>```c++
const int data[] = { 1, 2, 3, 4, 5 };
for (auto&amp; v : data)</p>

<pre><code>std::cout &lt;&lt; v &lt;&lt; std::endl;
</code></pre>

<p>```</p>

<h3>Range-Based For With Custom Types</h3>

<p>One of the questions that is often raised is how to use this new syntax with custom types. There are two possible ways to do this.</p>

<p>The first is to make your custom class provide two member functions: <code>begin()</code> and <code>end()</code>. They should return beginning of the iterate-able range as well as its end, respectively (both should be of the same type). For example:</p>

<p>```c++</p>

<h1>include <iostream></h1>

<h1>include <string></h1>

<p>class custom_container {
public:</p>

<pre><code>const char* begin() const {
    return data_.c_str();
}

const char* end() const {
    return data_.c_str() + data_.size();
}
</code></pre>

<p>private:</p>

<pre><code>std::string data_ = "Hello, Range-Based For!";
</code></pre>

<p>};</p>

<p>int main() {</p>

<pre><code>custom_container container;
for (auto&amp; element : container)
    std::cout &lt;&lt; element;
std::cout &lt;&lt; std::endl;
</code></pre>

<p>}
```</p>

<p>The second approach is to provide freestanding <code>begin()</code> and <code>end()</code> functions for a data type:</p>

<p>```c++</p>

<h1>include <iostream></h1>

<h1>include <string></h1>

<p>class custom_container {
public:</p>

<pre><code>const std::string&amp; data() const { return data_; }
</code></pre>

<p>private:</p>

<pre><code>std::string data_ = "Hello, Range-Based For!";
</code></pre>

<p>};</p>

<p>const char* begin(const custom_container&amp; c) {</p>

<pre><code>return c.data().c_str();
</code></pre>

<p>}</p>

<p>const char* end(const custom_container&amp; c) {</p>

<pre><code>return c.data().c_str() + c.data().size();
</code></pre>

<p>}</p>

<p>int main() {</p>

<pre><code>custom_container container;
for (auto&amp; element : container)
    std::cout &lt;&lt; element;
std::cout &lt;&lt; std::endl;
</code></pre>

<p>}
```</p>

<p>Note that compiler will first look for member functions, then for free-standing functions. This is described in 6.5.4/1 of the C++ standard.</p>

<h2>Old Style Still Apply</h2>

<p>So can we switch to use a new range-based for loops everywhere? Where possible, it could simplify the code and theoretically even make it faster (only if optimizing compiler is way too silly and does not handle loop optimizations well). But in cases where we do need an iterator or perhaps some other loop type like <code>while</code>, the range-based for loop won&rsquo;t work. For example, the below loop cannot be substituted for a new one:</p>

<p>```c++
auto it = map.begin(), eit = map.end();
while (it != eit) {</p>

<pre><code>if (it-&gt;second &gt; 0)
    ++it;
else
    it = map.erase(it);
</code></pre>

<p>}
```</p>

<h2>See Also</h2>

<ul>
<li><a href="/auto-type">C++, Type Safety and Automatic Type Deduction With โautoโ Keyword</a></li>
</ul>


<h3>References</h3>

<ul>
<li><a href="http://en.cppreference.com/w/cpp/language/range-for">Range-based for loop @ cppreference.com</a></li>
<li><a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2930.html">N2930 &ndash; Range-Based For Loop Wording (Without Concepts)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Inheriting constructors in C++11]]></title>
    <link href="http://741MHz.com/inheriting-constructors/"/>
    <updated>2013-11-17T13:00:00-05:00</updated>
    <id>http://741MHz.com/inheriting-constructors</id>
    <content type="html"><![CDATA[<p>We have previously reviewed a feature introduced in C++11 that allows a class to delegate work between multiple constructors constructors of a class, called &ldquo;<a href="/delegating-constructors">Delegating Constructors</a>&rdquo; that allows one constructor to call another:</p>

<p>```c++
struct A {</p>

<pre><code>explicit A(int i) : x(i), n(x * (x - 1)) {}
explicit A(double f) : A((int)lround(f)) {}

int x;
int n;
</code></pre>

<p>};
```</p>

<p>Although extremely useful in boosting efficiency, it does not solve the problem when programmer wants to create a derived class that has exactly the same set of constructor as its base class or classes. In which case programmers are forced to tediously duplicate constructors of the base class, for example:</p>

<p>```c++
struct A {</p>

<pre><code>A(int) {}
A(double) {}
A(int, double) {}
</code></pre>

<p>};</p>

<p>struct B : A {</p>

<pre><code>// Programmers are forced to define at least one
// if not all of the following constructors:
B(int v) : A(v) {}
B(double v) : A(v) {}
B(int x, double y) : A(x, y) {}
</code></pre>

<p>};
```</p>

<p>C++11 solves this problem by introducing constructor inheritance. In a derived class, programmers can write a single <code>using T::T;</code> statement that makes a derived class automatically inherit constructors of a base class. For example:</p>

<p>```c++
struct A {</p>

<pre><code>A(int) {}
A(double) {}
A(int, double) {}
</code></pre>

<p>};</p>

<p>struct B : A {</p>

<pre><code>using A::A;
</code></pre>

<p>};
```</p>

<p>How this works is obvious for utmost simple cases. It might not be as clear when multiple inheritance is involved. For those cases, inheriting constructors would only work if all but one base classes have default constructors. For example, the following would work:</p>

<p>```c++
struct A {</p>

<pre><code>A() {}
</code></pre>

<p>};</p>

<p>struct B {</p>

<pre><code>B(int) {}
</code></pre>

<p>};</p>

<p>struct C : A, B {</p>

<pre><code>using B::B;
</code></pre>

<p>};
```</p>

<p>And will be an equivalent of the following hand-crafted constructor:</p>

<p>```c++
struct C : A, B {</p>

<pre><code>C(int v) : A(), B(v) {}
</code></pre>

<p>};
```</p>

<p>But if <code>A</code> does not have default constructor (even if the signature is the same as <code>B</code>), it won&rsquo;t work, so the below code is ill-formed:</p>

<p>```c++
struct A {</p>

<pre><code>A(int) {}
</code></pre>

<p>};</p>

<p>struct B {</p>

<pre><code>B(int) {}
</code></pre>

<p>};</p>

<p>struct C : A, B {</p>

<pre><code>using B::B;
</code></pre>

<p>};
```</p>

<p>There is also another catch that programmers should be aware of. It is the same old problem as forgetting to initialize class fields:</p>

<p>```c++
struct A {</p>

<pre><code>A(int) {}
</code></pre>

<p>};</p>

<p>struct B : A {</p>

<pre><code>using A::A;
int x;
</code></pre>

<p>};
```</p>

<p>With the above code, class <code>B</code> introduces <code>B(int)</code> constructor through inheritance of <code>A</code>&rsquo;s constructor(s), but it leaves <code>x</code> uninitialized. This means that inherited constructors might be useless if we need to initialize POD types. But do not rush with writing a custom constructor in this case. One can use non-static data member initializers, another new C++11 feature that we have reviewed before, to initialize <code>x</code>. For example:</p>

<p>```c++
struct A {</p>

<pre><code>A(int) {}
</code></pre>

<p>};</p>

<p>struct B : A {</p>

<pre><code>using A::A; // Inheriting A's constructor to create B::B(int){}
int x = 0;  // Initializing "x" using non-static field initializer.
</code></pre>

<p>};
```</p>

<h3>See Also</h3>

<ul>
<li><a href="/delegating-constructors">Delegating constructors in C++11</a></li>
<li><a href="/member-initializers/">Non-Static Data Member Initializers</a></li>
</ul>


<h3>References</h3>

<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2540.htm">N2540 &ndash; Inheriting Constructors (revision 5)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Default Template Arguments For Functions]]></title>
    <link href="http://741MHz.com/default-function-template-arguments/"/>
    <updated>2013-11-14T20:35:00-05:00</updated>
    <id>http://741MHz.com/default-function-template-arguments</id>
    <content type="html"><![CDATA[<p>One of the features that C++ provides to its users is the ability to write code in an object-oriented manner. The first object-oriented system was created in 1960 by <a href="http://en.wikipedia.org/wiki/Ivan_Sutherland">Ivan Sutherland</a>. 32 years later, when C++ first appeared back in 1983, object-oriented paradigm was so popular that everything that was not a class or a method was treated as a defective entity.</p>

<p>The beauty of C++ compared to many other languages like Java, where there can be no freestanding methods or global variables, is the fact that C++ neither tries to limit its users in terms of ideas they can have, nor does it force any specific ideas or ideals upon its users. It always allowed programmers to make their creations follow object-oriented, procedural, data-oriented designs, or have no design whatsoever.</p>

<p>In practice, however, there will always be limits. But C++ honestly tries not to stand in a way and help us, the programmers, to code anything that we could possibly have in our heads. And C++11 have proved this one more time with a lot of changes over the previous revision effectively improving the language to allow us to achieve more with less labor, focus on our current ideas rather than overcoming limitations of our tools and programming language, and come up with even more ideas, because ideas are most important.</p>

<blockquote><p>It is not labor, not capital, not land, that has created modern wealth or is creating it today. It is <em>ideas</em> that create wealth, and what is wanted is more ideas&hellip;</p>

<p>โ <a href="http://en.wikipedia.org/wiki/Emerson_Harrington">Harrington Emerson</a></p></blockquote>

<p>Back in a day, freestanding functions, as well as freestanding function templates, did not get a lot of attention because people fell for the hype of object-oriented design. As a consequence, it was never possible to have seemingly simple and intuitive things such as a default template argument for a function template. It was allowed for classes, but not for functions. To give an example, the following would work:</p>

<p>```c++
template <typename X, typename Y = int>
struct A {</p>

<pre><code>static void func(X x, Y y) {
    // ...
}
</code></pre>

<p>};
```</p>

<p>But the function template like this would not compile:</p>

<p><code>c++
template &lt;typename X, typename Y = int&gt;
void func(X x, Y y) {
}
</code></p>

<p>Seems a little bit odd. Bjarne Stroustrup answered why this was happening in April 2000 when <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#226">he wrote</a>:</p>

<blockquote><p>The prohibition of default template arguments for function templates is a misbegotten remnant of the time where freestanding functions were treated as second-class citizens and required all template arguments to be deduced from the function arguments rather than specified.</p>

<p>The restriction seriously cramps programming style by unnecessarily making freestanding functions different from member functions, thus making it harder to write STL-style code.</p>

<p>โ <a href="http://www.stroustrup.com">Bjarne Stroustrup</a></p></blockquote>

<p>Luckily, this was written along with a proposal on how to fix it, and after a couple of meetings with the core language working group, all of the small details were thought through and the final resolution was proposed in October 2002. It consisted of seven changes to different sections and paragraphs to the C++ standard.</p>

<p>If you are interested in details, you can check them out at <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#226">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#226</a>.</p>

<p>What&rsquo;s important is that today we need to waste our time no more working around this limitation as all of the production quality C++ compilers and tools support default template arguments for function templates, and we we can write our code like this:</p>

<p><code>c++
template &lt;class T, class U = double&gt;
void f(T t = 0, U u = 0);
</code></p>

<p>Long live C++!</p>
]]></content>
  </entry>
  
</feed>
