<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tech | Ranting @ 741 MHz]]></title>
  <link href="http://741MHz.com/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://741MHz.com/"/>
  <updated>2013-12-01T21:38:07-05:00</updated>
  <id>http://741MHz.com/</id>
  <author>
    <name><![CDATA[741MHz.com]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Evolution of Computer Networking]]></title>
    <link href="http://741MHz.com/network-evolution/"/>
    <updated>2013-03-30T00:00:00-04:00</updated>
    <id>http://741MHz.com/network-evolution</id>
    <content type="html"><![CDATA[<p>Do you remember 56k modems? Me too. The sound it used to produce when connecting still gives me a warm fuzzy feeling and a bit of excitement. The last time I have used that modem was in 2003. Fifty six thousand bits per seconds — that was a lot back then. For the sake of comparison, I went to speedtest.net to check the speed of my phone that uses 4G LTE from Verizon, and my Verizon Fios home network. Here are my results:</p>

<p><img src="/images/network-evolution/home_speed_test.jpg"></p>

<p>The phone’s Internet connection is roughly 263 faster; the home network is 821 times faster. This is just mind-blowing. But that is a simple home networking — a standard phone and a standard gigabit Ethernet adapter. The industrial networking is a lot more complicated, a lot faster, and is far ahead of technologies commonly used in our homes. In order to achieve lower latency characteristics and better bandwidth, the industry took a few large steps to get where we are now. Let’s take a quick look at what is going on there!</p>

<h2>Direct Memory Access</h2>

<p>One of the first steps was an introduction of <a href="http://en.wikipedia.org/wiki/Direct_memory_access">Direct Memory Access</a>, or <em>DMA</em>. Basically, it allowed peripheral devices to access computer’s memory without having CPU being involved in this process. I was trying to find some information about the history of DMA and found <a href="http://www.ganssle.com/articles/adma.htm">this interesting article</a> dated back to 1994. At that time, DMA was gaining popularity in embedded systems. Today, it can be found in any computer, and is used in all systems and not only embedded.</p>

<h2>Network Interface Controllers</h2>

<p>Before, computers used to access the network by communicating with the <a href="http://en.wikipedia.org/wiki/PHY_(chip">Ethernet PHY</a>) directly. Its only task is to send and receive data over a physical medium, such as famous <a href="http://en.wikipedia.org/wiki/Registered_jack">RJ-45 cable</a>.</p>

<p><img src="/images/network-evolution/phy_and_cat6.jpg"></p>

<p>The problem was in having CPU perform a lot of simple yet time-consuming operations in order to communicate over the network using just a PHY device. With the ever growing demand for better performance, engineers came up with special hardware called <a href="http://en.wikipedia.org/wiki/Network_interface_controller">Network Interface Controller</a> (NIC). Initially, it was handling tasks related to the <a href="http://en.wikipedia.org/wiki/Data_link_layer">Data Link Layer</a>, such as <a href="http://en.wikipedia.org/wiki/Media_access_control">Media Access Control</a>. This made it possible to perform many tasks on the card and not waste CPU resources. For example, NIC could filter data that was not intended for this computer (based on MAC address or IP address, for example).</p>

<h2>PCI Express 3.0</h2>

<p>The first NICs used to communicate with PC over <a href="http://en.wikipedia.org/wiki/Industry_Standard_Architecture">ISA bus</a>. ISA was later replaced with PCI and then <a href="http://en.wikipedia.org/wiki/PCI_Express#PCI_Express_3.0">PCI Express</a> (aka PCIe). The PCIe has evolved significantly since its first release. The currently used version 3 of the PCIe can handle up to 8 gigatransfers per second and provides a tremendous advantage not only to Network Interface Controllers, but general purpose computing with technologies like <a href="http://en.wikipedia.org/wiki/CUDA">CUDA</a>, <a href="http://en.wikipedia.org/wiki/OpenCL">OpenCL</a>, <a href="http://en.wikipedia.org/wiki/C%2B%2B_AMP">C++ AMP</a> etc. The version 4 of the PCIe standard is already on its way.</p>

<p><img src="/images/network-evolution/nic_in_90s.jpg"></p>

<h2>Optical Fiber, 100 Gigabit Ethernet and Special Hardware</h2>

<p>The old good copper cables got replaced with <a href="http://en.wikipedia.org/wiki/Optical_fiber">optical fiber</a> which are effectively transferring data with a speed of light. The speed at which network cards can transfer data has also increased. It jumped from 10 to 100 Mbps, then from 100 Mbps to 1 Gigabit per second – a common speed our PCs are operating at home these days. <a href="https://en.wikipedia.org/wiki/10-gigabit_Ethernet">10 Gigabit Ethernet</a> started to evolve around 2002 and over six million ports were shipped by 2010. This is the most common Ethernet speed currently used by the industry. In 2010, there were two new Ethernet standards supporting <a href="https://en.wikipedia.org/wiki/100_Gigabit_Ethernet">40 and 100 Gigabit per second</a> line rates. This technology is already being used today, powering our “Clouds” and having people ranting about “Big Data”.</p>

<p>One interesting thing about these new and crazy bandwidth capabilities is that computers cannot really handle it, so you cannot just plug a 100 GbE controller into your PCIe slot and download the whole Internet. Not at all. Simply because no general-purpose CPU can handle that amount of data, at least not yet. So far these loads can only be handled by special hardware – Ethernet ICs which are commonly implemented as <a href="http://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASICs</a>, but there are also <a href="http://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> based solutions. One of the great examples of such devices are network switches. For example, Arista makes a few switches capable of handling 1.28 terabytes per second.</p>

<p>If you are a big electronics enthusiast and know how to program FPGAs, then you can make your own 100 GbE device at home. There are plenty of kits available on the market already. For example, the following Altera board looks very interesting:</p>

<p><img src="/images/network-evolution/100g_dk_stratix_v_gx.jpg"></p>

<p>Though I can think of better ways to spend $25,000. But that’s just me. Let’s get back to the software and general-purpose CPUs. Engineers from all around the world have been trying to solve a problem of having a software that can handle large amount of traffic with lowest possible latency, and there is indeed some progress.</p>

<h2>Software, Berkeley Sockets and C10K</h2>

<p><img class="right" src="/images/network-evolution/code_monkey_by_gloriouskyle.jpg"></p>

<p>The software hasn’t really changed much in the last two decades, unfortunately. Developers are still using a classic <a href="http://en.wikipedia.org/wiki/Berkeley_sockets">Berkeley Socket API</a> for network programming, as they used two decades ago. This has been a big problem because sticking to the same old programming model does not allow for a lot of great optimizations.</p>

<p>In early 2000s, Alexey Kuznetsov, Jamal Hadi Salim and Robert Olsson have developed a new technique for network packet processing called «<a href="http://en.wikipedia.org/wiki/New_API">New API</a>». It was not affecting the socket API used by the application developers. Instead, it was a modification to the device driver packet processing framework that was designed to improve the performance of high-speed networking.</p>

<p>There were also a few improvements for which programmers should be grateful and thank to NIC designers. Modern NICs provide something called «offloading» where some tasks that were done by software are now handled by the NICs. This at least includes a <a href="http://en.wikipedia.org/wiki/Large_segment_offload">Large Segment Offload</a>, <a href="http://en.wikipedia.org/wiki/Large_receive_offload">Large Receive Offload</a>, and TCP/IP, UDP and Ethernet checksum calculation. These “tricks” are very common these days and won’t surprise anyone.</p>

<p>The above improvements helped a lot but it soon turned out to be not enough. In 2003, Dan Kegel described <a href="http://www.kegel.com/c10k.html">the C10K problem</a>. It highlights that hardware is no longer a bottleneck – the software is, or at least the way it is written. And that affects everything and not only the Web. Here is a real world example from a financial industry. I remember when I first joined the company I am currently with, we had an application designed to process <a href="http://opradata.com/">OPRA data</a> – an information aggregated from participating <a href="http://en.wikipedia.org/wiki/Option_(finance">option</a>) exchanges (currently 11). The data was distributed over some 30+ multicast channels at that time, and the application was creating a <a href="http://en.wikipedia.org/wiki/Thread_(computing">thread</a>) per UDP socket/channel to handle all of that data. That was truly embarrassing, and as the amount of data increased over time, the application would just lose half of the data or even crash. Luckily, we quickly threw that crappy app away and wrote a new one that handles everything with ease even during the peak loads.</p>

<p>I was laughing out loud when a few days ago, <a href="http://www.ft.com/intl/cms/s/0/5771ec7a-90ce-11e2-862b-00144feabdc0.html">according to Mr. O’Malia</a>, the government reportedly had similar problems after deciding to regulate a swap market. After market participants started to report their activity, the government simply failed to handle the amount of data:</p>

<blockquote><p>The commission now receives data on thousands of swaps each day. So far, however, none of our computer programs loads this data without crashing.</p></blockquote>

<p>As a result of a higher awareness of this problem among <a href="https://www.youtube.com/watch?v=v4Wy7gRGgeA">code monkeys</a>, an asynchronous network I/O approach quickly gained popularity and more applications started to use it. Generally speaking, a well written application using asynchronous approach can handle a reasonable amount of traffic on a powerful multi-core server – at least enough for most of generic applications like web servers, bit torrents etc. Yet handling a constant load of anything close to 10 GbE is still beyond the imaginable. And even if CPUs could handle that, that would leave no resources to actually do something meaningful with that data. This slowly but surely becomes a problem. Luckily, there are a number of solutions aiming at solving this problem by taking the whole new approach to computer networking.</p>

<h2>What’s Trending</h2>

<p>A lot of work towards a better networking has been emerging since 2005 with a number of companies already providing industrial grade solutions today. There is not yet an official name for it, no standard, and no solutions are exactly the same. Yet they all share the same philosophy and similar implementations. There are few main points shared by all of them:</p>

<ul>
<li>Operating system kernel is a bottleneck and its use must be avoided.</li>
<li>Applications must access the NIC directly and perform DMA transactions.</li>
<li>As much work as possible must be done by the NIC hardware.</li>
</ul>


<p><img class="right" src="/images/network-evolution/modern_nic.png" title="&lsquo;Modern NIC with full kernel-bypass, offload and zero-copy support as well as on-board FPGA for custom hardware logic.&rsquo;" >
There are three buzz words for the above points – Kernel-Bypass, Zero-Copy and Offload respectively. Here are just a few popular solution provides that implement all of the above and provide extremely high-performance networking solutions (in no particular order):</p>

<ul>
<li><a href="http://www.6wind.com/">6WIND</a></li>
<li><a href="http://www.plda.com/index.php">PLDA</a></li>
<li><a href="http://www.napatech.com/">Napatech</a></li>
<li><a href="http://www.mellanox.com/">Mellanox</a></li>
<li><a href="http://www.myricom.com/">Myricom</a></li>
<li><a href="http://www.solarflare.com/">SolarFlare</a></li>
<li><a href="http://www.velocytech.com/">VelociTech</a></li>
<li><a href="http://www.intilop.com/">Intilop</a></li>
<li><a href="http://www.ntop.org/products/pf_ring/dna/">NTOP.ORG DNA</a></li>
</ul>


<p>Some of the technologies provided by the above companies can speed up network processing anywhere from 20 to 100 times. In order to achieve the best performance, however, a different programming model (as well as API) must be used. It is simply impossible to have a Berkeley Socket API anymore — it is way too old and does not account for many things, making it impossible to write the efficient (from hardware point of view) program.</p>

<h2>What To Expect Next</h2>

<p>Given the current trends, it would be logical to expect a few things to happen.</p>

<h3>Standard API</h3>

<p>The first thing is a consolidation of APIs. Having 10+ different ways to do the same thing just does not sound good. Sooner or later we should get a standard API that would provide developers with a stable, thought-through and efficient way to program network applications using these cutting edge technologies. This would probably be something like <a href="http://en.wikipedia.org/wiki/OpenCL">OpenCL</a> but for networking.</p>

<h3>Lower Cost</h3>

<p>To get one of those programmable network adapters of the new era today, one should pay through the nose. The price can vary anywhere from $5000 to $50000, depending on the functionality provided. We should (hopefully) see the price go down as technology gets stabilized and the sales increase in quantities. After all, creating such a device is no harder than an iPhone. Yet we don’t pay 50K for an iPhone, right?</p>

<h3>Integration</h3>

<p>Recently, the Xilinx has released the <a href="http://www.xilinx.com/publications/prod_mktg/quickpath-interconnect-ip-product-brief.pdf">worlds first FPGA running QPI</a> at full width — 21 lanes at 6.4 GHz per lane. So we can now have a motherboard that has a cutting edge Intel CPU for general-purpose processing in one socket, and a special purpose FPGA in another socket, both sharing the host memory at maximum speed and the lowest possible latency. In other words, Intel CPU will communicate with FPGA just like it communicates with other CPUs on the same board. This will indeed help to get rid of PCI Express that has always been a bottleneck when it comes to both throughput and latency. Amazing, isn’t it? Below is the video from Xilinx explaining this in more details:</p>

<p><div class="embed-video-container"><iframe src="http://www.youtube.com/embed/NHkpMlL0bZ8 "></iframe></div></p>

<p>At the same time Altera, another leading FPGA vendor, has released <a href="http://www.altera.com/corporate/news_room/releases/2012/products/nr-optical-fpga-demo.html">the worlds first optical FPGA technology</a> that was developed in conjunction with Avago Technologies, breaking through the barriers of traditional copper interconnect. To put it simple, we can now plug the optical fiber directly into the FPGA’s transceiver and achieve a bandwidth of approximately 120 gigabits per second:</p>

<p><div class="embed-video-container"><iframe src="http://www.youtube.com/embed/cC5g3rE9DZ8 "></iframe></div></p>

<p>Now, here is what I think is going to happen. In the next few years we would have an FPGA chip sitting in a CPU socket right next to the high-end Intel CPU, interconnected by QPI with the highest possible bandwidth, and lowest possible latency. The FPGA would have an optical fiber cable attached to it and beaming the data straight into the fabrics. The FPGA would then handle all of the network processing, including high-level protocols such as TCP/IP or even higher ones like <a href="https://bitcoin.it/wiki/Protocol_specification">BitCoin</a>, <a href="http://fixprotocol.org/">FIX</a>, etc.</p>

<p>Once that is done, we could take all of that and integrate it with a human’s brain :)</p>

<p>Hope it was interesting. Thanks for reading!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OOP with ANSI C]]></title>
    <link href="http://741MHz.com/c-oop/"/>
    <updated>2013-03-20T00:00:00-04:00</updated>
    <id>http://741MHz.com/c-oop</id>
    <content type="html"><![CDATA[<p>What if I told you that Linux kernel is object-oriented? Would that surprise you? Or maybe you would think I am a lunatic, and I would understand that. After all, the Linux kernel is mostly written in C, with only a few sections written in Assembly. And everybody knows that C is not an object-oriented language. It is <a href="http://en.wikipedia.org/wiki/List_of_object-oriented_programming_languages">not even listed as such</a> on Wikipedia.</p>

<p>But crazy sometimes is not as crazy as it seems. Did you know that <a href="http://www.youtube.com/watch?v=P8DrxzkwnmA">respected professors who taught Einstein thought he was a goof-off</a>? At a time, if you told those respected scientists that Einstein is in fact a genius who would change the history, they definitely take you for a lunatic. Who would have though, right?</p>

<p>And who would have thought that C can be a used for object-oriented programming? <a href="http://www.cs.rit.edu/~ats/">Axel-Tobias Schreiner</a> did. He even went a step further and wrote a book called «Object-Oriented Programming with ANSI C». It starts like this:</p>

<blockquote><p>Object-oriented programming is the current cure-all — although it has been around for much more then ten years. At the core, there is little more to it then finally applying the good programming principles that we have been taught for more than twenty years. C++ (Eiffel, Oberon-2, Smalltalk … take your pick) is the New Language because it is object-oriented — although you need not use it that way if you do not want to (or know how to), and it turns out that you can do just as well with plain ANSI-C.</p></blockquote>

<p>This is one of the most wonderful books about programming in general, object-oriented approach, C and C++ programming languages that I have ever read. In my opinion, it hasn’t got the attention it deserves. I read it twice — the first time when I was just learning C and the second time when I was mastering C++. If you have been learning C and/or C++ — this is a must read.</p>

<p>Practically, C is a very low-level language and nobody would want to spend hours writing lots of glue code in C to implement a virtual method table — something that C++ compiler does for you automatically, unless it is required. But even if taking up on that challenge is not part of the plan, the Alex’s book is still great — it teaches the fundamental core principles that all object-oriented languages are built upon. C and C++ are there almost for the sake of examples only. Delegate? Explained. Multiple inheritance? Check. Selectors? There. After reading the book, one could basically just look at any language construct, be that C#, Java, Ruby, Python or any other language, and say, — “Yeah, I know what that does and how compiler implements it. That’s easy!”</p>

<p>As it turns out, not only you can do all of that with ANSI C, it is actually the best language to explain what is going on under the hood of other languages. And if you ever look at Linux kernel, you would see that it is one of the greatest examples object-oriented design.</p>

<p>The book <a href="http://www.lulu.com/shop/axel-schreiner/object-oriented-programming-with-ansi-c/paperback/product-17561597.html">can be purchased for $20 from Lulu</a> and it is worth every penny. You can also <a href="http://www.cs.rit.edu/~ats/books/ooc.pdf">download a free PDF version</a> from Mr. Schreiner’s website.</p>

<p>Axel-Tobias Schreiner, Thank You!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Calculating FIX Message Checksum]]></title>
    <link href="http://741MHz.com/fix-checksum/"/>
    <updated>2013-03-16T00:00:00-04:00</updated>
    <id>http://741MHz.com/fix-checksum</id>
    <content type="html"><![CDATA[<p>A FIX message is a stream of bytes that consists of data represented by <a href="http://en.wikipedia.org/wiki/Attribute%E2%80%93value_pair">field-value (aka key-value) pairs</a>. Those field-value pairs are delimited by <a href="http://en.wikipedia.org/wiki/Start-of-Header#SOH">SOH character</a> — a special non-printable ASCII character with hex code <code>0x01</code>. For convenience, it is usually replaced with a vertical bar (<code>|</code>) for displaying purposes. Each field-value pair consists of the field number and its value delimited by equals sign (<code>=</code>). In the code, it is represented as an escape sequence — <code>'\1'</code> or <code>"\001"</code>. Here is an example of a FIX message:</p>

<p><code>
8=FIX.4.2|9=178|35=8|49=PHLX|56=PERS|52=20071123-05:30:00.000|11=ATOMNOCCC9990900|20=3|150=E|39=E|55=MSFT|167=CS|54=1|38=15|40=2|44=15|58=PHLX EQUITY TESTING|59=0|47=C|32=0|31=0|151=15|14=0|6=0|10=128|
</code></p>

<p>Every FIX message must always end with a checksum field followed by SOH symbol. The field number for a checksum is 10. Therefore, the checksum part in the above message is <code>10=128|</code>.</p>

<p>There is one special requirement for the checksum field — it must always be three characters long. Not more and not less. It must be left-padded with <code>0</code> characters if needed. For example, if the checksum value is <code>13</code>, then it should appear as <code>013</code>. If it is only <code>1</code>, then it should read <code>001</code>. It can also be just <code>000</code>.</p>

<p>The checksum of a FIX message is calculated by adding every byte of the message, excluding the checksum field-value pair, as unsigned binary number, discarding any overflow bits. Therefore, the range of possible values is [0-255], the same range of values that can be represented by unsigned 8-bit integer (<code>uint8_t</code>).</p>

<p>The code for calculating FIX checksum is very simple — all it needs to do is add every byte of the input and store a result in <code>uint8_t</code>. Remember, the checksum field itself should not be used to calculate checksum. Here is an example in C:</p>

<p>```c++
uint8_t fix_checksum(const char *data, size_t size)
{</p>

<pre><code>uint8_t sum = 0;
size_t i = 0;
while (i &lt; size)
    sum = (uint8_t)(sum + (uint8_t)data[i++]);
return sum;
</code></pre>

<p>}
```</p>

<p>If writing in C++, <a href="http://en.cppreference.com/w/cpp/algorithm/accumulate"><code>std::accumulate()</code></a> can be used to achieve the same. Here is an example:</p>

<p>Once the checksum value is calculated, it must be added to the end of the message as an ASCII-encoded field-value pair with field number <code>10</code>, followed by SOH. As a remainder, the checksum value must always be three characters long, left padded with <code>0</code> if needed. The easiest way to convert the binary checksum value is this:</p>

<p>```c++
char data[3];</p>

<p>data[0] = (char)(checksum / 100 + &lsquo;0&rsquo;);
data[1] = (char)(checksum / 10 % 10 + &lsquo;0&rsquo;);
data[2] = (char)(checksum % 10 + &lsquo;0&rsquo;);
```</p>

<p>To sum things up, here is a C++ example program that calculates the checksum and appends it to the end, forming a complete FIX message:</p>

<p>```c++
// &mdash;<em>&mdash; C++11 &mdash;</em>&mdash;
// Compile: clang++ -std=c++11 -stdlib=libc++ -Wall ./test.cpp</p>

<h1>include <cstdint></h1>

<h1>include <string></h1>

<h1>include <numeric></h1>

<h1>include <iostream></h1>

<p>int main()
{</p>

<pre><code>// Initial message. The SOH is an escape sequence '\001'.
// It does not include checksum field — the checksum must
// be calculated.
std::string msg =
    "8=FIX.4.2\0019=178\00135=8\00149=PHLX\00156=PERS\001"
    "52=20071123-05:30:00.000\00111=ATOMNOCCC9990900\001"
    "20=3\001150=E\00139=E\00155=MSFT\001167=CS\00154=1\00138=15"
    "\00140=2\00144=15\00158=PHLX EQUITY TESTING\00159=0\001"
    "47=C\00132=0\00131=0\001151=15\00114=0\0016=0\001";

// Calculate the checksum.
std::uint8_t csum =
    std::accumulate(msg.begin(), msg.end(),
                    static_cast&lt;std::uint8_t&gt;(0));

// Append the checksum field-value to the message.
// First, add field number and field delimiter:
msg.append("10=");

// Then add checksum converted to ASCII characters,
// left-padded with zeroes:
msg.append(1, csum / 100 + '0');
msg.append(1, csum / 10 % 10 + '0');
msg.append(1, csum % 10 + '0');

// And finally, complete the message by adding a final
// SOH character:
msg.append(1, '\1');

// Print the message to standard output.
std::cout &lt;&lt; msg &lt;&lt; std::endl;
</code></pre>

<p>}
```</p>

<p>Note that some terminals may not be able to display SOH characters. It is possible that it would get displayed as <code>^A</code>, some other sequence, or not displayed at all. In OS X «Terminal», the above program would display the following:</p>

<p><code>
$ clang++ -std=c++11 -stdlib=libc++ -Wall -pedantic ./test.cpp
$ ./a.out
8=FIX.4.29=17835=849=PHLX56=PERS52=20071123-05:30:00.00011=ATOMNOCCC999090020=3150=E39=E55=MSFT167=CS54=138=1540=244=1558=PHLX EQUITY TESTING59=047=C32=031=0151=1514=06=010=128
</code></p>

<p>So when printing a FIX message, it might be useful to replace all occurrences of <code>01</code> with something else, for example a vertical bar. It is also possible to do it with command line utility called <code>tr</code>. This does not require a code change:</p>

<p><code>
$ ./a.out | tr '\1' '|'
8=FIX.4.2|9=178|35=8|49=PHLX|56=PERS|52=20071123-05:30:00.000|11=ATOMNOCCC9990900|20=3|150=E|39=E|55=MSFT|167=CS|54=1|38=15|40=2|44=15|58=PHLX EQUITY TESTING|59=0|47=C|32=0|31=0|151=15|14=0|6=0|10=128|
</code></p>

<p>That is pretty much all you need to know to successfully calculate a FIX checksum. There is also one little detail that might come handy — checksums are meant to help verify data integrity and make sure that no part of the message got corrupted during transmission from one application to another. These days, FIX messages are transmitted using TCP/IP or UDP. Both TCP/IP and UDP protocols guarantee data integrity out of the box and therefore a FIX checksum doesn’t make a lot of sense. Given that calculating FIX checksums requires a lot of CPU resources and is even likely to be the bottleneck, make sure that exchange or broker, with which you intend to communicate using FIX Protocol, require a checksum. There are a number of technically wise brokers and exchanges out there that do not require you to provide the correct checksum. If that is the case, simply put <code>10=000|</code> at the end of every message.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Use free and delete correctly.]]></title>
    <link href="http://741MHz.com/free-delete/"/>
    <updated>2013-03-13T00:00:00-04:00</updated>
    <id>http://741MHz.com/free-delete</id>
    <content type="html"><![CDATA[<p>The Internet is full of programming jokes <a href="http://bash.org/?946461">like this one</a>:</p>

<blockquote><p>&lt;@joosa> how do you say float in java? just 1.5f?<br/>
&lt;@Gliptic> FloatFactoryFactory.getInstance (FloatFactoryFactory.defaultInstanceDescriptionString).getFactory (Locale.getLocale (“en-US”)).createBuilder ().setString (“1.5″).getResult ()</p></blockquote>

<p>Java people please read on, that’s only a joke! More often than not the jokes are directed at those using higher-level programming languages. This is a little unfair because C programmers (and C++ ones for that matter) write some funny code, too. For example:</p>

<p>```c
void foo(void *ptr) {</p>

<pre><code>if (ptr)
    free(ptr);
</code></pre>

<p>}
```</p>

<p>This perhaps could be a joke or maybe even an interview question. What’s wrong with the above C code (assuming everything else including the usage is correct)? It turns out that many can’t spot anything. If you do — congratulations! For those who don’t, let’s read the <a href="http://man7.org/linux/man-pages/man3/free.3.html">documentation of <code>free()</code> function</a>:</p>

<blockquote><p>The free() function frees the memory space pointed to by ptr, which must have been returned by a previous call to malloc(), calloc() or realloc(). Otherwise, or if free(ptr) has already been called before, undefined behavior occurs. If ptr is NULL, no operation is performed.</p></blockquote>

<p>In other words, there is no need to check if pointer is not NULL. The same applies to C++ programmers who often check for <strike><code>NULL</code></strike> <code>nullptr</code> before calling <code>delete</code>. If you don’t trust manual pages, check out §7.20.3/2 of the C standard that states the following:</p>

<blockquote><p>The free function causes the space pointed to by ptr to be deallocated, that is, made available for further allocation. If ptr is a null pointer, no action occurs. Otherwise, if the argument does not match a pointer earlier returned by the calloc, malloc, or realloc function, or if the space has been deallocated by a call to free or realloc, the behavior is undefined.</p></blockquote>

<p>For C++, see §5.3.5/2:</p>

<blockquote><p>… if the value of the operand of delete is the null pointer the operation has no effect.</p></blockquote>

<p>Possibly, an extra checking for NULL was a necessity some 20 years ago, according to some Internet rumors claiming that a few implementations of the standard C library had a bug back then and free() could crash the program when passed a NULL pointer. I couldn’t find any information about what it was. But no matter what was going on two decades ago — it is pretty hard to find pre-ANSI C code these days. Yet unnecessary NULL checking can be seen a lot. For example, <a href="http://krugle.org/">krugle.org</a> shows the following three projects right away:</p>

<ul>
<li><a href="http://opensearch.krugle.org/document/view_filecontent/apache_http_server1945779753/scmi_filer2-scmi.ofc.krugle.net_8799/scmi_305/tags/1.3/djg_nspr_split/src/regex/regfree.c">Apache Web Server</a></li>
<li><a href="http://opensearch.krugle.org/document/view_filecontent/apache_hadoop618243895/scmi_filer2-scmi.ofc.krugle.net_8799/scmi_528/trunk/hadoop-common-project/hadoop-common/src/main/native/src/org/apache/hadoop/security/getGroup.c">Apache Hadoop</a></li>
<li><a href="http://opensearch.krugle.org/document/view_filecontent/miranda1067994304/scmi_filer2-scmi.ofc.krugle.net_8799/scmi_705/miranda/protocols/Gadu-Gadu/ownerinfo.c">Miranda</a> (an ICQ client popular in ex-USSR countries)</li>
</ul>


<p>I thought that maybe people are worrying about performance too much and don’t want to do an extra function call (extra cycles, procedure linkage tables, etc). But then using <code>malloc()</code> and <code>free()</code> in performance critical path would have been even more silly.</p>

<p>So is it paranoia, a failure to read documentation, or maybe a thoughtless copy-paste that went too far?</p>

<p>Who knows.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux, HID and PyUSB]]></title>
    <link href="http://741MHz.com/pyusb/"/>
    <updated>2013-03-04T00:00:00-05:00</updated>
    <id>http://741MHz.com/pyusb</id>
    <content type="html"><![CDATA[<p>Today I was going through some stuff in my desk’s locker and ran into this nice toy — a big red electronic panic button. It has been there for years but I never had a chance to use it because a company making those does not have a driver for OS X, and of course I couldn’t find one for Linux either. But pushing a big red button is always fun and this time I have decided to try and make it work. So I brought it home with me into my “lab” to see what I can do.</p>

<p>After plugging it into a USB port, it immediately showed up in a list of USB devices (which you can see with lsusb tool). My Linux box has identified it as a Dream Cheeky Stress/Panic Button:</p>

<pre><code>Bus 007 Device 010: ID 04f3:04a0 Elan Microelectronics Corp. Dream Cheeky Stress/Panic Button
</code></pre>

<p>Meanwhile, the kernel has also logged a message saying that it has found a new USB device. So the magic button seemed somewhat operational and I already knew two important things about it — a vendor and a product IDs. They were <code>0x04f3</code> and <code>0x04a0</code> respectively.</p>

<h2>Writing a USB driver</h2>

<p>The only little detail missing was actually a driver. I tried to <a href="https://duckduckgo.com/">Duck Duck Go</a> it real quick but nothing showed up, and I decided to write it myself. How hard can it be, after all?</p>

<h2>Reverse Engineering</h2>

<p>In order to write a device driver, one must know what the device is doing. Obviously, I didn’t have any specification, neither I wanted to deal with Elan Microelectronics support department. So the only way to figure it out was reverse engineering. Luckily, Linux has <a href="https://www.kernel.org/doc/Documentation/usb/usbmon.txt"><em>usbmon</em></a> — a facility in the kernel that is used to collect traces of I/O on the USB bus. After a quick pick at its documentation, I loaded the module using <code>modprobe usbmon</code> command and the device showed up in <code>/sys/kernel/debug/usb/devices</code>. Since it was attached to bus #7, I traced the I/O by reading the <code>/sys/kernel/debug/usb/usbmon/7u</code> file and pushing my panic button a few times to see if anything shows up. And every time I hit the button, the device was sending the following data to the host:</p>

<p><code>
ffff8801b2efc9c0 1873321198 C Ii:7:010:1 0:8 8 = 02000000 00000000
ffff8801b2efc9c0 1873457204 C Ii:7:010:1 0:8 8 = 06000000 00000000
ffff8801b2efc9c0 1873633203 C Ii:7:010:1 0:8 8 = 06001300 00000000
ffff8801b2efc9c0 1873801206 C Ii:7:010:1 0:8 8 = 06000000 00000000
ffff8801b2efc9c0 1873977211 C Ii:7:010:1 0:8 8 = 02000000 00000000
</code></p>

<p>Not only this proved that button itself works, it also uncovered a pattern — the device was sending <code>02000000</code> and <code>06000000</code> twice with <code>06001300</code> in between. So <code>06001300</code> seemed like a good indication of the button being pressed.</p>

<h2>Linux Kernel USB Driver</h2>

<p>The next step was to write a USB Device Driver for Linux. I dealt with PCI Express, DMA and Ethernet network drivers, but never wrote a single USB driver before. So I pulled my copy of the Linux Device Drivers book off the shelf and opened it on Chapter 13 “USB Drivers”. I have to say I got surprised — that rant is about 100 pages long. I would of course suck it up, enjoy the reading and proceed to hacking. If only it was something serious. And what I had was a simple USB button that did nothing but sending two 32-bit integers, 0x06 and 0x13, every time it gets hit. Going through the hundred pages just to read 64-bit of data off the USB cable, on Monday night, after a hard 10 hours working day… Ain’t nobody got time for that?</p>

<h2>PyUSB</h2>

<p>A bit disappointed, I tried to find an easier way and once against ducked for a few keywords like “USB”, “driver”, “read”, “HID” and so on…</p>

<blockquote><p>Ask and it will be given to you; seek and you will find; knock and the door will be opened to you.
— Matthew 7:7</p></blockquote>

<p>Turned out, it is possible to write a USB driver in just a few lines of Python. Sir <a href="http://www.micahcarrick.com/">Micah Carrick</a> have managed to make a driver for his credit card reader and wrote about his experience in <a href="http://www.micahcarrick.com/credit-card-reader-pyusb.html">this nice article</a>. Following in his footsteps, I quickly glanced at <a href="http://sourceforge.net/apps/trac/pyusb/">PyUSB</a> that he was using in his work, read a few other examples, and came up with a driver for my magic button. This is truly the shortest and simplest device driver that I have made in my life:</p>

<p>```python</p>

<h1>!/usr/bin/env python</h1>

<p>import sys, usb.core</p>

<p>dev = usb.core.find(idVendor=0x04f3, idProduct=0x04a0)
if dev is None:</p>

<pre><code>sys.exit("No Panic button found in the system");
</code></pre>

<p>try:</p>

<pre><code>if dev.is_kernel_driver_active(0) is True:
    dev.detach_kernel_driver(0)
</code></pre>

<p>except usb.core.USBError as e:</p>

<pre><code>sys.exit("Kernel driver won't give up control over device: %s" % str(e))
</code></pre>

<p>try:</p>

<pre><code>dev.set_configuration()
dev.reset()
</code></pre>

<p>except usb.core.USBError as e:</p>

<pre><code>sys.exit("Cannot set configuration the device: %s" % str(e))
</code></pre>

<p>endpoint = dev[0][(0,0)][0]
while 1:</p>

<pre><code>try:
    data = dev.read(endpoint.bEndpointAddress, endpoint.wMaxPacketSize,
                    timeout=10000)
    if data is not None and len(data) &gt; 2:
        if data[0] == 6 and data[2] == 19:
            # Panic button was pressed!
            print "OH MY GOD! OH MY GOD! DOUBLE RAINBOW!!!"
except usb.core.USBError as e:
    if e.errno != 110: # 110 is a timeout.
        sys.exit("Error readin data: %s" % str(e))
</code></pre>

<p>```</p>

<p>So now I have my beautiful toy working!</p>

<h2>UPDATE</h2>

<p><a href="https://twitter.com/pdp7">Drew Fustini</a> have hooked this up to the BeagleBone Next-Gen and made this video:</p>

<p><div class="embed-video-container"><iframe src="http://www.youtube.com/embed/52b5RGd4yrE "></iframe></div></p>
]]></content>
  </entry>
  
</feed>
