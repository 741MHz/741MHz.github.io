<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tech | Ranting @ 741 MHz]]></title>
  <link href="http://741MHz.com/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://741MHz.com/"/>
  <updated>2013-12-01T19:17:51-05:00</updated>
  <id>http://741MHz.com/</id>
  <author>
    <name><![CDATA[741MHz.com]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++ Exceptions Performance]]></title>
    <link href="http://741MHz.com/exceptions-performance/"/>
    <updated>2011-07-22T00:00:00-04:00</updated>
    <id>http://741MHz.com/exceptions-performance</id>
    <content type="html"><![CDATA[<h3>Introduction</h3>

<p>Exceptions provide a way to react to special conditions that change the normal flow of a program execution. Exception handling in general can refer to programming language construct, computer hardware mechanism, or both.</p>

<p>Many people are concerned with performance impact introduced by using exception mechanism in C++. For example, one of my colleagues believes that using exceptions should be avoided at any cost to improve execution speed of an application. Is that true or not? Let’s find out.</p>

<h3>Using exceptions</h3>

<p>It is important to understand that exception is not a general case of a program execution flow but an unexpected situation. Such situation should normally not arise at all. However, errors happen and we need to check for them. A large chunk of any good program is mostly dedicated to proper error handling. There are two fundamental approaches when dealing with error handling — return codes or exceptions. For example, let’s say we have a custom function that implements division:</p>

<p><code>c++
int divide (int x, int y)
{
  return x / y;
}
</code></p>

<p>We need to make sure that divisor is not zero because you cannot divide by zero (at least not with integer arithmetics). There are two ways of doing this. Let’s start from C-style error checking that will make our function look like this:</p>

<p>```c++
int divide (int x, int y, int &amp; result)
{
  if (y == 0)</p>

<pre><code>return -1;
</code></pre>

<p>  result = x / y;
  return 0;
}
```</p>

<p>C++ error checking using exceptions will look something like this:</p>

<p>```c++
int divide (int x, int y)
{</p>

<pre><code>if (y == 0)
    throw std::logic_error (“Division by zero”);
return x / y;
</code></pre>

<p>}
```</p>

<p>The use cases for these two functions will be different. For C-style function, we will always have to check for return code to make sure that operation succeeded:</p>

<p>```c++
void foo (int x, int y)
{</p>

<pre><code>int result;
if (divide (x, y, result) == 0)
{
    // Division was successful. Do something with “result”.
}
else
{
    // Error occurred!
}
</code></pre>

<p>}
```</p>

<p>The C++ use case:</p>

<p>```c++
void foo (int x, int y)
{</p>

<pre><code>try
{
    int result = divide (x, y);
    // Division was successful. Do something with “result”.
}
catch (const std::logic_error &amp;)
{
    // Error occurred!
}
</code></pre>

<p>}
```</p>

<p>C++ way with exceptions is handy when program flow is somewhat more complicated. What if we need to invoke “divide” function two times? In that case we will have to check for error twice using C-style:</p>

<p>```c++
void foo (int x, int y)
{</p>

<pre><code>int result;
if (divide (x, y, result) == 0)
{
    // Division was successful. Do something with “result”.
}
else
{
    // Error occurred!
}

if (divide (y, x, result) == 0)
{
    // Division was successful. Do something with “result”.
}
else
{
    // Error occurred!
}
</code></pre>

<p>}
```</p>

<p>But in C++, one try-catch block will do:</p>

<p>```c++
void foo (int x, int y)
{</p>

<pre><code>try
{
    int result = divide (x, y);
    // Division was successful. Do something with “result”.
    result = divide (x, y);
    // Division was successful. Do something with “result”, again.
}
catch (const std::logic_error &amp;)
{
    // Error occurred!
}
</code></pre>

<p>}
```</p>

<p>Now, imagine that we have to invoke “divide” function ten or hundred times. And to make it even more complex, imagine that we have multiple nested functions and every function needs to check for an error. Using exception now seems to be the ideal way to go. Well, that is what exceptions were designed for — to make things easier.</p>

<h3>Easy vs Fast</h3>

<p>There are a lot of things that will make our lives as developers easier. But sometimes our programs should be fast. And not only fast but fastest in the world, or even the whole universe. And we have to sacrifice the ease of development to achieve that. This is the case with high-frequency trading programs, for example. So if a programmer writing code for high-frequency trading will think that wrapping invocation of “divide” function with “try-catch” block will slow down his application even by a nanosecond in comparison with C-style error checking, he will choose the hardest way and check for error code every time he invokes “divide” function. Indeed, he will spend much more time to achieve his goals, but will that be a right decision?</p>

<h3>Under the hood</h3>

<p>To answer the question above, we need to dive into the implementation details and figure out how exceptions are implemented. From this point, there is a huge difference between C++ and higher-level languages such as Java, C#, Python and others. In C++, there are two methods for handling exceptions at run-time — “setjmp/longjmp” (hereinafter jumping) method and “zero-cost” exception handling.</p>

<p>Jumping method saves the context when entering a frame with an exception handler. Then when an exception is raised, the context can be restored immediately, without the need for tracking stack frames. This method provides very fast exception propagation, but introduces significant overhead for use of exception handlers, even if no exception is raised.</p>

<p>Zero-cost method generates static tables to describe exception ranges. No dynamic code is required when entering a frame containing an exception handler. When an exception is raised, the tables are used to control a back trace of the subprogram invocation stack to locate the required exception handler. This method has considerably poorer performance for the propagation of exceptions, but there is no overhead for exception handlers if no exception is raised.</p>

<p>There is always upside and downside and we have to make a choice. Taking into account that exceptions are not a part of normal execution flow, we need to optimize the most common case when exceptions are not thrown and sacrifice the speed of handling them. So many production-quality C++ compilers made that choice in favor of zero-cost method.</p>

<h3>Digging into the assembler</h3>

<p>So let’s get back to our “divide” function and compare C-style error checking with zero-cost exception handling. C-style error checking:</p>

<p>```c++
int divide (int x, int y, int &amp; result)
{</p>

<pre><code>if (y == 0)
    return -1;
result = x / y;
return 0;
</code></pre>

<p>}</p>

<p>int foo (int &amp; result)
{</p>

<pre><code>volatile int x = 4, y = 28;
int d1, d2;
if (divide (x, y, d1) == -1)
    return -1;
if (divide (y, x, d2) == -1)
    return -1;
result = d1 + d2;
return 0;
</code></pre>

<p>}</p>

<p>int main ()
{</p>

<pre><code>int result;
foo (result);
return result;
</code></pre>

<p>}
```</p>

<p>Code using exceptions:</p>

<p>```c++
int divide (int x, int y)
{</p>

<pre><code>if (y == 0)
    throw std::logic_error ("Division by zero");
return x / y;
</code></pre>

<p>}</p>

<p>int foo ()
{</p>

<pre><code>volatile int x = 4, y = 28;
return divide (x, y) + divide (y, x);
</code></pre>

<p>}</p>

<p>int main ()
{</p>

<pre><code>try
{
    return foo ();
}
catch (const std::exception &amp;)
{
    return -1;
}
</code></pre>

<p>}
```</p>

<p>Here is what will actually happen for C-style example (I removed code that won’t get executed for simplicity):</p>

<p>```
__Z6divideiiRi:
  pushq   %rbp
  movq    %rsp, %rbp
  movl    %edi, -4(%rbp)
  movl    %esi, -8(%rbp)
  movq    %rdx, -16(%rbp)
  cmpl    $0, -8(%rbp)
  jne L2
;; Skipped return of -1. We will always jump to L2
L2:
  movl    -4(%rbp), %eax
  movl    %eax, %edx
  sarl    $31, %edx
  idivl   -8(%rbp)
  movl    %eax, %edx
  movq    -16(%rbp), %rax
  movl    %edx, (%rax)
  movl    $0, %eax
  popq    %rbp
  ret</p>

<p><strong>Z3fooRi:
  pushq   %rbp
  movq    %rsp, %rbp
  subq    $24, %rsp
  movq    %rdi, -24(%rbp)
  movl    $4, -4(%rbp)
  movl    $28, -8(%rbp)
  movl    -8(%rbp), %ecx
  movl    -4(%rbp), %eax
  leaq    -12(%rbp), %rdx
  movl    %ecx, %esi
  movl    %eax, %edi
  call    </strong>Z6divideiiRi
  cmpl    $-1, %eax
  sete    %al
  testb   %al, %al
  je  L5
;; Skipped return of -1, we will always jump to L5.
L5:
  movl    -4(%rbp), %ecx
  movl    -8(%rbp), %eax
  leaq    -16(%rbp), %rdx
  movl    %ecx, %esi
  movl    %eax, %edi
  call    __Z6divideiiRi
  cmpl    $-1, %eax
  sete    %al
  testb   %al, %al
  je  L7
;; Skipped return of -1, always jumping to L7.
L7:
  movl    -12(%rbp), %edx
  movl    -16(%rbp), %eax
  addl    %eax, %edx
  movq    -24(%rbp), %rax
  movl    %edx, (%rax)
  movl    $0, %eax
  leave
  ret</p>

<p>_main:
  pushq   %rbp
  movq    %rsp, %rbp
  subq    $16, %rsp
  leaq    -4(%rbp), %rax
  movq    %rax, %rdi
  call    __Z3fooRi
  movl    -4(%rbp), %eax
  leave
  ret
```</p>

<p>That’s a lot of error checking code that gets executed assuming it doesn’t happen very often! If we need to call “divide” function more, we will have to add more checking for “-1” return result, and assembly listing will get longer and longer because of that check. Let’s see how the code will look like with exception handling:</p>

<p>```
__Z6divideii:
  pushq   %rbp
  movq    %rsp, %rbp
  pushq   %r12
  pushq   %rbx
  subq    $32, %rsp
  movl    %edi, -36(%rbp)
  movl    %esi, -40(%rbp)
  cmpl    $0, -40(%rbp)
  jne L2
;; Skipped the code that allocates and throws exception. We will always jump to L2.
L2:
  movl    -36(%rbp), %eax
  movl    %eax, %edx
  sarl    $31, %edx
  idivl   -40(%rbp)
  addq    $32, %rsp
  popq    %rbx
  popq    %r12
  popq    %rbp
  ret</p>

<p><strong>Z3foov:
  pushq   %rbp
  movq    %rsp, %rbp
  pushq   %rbx
  subq    $24, %rsp
  movl    $4, -20(%rbp)
  movl    $28, -24(%rbp)
  movl    -24(%rbp), %edx
  movl    -20(%rbp), %eax
  movl    %edx, %esi
  movl    %eax, %edi
  call    </strong>Z6divideii
  movl    %eax, %ebx
  movl    -20(%rbp), %edx
  movl    -24(%rbp), %eax
  movl    %edx, %esi
  movl    %eax, %edi
  call    __Z6divideii
  addl    %ebx, %eax
  addq    $24, %rsp
  popq    %rbx
  popq    %rbp
  ret</p>

<p>_main:
  pushq   %rbp
  movq    %rsp, %rbp
  pushq   %rbx
  subq    $24, %rsp
  call    __Z3foov
  movl    %eax, %ebx
  movl    %ebx, %eax
  addq    $24, %rsp
  popq    %rbx
  popq    %rbp
  ret
;; Stack unwinding code is invoked from statically generated exception
;; table. That code is stripped out, will never be reached in our example.
```</p>

<p>That is much better! We managed to avoid two unnecessary checks of return result. Other than that code that is being executed is exactly the same.</p>

<h3>Jumping exceptions</h3>

<p>Now, let’s say we have a compiler that is using “setjmp/longjmp” approach to implement exceptions. Even with that approach, exception handling could be faster than error checking. Consider the following example:</p>

<p>```c++
while (doContinue) {</p>

<pre><code>try {
    doSomeWork ();
}
catch (...) { /* do something about it! */ }
</code></pre>

<p>}
```</p>

<p>… that will be indeed slower than this:</p>

<p>```c++
while (doContinue) {</p>

<pre><code>if (doSomeWork () != 0) {
    /* do something about it! */
}
</code></pre>

<p>}
```</p>

<p>… but how about this:</p>

<p>```c++
while (doContinue) {</p>

<pre><code>try {
    do {
        doSomeWork ();
    } while (doContinue);
    break;
} catch (...) { /* do something about it! */ }
</code></pre>

<p>}
```</p>

<p>In the example above, we set recovery point once and avoid checking return result of the function multiple times. Of course, that is the best-case scenario assuming that exceptional situation almost never happens. But that is a fair assumption. Otherwise that situation should be treated as normal execution flow and handled differently, without exceptions, which will be the same for both C-style and C++-style programmers. Please note that above optimization makes no sense in case with zero-cost exception mechanism.</p>

<h3>Finding out what exception mechanism is being used</h3>

<p>Unfortunately, the only way to find out what underlying mechanism is used by compiler for exception handling is to write a simple program using exceptions, compile it into assembler language and analyze results.</p>

<h3>Other performance considerations</h3>

<p>Using exceptions will make binary size bigger, no matter what mechanism is used to implement exception handling. So if program size is more important than execution speed, exceptions should not be used. And in those cases where you want to gain maximum execution speed with minimal impact on binary size, you have to do additional testing in order to find the best combination of C-style error checking and exception handling code that achieves your result.</p>

<h3>Summary</h3>

<p>Performance can mean many different things — from the speed of execution or size of the binary to the time developer spends writing code.</p>

<p>In this article we have discussed execution speed of an application using exceptions vs. an application using C-style error checking, and developer’s time needed to write the same program using these two approaches.</p>

<p>If binary size of the compiled program is the most important factor then exceptions should not be used.</p>

<p>If execution speed or ease of development (or both!) is the most important factor then programmer deciding to give up the ease of using exceptions in favor of C-style error checking will not only spend much more time writing the code, make the code more complicated, run into the problem of actually describing the error (especially in multi-threaded environment, and especially when thread local storage cannot be used due to handling of exception in different thread in case of asynchronous programming), but will also make it slower.</p>

<h3>References</h3>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Exception_handling">Exception Handling – Wikipedia</a></li>
<li><a href="http://www.boost.org/community/error_handling.html">Error and Exception Handling by Dave Abrahams</a></li>
<li><a href="http://mentorembedded.github.io/cxx-abi/abi-eh.html">Itanium C++ ABI: Exception Handling</a></li>
<li><a href="http://gcc.gnu.org/onlinedocs/gnat_ugn_unw/Exception-Handling-Control.html">GNAT Exception Handling Control</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unique Lines Without Sorting]]></title>
    <link href="http://741MHz.com/awk-uniq/"/>
    <updated>2010-10-23T00:00:00-04:00</updated>
    <id>http://741MHz.com/awk-uniq</id>
    <content type="html"><![CDATA[<p>Today I ran into a small problem where I had a set of unsorted lines of text and wanted to remove duplicate lines without sorting the data. Both <code>uniq</code> and <code>sort -u</code> commands require data to be sorted, so they won&rsquo;t work. There is a way of doing this with AWK:</p>

<pre><code>awk '!($0 in lines) { lines[$0]; print }'
</code></pre>

<p>The above script will collect unique lines in order of their appearance and store them in array called lines that gets printed at the end. This probably won&rsquo;t work for huge data sets but works well on up to a few thousand lines of text.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Predefined Macros]]></title>
    <link href="http://741MHz.com/predefined-macros/"/>
    <updated>2010-10-17T00:00:00-04:00</updated>
    <id>http://741MHz.com/predefined-macros</id>
    <content type="html"><![CDATA[<p>Every C and C++ compiler has several object-like macros that are implicitly defined and can be used  without supplying their definitions on the command line or through including header files. Such macros are called &ldquo;predefined&rdquo; and can help figure out for what architecture you compile for, on what platform, if the source code being compiled is C or C++, and even tell the language standard of the code being used.</p>

<p>All predefined macros are described in GCC online documentation. However, not all of them are guaranteed to be defined. Sometimes it is helpful to see a list of macros defined by the compiler with their values, if any. To do that, run a preprocessor with zero input, using the following command:</p>

<pre><code>cpp -dM &lt;/dev/null
</code></pre>

<p>This will produce the output like this:</p>

<p>```</p>

<h1>define <strong>unix</strong> 1</h1>

<h1>define __x86_64 1</h1>

<h1>define <strong>DBL_MIN_10_EXP</strong> (-307)</h1>

<h1>define <strong>FINITE_MATH_ONLY</strong> 0</h1>

<h1>define <strong>GNUC_PATCHLEVEL</strong> 3</h1>

<p>```</p>

<p>From the above output we can tell that code is being compiled for x86_64 architecture. The output may change depending on the platform and/or compiler settings.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Wait For File With Inotify]]></title>
    <link href="http://741MHz.com/inotify-wait/"/>
    <updated>2010-09-29T00:00:00-04:00</updated>
    <id>http://741MHz.com/inotify-wait</id>
    <content type="html"><![CDATA[<p>Imagine a situation where you have been asked to create a program that needs user to upload a file. It sounds easy, but there is a little problem. The program needs to wait for the file to appear, and how to do so efficiently might not be immediately obvious. The easiest and perhaps most naive implementation that comes to mind first is to check whether the file exist, wait some time using <a href="http://man7.org/linux/man-pages/man3/sleep.3.html"><code>sleep()</code></a> and repeat this loop if files still does not exist afterwards.</p>

<p>This approach has some problems. It is not clear what time the program needs to sleep. If the interval is too long, a second for example, then user may experience a second long delay. This might be unacceptable. On the other hand, having a sleep interval too short would put an extra load on the entire system — operating system will have to <a href="http://en.wikipedia.org/wiki/Schedule_(computer_science">schedule</a>) this program more frequently, the filesystem access will be performed on each loop cycle, etc. This might slow down other applications running on the same server. Either way there is a problem that cannot be solved without a proper support from operating system that can tell the program when the file is created.</p>

<p><a href="http://en.wikipedia.org/wiki/Linux">Linux</a> has introduced the <a href="http://en.wikipedia.org/wiki/Inotify"><em>inotify</em></a> subsystem that was designed to solve this and similar problems by extending the filesystem with notifications of changes that are reported to the applications. To demonstrate how it works, I wrote a simple C++ that check if the file exists and waits for it if it doesn’t:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code panel panel-default'><figcaption class='panel-heading'><h3 class='panel-title'>Wait for file using inotify (inotify_wait.cpp)</h3> <a href='/downloads/code/inotify_wait.cpp'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;cstdio&gt;</span>
</span><span class='line'><span class="cp">#include &lt;cstring&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string&gt;</span>
</span><span class='line'><span class="cp">#include &lt;unistd.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;sys/inotify.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">directory</span> <span class="o">=</span> <span class="s">&quot;/tmp&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">filename</span> <span class="o">=</span> <span class="s">&quot;test.txt&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">fullpath</span> <span class="o">=</span> <span class="n">directory</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">filename</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">inotify_init</span><span class="p">();</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">watch</span> <span class="o">=</span> <span class="n">inotify_add_watch</span><span class="p">(</span>
</span><span class='line'>        <span class="n">fd</span><span class="p">,</span> <span class="n">directory</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span>
</span><span class='line'>        <span class="n">IN_MODIFY</span> <span class="o">|</span> <span class="n">IN_CREATE</span> <span class="o">|</span> <span class="n">IN_MOVED_TO</span>
</span><span class='line'>    <span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">access</span><span class="p">(</span><span class="n">fullpath</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">F_OK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;File %s exists.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fullpath</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
</span><span class='line'>        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">char</span>    <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span> <span class="o">*</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">inotify_event</span><span class="p">)</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)];</span>
</span><span class='line'>    <span class="n">ssize_t</span> <span class="n">length</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">bool</span>    <span class="n">is_created</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">is_created</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">length</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="n">inotify_event</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
</span><span class='line'>             <span class="n">i</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inotify_event</span><span class="p">)</span> <span class="o">+</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">event</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">inotify_event</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">filename</span> <span class="o">==</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">printf</span><span class="p">(</span><span class="s">&quot;The file %s was created.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
</span><span class='line'>                <span class="n">is_created</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>                <span class="k">break</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">inotify_rm_watch</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">watch</span><span class="p">);</span>
</span><span class='line'>    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Note that we subscribe for filesystem notifications before checking if file exists. It is needed to avoid a race condition where file is created exactly after we checked for its existence and before we subscribed for notifications.</p>

<p>A similar approach is used in many applications. For example, <a href="www.bittorrent.com">BitTorrent</a> application can monitor a “Downloads” directory for new torrent files and open them automatically.</p>
]]></content>
  </entry>
  
</feed>
