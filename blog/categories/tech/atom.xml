<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tech | Ranting @ 741 MHz]]></title>
  <link href="http://741MHz.com/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://741MHz.com/"/>
  <updated>2013-12-01T22:07:58-05:00</updated>
  <id>http://741MHz.com/</id>
  <author>
    <name><![CDATA[741MHz.com]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++ Exceptions, Stack Trace and GDB Automation]]></title>
    <link href="http://741MHz.com/throw-stacktrace/"/>
    <updated>2013-04-16T00:00:00-04:00</updated>
    <id>http://741MHz.com/throw-stacktrace</id>
    <content type="html"><![CDATA[<p>The tricky part about any exception is that the stack is already unwinded by the time exception is caught and there is no easy way to figure out from which part of the code it was thrown. Have you ever caught an exception that has no information that can be used to find where the problem is? The one that says «this should never happen» or even has no text at all. Hopefully, this doesn’t happen to you very often. But if you work with a large C++ codebase with tons of different components written by different developers then sooner or later it would definitely happen. It can be quite disappointing and take a lot of time going through the pile of somebody else’s code trying to figure out what went wrong. So you must be prepared. I might be a little bit unlucky in this regard – this happened to me a lot, so I decided to share a few ways for overcoming this type of situations.</p>

<h2>Backtrace API</h2>

<p>Quite a few C runtime libraries provide a mechanism to examine the current thread’s call stack. It consists of three functions declared in <code>execinfo.h</code> header:</p>

<p>```c
int backtrace(void** array, int size);</p>

<p>char<em><em> backtrace_symbols(void</em> const</em> array, int size);</p>

<p>void backtrace_symbols_fd(void<em> const</em> array, int size, int fd);
```</p>

<p>Using those functions, one can access the stack trace at any given point of program execution. Here is a simple example that prints the stack to standard output:</p>

<p>```c++</p>

<h1>include &lt;execinfo.h></h1>

<h1>include <iostream></h1>

<p>int main()
{</p>

<pre><code>void *callstack[256];
int frames = ::backtrace(
    callstack, sizeof(callstack) / sizeof(callstack[0]));
char **symbols = ::backtrace_symbols(callstack, frames);
std::cout &lt;&lt; "Stack Trace:\n";
for (int i = 0; i &lt; frames; ++i) {
    std::cout &lt;&lt; '\t' &lt;&lt; symbols[i] &lt;&lt; '\n';
}
std::free(symbols);
</code></pre>

<p>}
```</p>

<p>This method can be used to get the stack trace before the exception is thrown and before the stack is unwinded. In order to do that, one could define a custom exception class that grabs the stack trace in its constructor. For example:</p>

<p>```c++</p>

<h1>include &lt;execinfo.h></h1>

<h1>include <string></h1>

<h1>include <stdexcept></h1>

<h1>include <cstdlib></h1>

<h1>include <iostream></h1>

<p>class Exception : public std::exception {
  public:</p>

<pre><code>Exception() {
    grab_backtrace();
}

explicit Exception(const std::string &amp;reason) : reason_(reason) {
    reason_.append(1, '\n');
    grab_backtrace();
}

virtual ~Exception() throw() { }

virtual const char *what() const throw() {
    return reason_.c_str();
}
</code></pre>

<p>  private:</p>

<pre><code>void grab_backtrace() {
    void *callstack[256];
    int frames = ::backtrace(
        callstack, sizeof(callstack) / sizeof(callstack[0]));
    char **symbols = backtrace_symbols(callstack, frames);
    try {
        reason_.append("Stack Trace:");
        for (int i = 0; i &lt; frames; ++i) {
            reason_.append("\n\t").append(symbols[i]);
        }
    } catch(const std::exception &amp;) {
        std::free(symbols);
        throw;
    }
    std::free(symbols);
}

std::string reason_;
</code></pre>

<p>};</p>

<p>static void do_something(int n, int i = 0)
{</p>

<pre><code>if (i &lt; n) {
    do_something(n, ++i);
} else {
    throw Exception("Recursion limit exceeded");
}
</code></pre>

<p>}</p>

<p>int main(int argc, char *argv[])
{</p>

<pre><code>try {
    do_something(argc &gt; 1 ? std::atoi(argv[1]) : 10, argc);
} catch(const std::exception &amp;e) {
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
    return EXIT_FAILURE;
}
</code></pre>

<p>}
```</p>

<p>So far so good! Here is an example of running the above program:</p>

<p>```
$ clang++ -Wall -pedantic ./test.cpp &amp;&amp; ./a.out 3
Recursion limit exceeded
Stack Trace:</p>

<pre><code>0   a.out                0x00000001034fa7af _ZN9Exception14grab_backtraceEv + 63
1   a.out                0x00000001034fa6f4 _ZN9ExceptionC2ERKSs + 116
2   a.out                0x00000001034fa56d _ZN9ExceptionC1ERKSs + 29
3   a.out                0x00000001034fa33c _Z12do_somethingii + 140
4   a.out                0x00000001034fa2df _Z12do_somethingii + 47
5   a.out                0x00000001034fa42d main + 93
6   libdyld.dylib        0x00007fff935e27e1 start + 0
</code></pre>

<p>```</p>

<p>Unfortunately, there are a few problems with this approach. Firstly, there no file names and no line numbers. Secondly, this approach requires to use the “Exception” class as a base class of all exceptions in the project (well, at least for those you want to get a stack trace for), which indeed can be very problematic if not impossible. But even if all of the above is fine with you, this approach may still not work out for you because frame pointers can be omitted in optimized builds. For example, omitting frame pointers is a default behavior of recent GCC compilers for x86_64 platforms (which can also be turned on/off using <code>-fomit-frame-pointer</code> option). Our call stack becomes useless if frame pointers are omitted:</p>

<p>```
$ clang++ -Wall -fomit-frame-pointer ./test.cpp &amp;&amp; ./a.out 3
Recursion limit exceeded
Stack Trace:</p>

<pre><code>0   a.out                0x0000000105eca82d _ZN9Exception14grab_backtraceEv + 61
</code></pre>

<p>```</p>

<p>Depending on the system, there could be other requirements in order to make this API work. For example, GNU runtime requires you to specify “-rdynamic” flag to instruct the linker to add all symbols, not only used ones, to the dynamic symbol table. So don’t forget to read a manual page for this API in your system before using this.</p>

<h2>__FILE__ and __LINE__</h2>

<p>C++ has many <a href="http://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html">standard predefined macros</a>. <code>__FILE__</code> and <code>__LINE__</code> macros are those two that come handy in order to identify a point in a program:</p>

<p><code>__FILE__</code>  macros expands to the name of the current input file, in the form of a C string constant. This is the path by which the preprocessor opened the file, not the short name specified in ‘#include’ or as the input file name argument. For example, “/usr/local/include/myheader.h” is a possible expansion of this macros.</p>

<p><code>__LINE__</code> macros expands to the current input line number, in the form of a decimal integer constant. While we call it a predefined macro, it’s a pretty strange macro, since its “definition” changes with each new line of source code.|</p>

<p>Using the above macros, it is possible to include both file and line information along with exception’s text, or maybe as additional member fields of any given exception class. There are multiple choices. Here is an example of one of possible implementations:</p>

<p>```c++</p>

<h1>include <stdexcept></h1>

<h1>include <cstdlib></h1>

<h1>include <iostream></h1>

<p>class Exception : public std::runtime_error {
  public:</p>

<pre><code>template &lt;unsigned int location_len&gt;
inline Exception(const char (&amp;location)[location_len],
                 const std::string &amp;reason)
    : std::runtime_error(reason + location)
{ }

virtual ~Exception() throw() { }
</code></pre>

<p>};</p>

<h1>define MY_THROW_STR_I(Arg) #Arg</h1>

<h1>define MY_THROW_STR(Arg) MY_THROW_STR_I(Arg)</h1>

<h1>define MY_THROW(Type, &hellip;)                                             \</h1>

<pre><code>do {                                                                \
    throw Type(" @ "; __FILE__ ";:" MY_THROW_STR(__LINE__), ##__VA_ARGS__); \
} while (0)
</code></pre>

<p>static void do_something(int n, int i = 0)
{</p>

<pre><code>if (i &lt; n) {
    do_something(n, ++i);
} else {
    MY_THROW(Exception, "Recursion limit exceeded");
}
</code></pre>

<p>}</p>

<p>int main(int argc, char *argv[])
{</p>

<pre><code>try {
    do_something(argc &gt; 1 ? std::atoi(argv[1]) : 10, argc);
} catch(const std::exception &amp;e) {
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
    return EXIT_FAILURE;
}
</code></pre>

<p>}
```</p>

<p>When the exception is caught and printed, the source file name and a line numbers are included, which makes it easy to trace the origins of such an exception:</p>

<p><code>
$ ./a.out
Recursion limit exceeded @ ./test.cpp:26
</code></p>

<p>Of course, this does not include a stack trace. But it works if frame pointers are omitted, tail recursion optimization is applied, or even if all symbol names are stripped out of the executable. There is one problem though — it may not be useful without a stack trace in certain cases. For example, one may declare a helper function used to throw an exception, like this:</p>

<p>```c++
<strong>attribute</strong>((noreturn)) void report_error(const std::string &amp;reason) {</p>

<pre><code>MY_THROW(Exception, reason);
</code></pre>

<p>}
```</p>

<p>In that case, the file and line of the exception origins will always be the same even if it was called from different places in the program. So this approach is also not a cure for all diseases.</p>

<h2>GDB Scripting: Automatic Backtrace on Exception Catchpoints</h2>

<p>And the last but not least method is to use <a href="http://www.gnu.org/software/gdb/">GDB debugger</a>. If you are not familiar with this debugger, you definitely should spend some time learning it. It is one of the most powerful tools out there. And it comes extremely handy when dealing with exceptions.</p>

<p><a href="http://sourceware.org/gdb/onlinedocs/gdb/Set-Catchpoints.html">GDB provides special catch points</a>, including those to catch exceptions being thrown, caught or even unhandled. We are interested in exceptions that are being thrown and so must use <code>catch throw</code> command. Here is an example of manually using GDB in order to examine a stack trace before the exception is thrown:</p>

<p>```
$ gdb -args ./a.out 5
Reading symbols from /tmp/a.out&hellip;done.
(gdb) catch throw
Catchpoint 1 (throw)
(gdb) run
Starting program: /tmp/a.out 5
Catchpoint 1 (exception thrown), <strong>cxxabiv1::</strong>cxa_throw (obj=0x6030d0, tinfo=0x401420 , dest=0x401198 )</p>

<pre><code>at ../../../../libstdc++-v3/libsupc++/eh_throw.cc:70
</code></pre>

<p>70    header->exc.unexpectedHandler = __unexpected_handler;
(gdb) backtrace</p>

<h1>0  <strong>cxxabiv1::</strong>cxa_throw (obj=0x6030d0, tinfo=0x401420 , dest=0x401198 )</h1>

<pre><code>at ../../../../libstdc++-v3/libsupc++/eh_throw.cc:70
</code></pre>

<h1>1  0x0000000000400fee in report_error (reason=&ldquo;Recursion limit exceeded&rdquo;) at ./test.cpp:25</h1>

<h1>2  0x000000000040105d in do_something (n=5, i=5) at ./test.cpp:33</h1>

<h1>3  0x000000000040102e in do_something (n=5, i=5) at ./test.cpp:31</h1>

<h1>4  0x000000000040102e in do_something (n=5, i=4) at ./test.cpp:31</h1>

<h1>5  0x000000000040102e in do_something (n=5, i=3) at ./test.cpp:31</h1>

<h1>6  0x00000000004010cb in main (argc=2, argv=0x7fffffffe1f8) at ./test.cpp:40</h1>

<p>(gdb) continue
Continuing.
Recursion limit exceeded @ ./test.cpp:25
[Inferior 1 (process 3865) exited with code 01]
(gdb) quit
```</p>

<p>At first, this might sound silly because in the real world a program may encounter a lot of exceptions and manually typing “backtrace” and “continue” every type that happens is nothing but a waste of time. But there is one trick — GDB can be automated. There are two ways of doing this — use a batch mode or a more sophisticated <a href="http://sourceware.org/gdb/wiki/PythonGdbTutorial">Python scripting</a>. For our purpose, a batch script will do just fine. Here is a simple script that turns off verbose output and paging, sets up a <code>throw</code> catch point and executes <code>backtrace</code> + <code>continue</code> commands every time the event is caught:</p>

<p><code>
set verbose off
set pagination off
catch throw
commands
backtrace
continue
end
run
quit
</code></p>

<p>Save the above script into a file, and then run GDB in batch mode telling it to use that file, which in my case is called “gdb_bt_script”:</p>

<p>```
$ gdb -n -batch -x ./gdb_bt_script &mdash;args ./a.out 5
Catchpoint 1 (throw)
Catchpoint 1 (exception thrown), <strong>cxxabiv1::</strong>cxa_throw (obj=0x6030d0, tinfo=0x401420 , dest=0x401198 ) at ../../../../libstdc++-v3/libsupc++/eh_throw.cc:70
70    header->exc.unexpectedHandler = __unexpected_handler;</p>

<h1>0  <strong>cxxabiv1::</strong>cxa_throw (obj=0x6030d0, tinfo=0x401420 , dest=0x401198 ) at ../../../../libstdc++-v3/libsupc++/eh_throw.cc:70</h1>

<h1>1  0x0000000000400fee in report_error (reason=&ldquo;Recursion limit exceeded&rdquo;) at ./test.cpp:25</h1>

<h1>2  0x000000000040105d in do_something (n=5, i=5) at ./test.cpp:33</h1>

<h1>3  0x000000000040102e in do_something (n=5, i=5) at ./test.cpp:31</h1>

<h1>4  0x000000000040102e in do_something (n=5, i=4) at ./test.cpp:31</h1>

<h1>5  0x000000000040102e in do_something (n=5, i=3) at ./test.cpp:31</h1>

<h1>6  0x00000000004010cb in main (argc=2, argv=0x7fffffffe1f8) at ./test.cpp:40</h1>

<p>Recursion limit exceeded @ ./test.cpp:25
[Inferior 1 (process 5849) exited with code 01]
$
```</p>

<p>Whoala! Now we get a full stack trace including function parameters, their values, and file and line numbers. If the program is optimized and has no debug symbols, however, we get a little bit less:</p>

<p>```
$ gdb -n -batch -x ./gdb_bt_script &mdash;args ./a.out 5
Catchpoint 1 (throw)
Catchpoint 1 (exception thrown), <strong>cxxabiv1::</strong>cxa_throw (obj=0x6030d0, tinfo=0x401470 , dest=0x401270 ) at ../../../../libstdc++-v3/libsupc++/eh_throw.cc:70
70    header->exc.unexpectedHandler = __unexpected_handler;</p>

<h1>0  <strong>cxxabiv1::</strong>cxa_throw (obj=0x6030d0, tinfo=0x401470 , dest=0x401270 ) at ../../../../libstdc++-v3/libsupc++/eh_throw.cc:70</h1>

<h1>1  0x00000000004010a8 in report_error(std::string const&amp;) ()</h1>

<h1>2  0x000000000040121e in do_something(int, int) ()</h1>

<h1>3  0x0000000000400ef6 in main ()</h1>

<p>Recursion limit exceeded @ ./test.cpp:25
[Inferior 1 (process 1877) exited with code 01]
```</p>

<p>Yet still a lot more than we get using backtrace API. But the most beautiful part is that this method does not require any code changes and works for pretty much any binary.</p>

<h2>The End</h2>

<p>Those were three fundamental methods that can help to identify a place where exception is thrown from. They are not mutually exclusive. Each has its cons and pros. I personally prefer to use GDB because it doesn’t require a code change, but use other two methods as well, depending on a situation. It is up to you to decide which one to use.</p>

<p>Hope it helps and Good Luck!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Two Different Languages - C and C++]]></title>
    <link href="http://741MHz.com/c-vs-cxx/"/>
    <updated>2013-04-15T00:00:00-04:00</updated>
    <id>http://741MHz.com/c-vs-cxx</id>
    <content type="html"><![CDATA[<p>Good news everyone, we are looking for a C/C++ developer! Wait, that’s not good news at all!</p>

<p>You see, the term «C/C++» is likely to piss off those who actually know both C and C++. On the other hand, majority of C++ developers mistakenly think they know C. And it would take at least a year or two for a C developer to learn C++. Yet «C/C++» is mentioned in way too many job postings. So who exactly are we looking for?</p>

<p>Let’s start by asking a simple question — what would the main() function return in the below C/C++ program?</p>

<p>```c++
extern int T;</p>

<p>int main()
{</p>

<pre><code>struct T { int a; int b; };
return sizeof(T) + sizeof('T');
</code></pre>

<p>}
```</p>

<p>Of course it depends on architecture. But let’s assume that size of int is 4 bytes and structure T has no extra padding. The code is legal in both C and C++. Yet the correct answer depends on whether this is a C or C++ program. If it is a C program then the correct answer is 8. In case of C++ the answer is 9.</p>

<h2>C is not C++</h2>

<p>C++ originated back in 1979 and at that time it was based on C. It wasn’t even called C++ — its first name was «C with Classes». The language was renamed to «C++» only in 1983. At that time, both languages were closely related. However, from that point both C and C++ took a different evolution path and today, some 30+ years later, both languages are as different as Objective-C and C++, Java and C#, Python and Ruby, OCaml and F#. There is only one catch — the basic syntax of both is very similar to such a degree that it is possible to have a program that is both legal C and legal C++, which may or may not behave differently. Generally, everyone knows that C++ has tons of features that are not available in C but any C code can be compiled as C++. Therefore, C++ developers also think that they know C. And in most cases they are dangerously mistaken. Below is a list of the most common features of C language serving as traps for C++ fellows.</p>

<h3>Casting void pointer</h3>

<p>In C, void pointer can be implicitly casted to a pointer of any other type. For example:</p>

<p><code>c
void *ptr = 0xDEADDEAD;
int *i = ptr;
</code></p>

<p>C developers use this convenient feature all the time. However, any C++ compiler would choke on that and die.</p>

<h3>Implicit function declaration</h3>

<p>In C, it is not always necessary to declare a function before using it. Using an undeclared function implicitly declares it. This feature has been declared deprecated since 1999 but is still used here and there. For example:</p>

<p>```c
int main() {</p>

<pre><code>    return foo();
</code></pre>

<p>}</p>

<p>int foo() {</p>

<pre><code>    return 0;
</code></pre>

<p>}
```</p>

<p>A perfectly legal C program that is illegal C++:</p>

<p><code>
$ gcc ./test.c
$ g++ ./test.cpp
./test.cpp: In function ‘int main()’:
./test.cpp:3: error: ‘foo’ was not declared in this scope
</code></p>

<h3>No arguments vs any arguments</h3>

<p>In C, function prototype without parameters imply that function accepts any number of arguments and it is legal to call such a function with one or more arguments. In C++, function prototype without parameters means that function accepts no arguments and it is illegal to call such function with arguments. For example:</p>

<p>```c
void foo();</p>

<p>int main() {</p>

<pre><code>    foo(1, "hello");
</code></pre>

<p>}</p>

<p>void foo() {
}
```</p>

<p>The above is absolutely legal C code that won’t compile as C++. As a matter of fact, I haven’t seen many C++ developers who can tell the difference between <code>void foo();</code> and <code>void foo(void);</code></p>

<h3>Crossing initialization with goto or switch</h3>

<p>```c
int main()
{</p>

<pre><code>goto out;
int i = 1;
</code></pre>

<p>  out:</p>

<pre><code>return 0;
</code></pre>

<p>}
```</p>

<p>The above is a perfectly legal C code but is rejected by C++ compiler as C++ does not allow to cross initialization:</p>

<p>```
$ clang++ ./test.cpp
./test.cpp:3:5: error: goto into protected scope</p>

<pre><code>goto out;
^
</code></pre>

<p>./test.cpp:4:9: note: jump bypasses variable initialization</p>

<pre><code>int i = 1;
    ^
</code></pre>

<p>1 error generated.
```</p>

<h3>Keywords clash</h3>

<p>C++ would fail to compile any legal C code that happen to use C++ keywords:</p>

<p>```c
struct foo {</p>

<pre><code>int old;
int new;
</code></pre>

<p>};
```</p>

<h2>More! More! More!</h2>

<p>Oh, you knew that? If you knew all of the above and still consider yourself a “C/C++” developer, hold on a second. Name at least 10 more differences. Huh?</p>

<ul>
<li>In C++, comma operator can yield an l-value. In C it cannot.</li>
<li>C does not allow duplicate typedefs while C++ does.</li>
<li>C++ does not allow non-prototype function declarations while C does.</li>
<li>C allows struct, union and enum to be declared in function prototypes, C++ doesn’t.</li>
<li>C allows for implicit discard of pointer const qualifiers. This trick won’t work in C++.</li>
<li>In C++, struct, union and enum declarations automatically imply a typedef with the same name. This is not the case in C.</li>
<li>Character literals in C are of type int. In C++ they are of type char.</li>
<li>C++ implicitly treats any const global as file scope unless it is explicitly declared extern, unlike C in which extern is the default.</li>
<li>Functions market as “inline” in C are of file scope whereas they have external linkage by default in C++.</li>
<li>C has VLA (Variable Length Arrays) support whereas C++ does not (until C++14).</li>
</ul>


<p>And the list of technical differences/incompatibilities of C and C++ can go on and on. The list is so big that it is impossible to fit it into a blog post. But if you are interested, check out References section in the bottom of this post.</p>

<p>Aside of technical differences, it would also be a mistake not to mention the coding style. Not a formatting style or using tabs versus spaces, but coding style. For example, C++ developers would always cast a result of <code>malloc()</code> whereas C developers would almost never do that.</p>

<h2>Grammar of «C/C++»</h2>

<p>Trying to figure out the meaning behind «C/C++», I dug the usage of slash as a punctuation sign in English text. I have never learn English grammar in school so you may want to check me on this one. Anyhow, according to Wikipedia the slash is most commonly used as the word substitute for “or” which indicates a choice (often mutually-exclusive) is present.</p>

<p>If that is the case, then companies are actually looking for either C or C++ developers, not both. Which doesn’t make any sense at all. Why nobody is looking for “Cobol/Ada” or “Lisp/Verilog” developers? Looking at other industries, there seem to be no companies searching for “Linguist/Plumber”-like people.</p>

<p>So the grammar doesn’t seem to back up the usage of «C/C++» term. This leaves everyone guessing as to what it actually means and the only way to figure out is from the context.</p>

<h2>What it actually means</h2>

<p>The actual meaning of «C/C++» depends. Here are some examples of what this means according to my observations.</p>

<p>In job postings, “We are looking for C/C++ developers” generally means “We are looking for C++ developers, nobody knows C here but why not put that in a title, too?”</p>

<p>When somebody brags about being a “C/C++” developers it means they don’t really know any of those languages but learned to write a “Hello, World!” application using printf() and compile it with C++ compiler.</p>

<p>In forums, «C/C++» section is usually dedicated for C++ crowd that might as well be able to answer some C-related questions if you get lucky.</p>

<h2>Tip: Don’t Use «C/C++»</h2>

<p>If you are looking for a developer, make sure you clearly specify requirements and avoid the use of «C/C++». If it so happens that you are actually looking for someone who knows both, say «C and C++». If you are willing to spend a few years teaching C developer C++ language, say «C++ developer or C developer willing to learn C++». Using «C/C++» will only bring confusion to those reading the job posting.</p>

<p>End of rant.</p>

<h2>References</h2>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Slash_(punctuation">Slash in English text.</a></li>
<li><a href="http://david.tribble.com/text/cdiffs.htm">Incompatibilities Between ISO C and ISO C++</a> by David R. Tribble</li>
<li><a href="http://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B">Compatibility of C and C++</a></li>
<li><a href="http://c-faq.com/malloc/mallocnocast.html">What’s wrong with casting malloc’s return value?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Evolution of Computer Networking]]></title>
    <link href="http://741MHz.com/network-evolution/"/>
    <updated>2013-03-29T21:00:00-04:00</updated>
    <id>http://741MHz.com/network-evolution</id>
    <content type="html"><![CDATA[<p>Do you remember 56k modems? Me too. The sound it used to produce when connecting still gives me a warm fuzzy feeling and a bit of excitement. The last time I have used that modem was in 2003. Fifty six thousand bits per seconds — that was a lot back then. For the sake of comparison, I went to speedtest.net to check the speed of my phone that uses 4G LTE from Verizon, and my Verizon Fios home network. Here are my results:</p>

<p><img src="/images/network-evolution/home_speed_test.jpg"></p>

<p>The phone’s Internet connection is roughly 263 faster; the home network is 821 times faster. This is just mind-blowing. But that is a simple home networking — a standard phone and a standard gigabit Ethernet adapter. The industrial networking is a lot more complicated, a lot faster, and is far ahead of technologies commonly used in our homes. In order to achieve lower latency characteristics and better bandwidth, the industry took a few large steps to get where we are now. Let’s take a quick look at what is going on there!</p>

<h2>Direct Memory Access</h2>

<p>One of the first steps was an introduction of <a href="http://en.wikipedia.org/wiki/Direct_memory_access">Direct Memory Access</a>, or <em>DMA</em>. Basically, it allowed peripheral devices to access computer’s memory without having CPU being involved in this process. I was trying to find some information about the history of DMA and found <a href="http://www.ganssle.com/articles/adma.htm">this interesting article</a> dated back to 1994. At that time, DMA was gaining popularity in embedded systems. Today, it can be found in any computer, and is used in all systems and not only embedded.</p>

<h2>Network Interface Controllers</h2>

<p>Before, computers used to access the network by communicating with the <a href="http://en.wikipedia.org/wiki/PHY_(chip">Ethernet PHY</a>) directly. Its only task is to send and receive data over a physical medium, such as famous <a href="http://en.wikipedia.org/wiki/Registered_jack">RJ-45 cable</a>.</p>

<p><img src="/images/network-evolution/phy_and_cat6.jpg"></p>

<p>The problem was in having CPU perform a lot of simple yet time-consuming operations in order to communicate over the network using just a PHY device. With the ever growing demand for better performance, engineers came up with special hardware called <a href="http://en.wikipedia.org/wiki/Network_interface_controller">Network Interface Controller</a> (NIC). Initially, it was handling tasks related to the <a href="http://en.wikipedia.org/wiki/Data_link_layer">Data Link Layer</a>, such as <a href="http://en.wikipedia.org/wiki/Media_access_control">Media Access Control</a>. This made it possible to perform many tasks on the card and not waste CPU resources. For example, NIC could filter data that was not intended for this computer (based on MAC address or IP address, for example).</p>

<h2>PCI Express 3.0</h2>

<p>The first NICs used to communicate with PC over <a href="http://en.wikipedia.org/wiki/Industry_Standard_Architecture">ISA bus</a>. ISA was later replaced with PCI and then <a href="http://en.wikipedia.org/wiki/PCI_Express#PCI_Express_3.0">PCI Express</a> (aka PCIe). The PCIe has evolved significantly since its first release. The currently used version 3 of the PCIe can handle up to 8 gigatransfers per second and provides a tremendous advantage not only to Network Interface Controllers, but general purpose computing with technologies like <a href="http://en.wikipedia.org/wiki/CUDA">CUDA</a>, <a href="http://en.wikipedia.org/wiki/OpenCL">OpenCL</a>, <a href="http://en.wikipedia.org/wiki/C%2B%2B_AMP">C++ AMP</a> etc. The version 4 of the PCIe standard is already on its way.</p>

<p><img src="/images/network-evolution/nic_in_90s.jpg"></p>

<h2>Optical Fiber, 100 Gigabit Ethernet and Special Hardware</h2>

<p>The old good copper cables got replaced with <a href="http://en.wikipedia.org/wiki/Optical_fiber">optical fiber</a> which are effectively transferring data with a speed of light. The speed at which network cards can transfer data has also increased. It jumped from 10 to 100 Mbps, then from 100 Mbps to 1 Gigabit per second – a common speed our PCs are operating at home these days. <a href="https://en.wikipedia.org/wiki/10-gigabit_Ethernet">10 Gigabit Ethernet</a> started to evolve around 2002 and over six million ports were shipped by 2010. This is the most common Ethernet speed currently used by the industry. In 2010, there were two new Ethernet standards supporting <a href="https://en.wikipedia.org/wiki/100_Gigabit_Ethernet">40 and 100 Gigabit per second</a> line rates. This technology is already being used today, powering our “Clouds” and having people ranting about “Big Data”.</p>

<p>One interesting thing about these new and crazy bandwidth capabilities is that computers cannot really handle it, so you cannot just plug a 100 GbE controller into your PCIe slot and download the whole Internet. Not at all. Simply because no general-purpose CPU can handle that amount of data, at least not yet. So far these loads can only be handled by special hardware – Ethernet ICs which are commonly implemented as <a href="http://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASICs</a>, but there are also <a href="http://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> based solutions. One of the great examples of such devices are network switches. For example, Arista makes a few switches capable of handling 1.28 terabytes per second.</p>

<p>If you are a big electronics enthusiast and know how to program FPGAs, then you can make your own 100 GbE device at home. There are plenty of kits available on the market already. For example, the following Altera board looks very interesting:</p>

<p><img src="/images/network-evolution/100g_dk_stratix_v_gx.jpg"></p>

<p>Though I can think of better ways to spend $25,000. But that’s just me. Let’s get back to the software and general-purpose CPUs. Engineers from all around the world have been trying to solve a problem of having a software that can handle large amount of traffic with lowest possible latency, and there is indeed some progress.</p>

<h2>Software, Berkeley Sockets and C10K</h2>

<p><img class="right" src="/images/network-evolution/code_monkey_by_gloriouskyle.jpg"></p>

<p>The software hasn’t really changed much in the last two decades, unfortunately. Developers are still using a classic <a href="http://en.wikipedia.org/wiki/Berkeley_sockets">Berkeley Socket API</a> for network programming, as they used two decades ago. This has been a big problem because sticking to the same old programming model does not allow for a lot of great optimizations.</p>

<p>In early 2000s, Alexey Kuznetsov, Jamal Hadi Salim and Robert Olsson have developed a new technique for network packet processing called «<a href="http://en.wikipedia.org/wiki/New_API">New API</a>». It was not affecting the socket API used by the application developers. Instead, it was a modification to the device driver packet processing framework that was designed to improve the performance of high-speed networking.</p>

<p>There were also a few improvements for which programmers should be grateful and thank to NIC designers. Modern NICs provide something called «offloading» where some tasks that were done by software are now handled by the NICs. This at least includes a <a href="http://en.wikipedia.org/wiki/Large_segment_offload">Large Segment Offload</a>, <a href="http://en.wikipedia.org/wiki/Large_receive_offload">Large Receive Offload</a>, and TCP/IP, UDP and Ethernet checksum calculation. These “tricks” are very common these days and won’t surprise anyone.</p>

<p>The above improvements helped a lot but it soon turned out to be not enough. In 2003, Dan Kegel described <a href="http://www.kegel.com/c10k.html">the C10K problem</a>. It highlights that hardware is no longer a bottleneck – the software is, or at least the way it is written. And that affects everything and not only the Web. Here is a real world example from a financial industry. I remember when I first joined the company I am currently with, we had an application designed to process <a href="http://opradata.com/">OPRA data</a> – an information aggregated from participating <a href="http://en.wikipedia.org/wiki/Option_(finance">option</a>) exchanges (currently 11). The data was distributed over some 30+ multicast channels at that time, and the application was creating a <a href="http://en.wikipedia.org/wiki/Thread_(computing">thread</a>) per UDP socket/channel to handle all of that data. That was truly embarrassing, and as the amount of data increased over time, the application would just lose half of the data or even crash. Luckily, we quickly threw that crappy app away and wrote a new one that handles everything with ease even during the peak loads.</p>

<p>I was laughing out loud when a few days ago, <a href="http://www.ft.com/intl/cms/s/0/5771ec7a-90ce-11e2-862b-00144feabdc0.html">according to Mr. O’Malia</a>, the government reportedly had similar problems after deciding to regulate a swap market. After market participants started to report their activity, the government simply failed to handle the amount of data:</p>

<blockquote><p>The commission now receives data on thousands of swaps each day. So far, however, none of our computer programs loads this data without crashing.</p></blockquote>

<p>As a result of a higher awareness of this problem among <a href="https://www.youtube.com/watch?v=v4Wy7gRGgeA">code monkeys</a>, an asynchronous network I/O approach quickly gained popularity and more applications started to use it. Generally speaking, a well written application using asynchronous approach can handle a reasonable amount of traffic on a powerful multi-core server – at least enough for most of generic applications like web servers, bit torrents etc. Yet handling a constant load of anything close to 10 GbE is still beyond the imaginable. And even if CPUs could handle that, that would leave no resources to actually do something meaningful with that data. This slowly but surely becomes a problem. Luckily, there are a number of solutions aiming at solving this problem by taking the whole new approach to computer networking.</p>

<h2>What’s Trending</h2>

<p>A lot of work towards a better networking has been emerging since 2005 with a number of companies already providing industrial grade solutions today. There is not yet an official name for it, no standard, and no solutions are exactly the same. Yet they all share the same philosophy and similar implementations. There are few main points shared by all of them:</p>

<ul>
<li>Operating system kernel is a bottleneck and its use must be avoided.</li>
<li>Applications must access the NIC directly and perform DMA transactions.</li>
<li>As much work as possible must be done by the NIC hardware.</li>
</ul>


<p><img class="right" src="/images/network-evolution/modern_nic.png" title="&lsquo;Modern NIC with full kernel-bypass, offload and zero-copy support as well as on-board FPGA for custom hardware logic.&rsquo;" >
There are three buzz words for the above points – Kernel-Bypass, Zero-Copy and Offload respectively. Here are just a few popular solution provides that implement all of the above and provide extremely high-performance networking solutions (in no particular order):</p>

<ul>
<li><a href="http://www.6wind.com/">6WIND</a></li>
<li><a href="http://www.plda.com/index.php">PLDA</a></li>
<li><a href="http://www.napatech.com/">Napatech</a></li>
<li><a href="http://www.mellanox.com/">Mellanox</a></li>
<li><a href="http://www.myricom.com/">Myricom</a></li>
<li><a href="http://www.solarflare.com/">SolarFlare</a></li>
<li><a href="http://www.velocytech.com/">VelociTech</a></li>
<li><a href="http://www.intilop.com/">Intilop</a></li>
<li><a href="http://www.ntop.org/products/pf_ring/dna/">NTOP.ORG DNA</a></li>
</ul>


<p>Some of the technologies provided by the above companies can speed up network processing anywhere from 20 to 100 times. In order to achieve the best performance, however, a different programming model (as well as API) must be used. It is simply impossible to have a Berkeley Socket API anymore — it is way too old and does not account for many things, making it impossible to write the efficient (from hardware point of view) program.</p>

<h2>What To Expect Next</h2>

<p>Given the current trends, it would be logical to expect a few things to happen.</p>

<h3>Standard API</h3>

<p>The first thing is a consolidation of APIs. Having 10+ different ways to do the same thing just does not sound good. Sooner or later we should get a standard API that would provide developers with a stable, thought-through and efficient way to program network applications using these cutting edge technologies. This would probably be something like <a href="http://en.wikipedia.org/wiki/OpenCL">OpenCL</a> but for networking.</p>

<h3>Lower Cost</h3>

<p>To get one of those programmable network adapters of the new era today, one should pay through the nose. The price can vary anywhere from $5000 to $50000, depending on the functionality provided. We should (hopefully) see the price go down as technology gets stabilized and the sales increase in quantities. After all, creating such a device is no harder than an iPhone. Yet we don’t pay 50K for an iPhone, right?</p>

<h3>Integration</h3>

<p>Recently, the Xilinx has released the <a href="http://www.xilinx.com/publications/prod_mktg/quickpath-interconnect-ip-product-brief.pdf">worlds first FPGA running QPI</a> at full width — 21 lanes at 6.4 GHz per lane. So we can now have a motherboard that has a cutting edge Intel CPU for general-purpose processing in one socket, and a special purpose FPGA in another socket, both sharing the host memory at maximum speed and the lowest possible latency. In other words, Intel CPU will communicate with FPGA just like it communicates with other CPUs on the same board. This will indeed help to get rid of PCI Express that has always been a bottleneck when it comes to both throughput and latency. Amazing, isn’t it? Below is the video from Xilinx explaining this in more details:</p>

<p><div class="embed-video-container"><iframe src="http://www.youtube.com/embed/NHkpMlL0bZ8 "></iframe></div></p>

<p>At the same time Altera, another leading FPGA vendor, has released <a href="http://www.altera.com/corporate/news_room/releases/2012/products/nr-optical-fpga-demo.html">the worlds first optical FPGA technology</a> that was developed in conjunction with Avago Technologies, breaking through the barriers of traditional copper interconnect. To put it simple, we can now plug the optical fiber directly into the FPGA’s transceiver and achieve a bandwidth of approximately 120 gigabits per second:</p>

<p><div class="embed-video-container"><iframe src="http://www.youtube.com/embed/cC5g3rE9DZ8 "></iframe></div></p>

<p>Now, here is what I think is going to happen. In the next few years we would have an FPGA chip sitting in a CPU socket right next to the high-end Intel CPU, interconnected by QPI with the highest possible bandwidth, and lowest possible latency. The FPGA would have an optical fiber cable attached to it and beaming the data straight into the fabrics. The FPGA would then handle all of the network processing, including high-level protocols such as TCP/IP or even higher ones like <a href="https://bitcoin.it/wiki/Protocol_specification">BitCoin</a>, <a href="http://fixprotocol.org/">FIX</a>, etc.</p>

<p>Once that is done, we could take all of that and integrate it with a human’s brain :)</p>

<p>Hope it was interesting. Thanks for reading!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OOP with ANSI C]]></title>
    <link href="http://741MHz.com/c-oop/"/>
    <updated>2013-03-20T00:00:00-04:00</updated>
    <id>http://741MHz.com/c-oop</id>
    <content type="html"><![CDATA[<p>What if I told you that Linux kernel is object-oriented? Would that surprise you? Or maybe you would think I am a lunatic, and I would understand that. After all, the Linux kernel is mostly written in C, with only a few sections written in Assembly. And everybody knows that C is not an object-oriented language. It is <a href="http://en.wikipedia.org/wiki/List_of_object-oriented_programming_languages">not even listed as such</a> on Wikipedia.</p>

<p>But crazy sometimes is not as crazy as it seems. Did you know that <a href="http://www.youtube.com/watch?v=P8DrxzkwnmA">respected professors who taught Einstein thought he was a goof-off</a>? At a time, if you told those respected scientists that Einstein is in fact a genius who would change the history, they definitely take you for a lunatic. Who would have though, right?</p>

<p>And who would have thought that C can be a used for object-oriented programming? <a href="http://www.cs.rit.edu/~ats/">Axel-Tobias Schreiner</a> did. He even went a step further and wrote a book called «Object-Oriented Programming with ANSI C». It starts like this:</p>

<blockquote><p>Object-oriented programming is the current cure-all — although it has been around for much more then ten years. At the core, there is little more to it then finally applying the good programming principles that we have been taught for more than twenty years. C++ (Eiffel, Oberon-2, Smalltalk … take your pick) is the New Language because it is object-oriented — although you need not use it that way if you do not want to (or know how to), and it turns out that you can do just as well with plain ANSI-C.</p></blockquote>

<p>This is one of the most wonderful books about programming in general, object-oriented approach, C and C++ programming languages that I have ever read. In my opinion, it hasn’t got the attention it deserves. I read it twice — the first time when I was just learning C and the second time when I was mastering C++. If you have been learning C and/or C++ — this is a must read.</p>

<p>Practically, C is a very low-level language and nobody would want to spend hours writing lots of glue code in C to implement a virtual method table — something that C++ compiler does for you automatically, unless it is required. But even if taking up on that challenge is not part of the plan, the Alex’s book is still great — it teaches the fundamental core principles that all object-oriented languages are built upon. C and C++ are there almost for the sake of examples only. Delegate? Explained. Multiple inheritance? Check. Selectors? There. After reading the book, one could basically just look at any language construct, be that C#, Java, Ruby, Python or any other language, and say, — “Yeah, I know what that does and how compiler implements it. That’s easy!”</p>

<p>As it turns out, not only you can do all of that with ANSI C, it is actually the best language to explain what is going on under the hood of other languages. And if you ever look at Linux kernel, you would see that it is one of the greatest examples object-oriented design.</p>

<p>The book <a href="http://www.lulu.com/shop/axel-schreiner/object-oriented-programming-with-ansi-c/paperback/product-17561597.html">can be purchased for $20 from Lulu</a> and it is worth every penny. You can also <a href="http://www.cs.rit.edu/~ats/books/ooc.pdf">download a free PDF version</a> from Mr. Schreiner’s website.</p>

<p>Axel-Tobias Schreiner, Thank You!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Calculating FIX Message Checksum]]></title>
    <link href="http://741MHz.com/fix-checksum/"/>
    <updated>2013-03-16T00:00:00-04:00</updated>
    <id>http://741MHz.com/fix-checksum</id>
    <content type="html"><![CDATA[<p>A FIX message is a stream of bytes that consists of data represented by <a href="http://en.wikipedia.org/wiki/Attribute%E2%80%93value_pair">field-value (aka key-value) pairs</a>. Those field-value pairs are delimited by <a href="http://en.wikipedia.org/wiki/Start-of-Header#SOH">SOH character</a> — a special non-printable ASCII character with hex code <code>0x01</code>. For convenience, it is usually replaced with a vertical bar (<code>|</code>) for displaying purposes. Each field-value pair consists of the field number and its value delimited by equals sign (<code>=</code>). In the code, it is represented as an escape sequence — <code>'\1'</code> or <code>"\001"</code>. Here is an example of a FIX message:</p>

<p><code>
8=FIX.4.2|9=178|35=8|49=PHLX|56=PERS|52=20071123-05:30:00.000|11=ATOMNOCCC9990900|20=3|150=E|39=E|55=MSFT|167=CS|54=1|38=15|40=2|44=15|58=PHLX EQUITY TESTING|59=0|47=C|32=0|31=0|151=15|14=0|6=0|10=128|
</code></p>

<p>Every FIX message must always end with a checksum field followed by SOH symbol. The field number for a checksum is 10. Therefore, the checksum part in the above message is <code>10=128|</code>.</p>

<p>There is one special requirement for the checksum field — it must always be three characters long. Not more and not less. It must be left-padded with <code>0</code> characters if needed. For example, if the checksum value is <code>13</code>, then it should appear as <code>013</code>. If it is only <code>1</code>, then it should read <code>001</code>. It can also be just <code>000</code>.</p>

<p>The checksum of a FIX message is calculated by adding every byte of the message, excluding the checksum field-value pair, as unsigned binary number, discarding any overflow bits. Therefore, the range of possible values is [0-255], the same range of values that can be represented by unsigned 8-bit integer (<code>uint8_t</code>).</p>

<p>The code for calculating FIX checksum is very simple — all it needs to do is add every byte of the input and store a result in <code>uint8_t</code>. Remember, the checksum field itself should not be used to calculate checksum. Here is an example in C:</p>

<p>```c++
uint8_t fix_checksum(const char *data, size_t size)
{</p>

<pre><code>uint8_t sum = 0;
size_t i = 0;
while (i &lt; size)
    sum = (uint8_t)(sum + (uint8_t)data[i++]);
return sum;
</code></pre>

<p>}
```</p>

<p>If writing in C++, <a href="http://en.cppreference.com/w/cpp/algorithm/accumulate"><code>std::accumulate()</code></a> can be used to achieve the same. Here is an example:</p>

<p>Once the checksum value is calculated, it must be added to the end of the message as an ASCII-encoded field-value pair with field number <code>10</code>, followed by SOH. As a remainder, the checksum value must always be three characters long, left padded with <code>0</code> if needed. The easiest way to convert the binary checksum value is this:</p>

<p>```c++
char data[3];</p>

<p>data[0] = (char)(checksum / 100 + &lsquo;0&rsquo;);
data[1] = (char)(checksum / 10 % 10 + &lsquo;0&rsquo;);
data[2] = (char)(checksum % 10 + &lsquo;0&rsquo;);
```</p>

<p>To sum things up, here is a C++ example program that calculates the checksum and appends it to the end, forming a complete FIX message:</p>

<p>```c++
// &mdash;<em>&mdash; C++11 &mdash;</em>&mdash;
// Compile: clang++ -std=c++11 -stdlib=libc++ -Wall ./test.cpp</p>

<h1>include <cstdint></h1>

<h1>include <string></h1>

<h1>include <numeric></h1>

<h1>include <iostream></h1>

<p>int main()
{</p>

<pre><code>// Initial message. The SOH is an escape sequence '\001'.
// It does not include checksum field — the checksum must
// be calculated.
std::string msg =
    "8=FIX.4.2\0019=178\00135=8\00149=PHLX\00156=PERS\001"
    "52=20071123-05:30:00.000\00111=ATOMNOCCC9990900\001"
    "20=3\001150=E\00139=E\00155=MSFT\001167=CS\00154=1\00138=15"
    "\00140=2\00144=15\00158=PHLX EQUITY TESTING\00159=0\001"
    "47=C\00132=0\00131=0\001151=15\00114=0\0016=0\001";

// Calculate the checksum.
std::uint8_t csum =
    std::accumulate(msg.begin(), msg.end(),
                    static_cast&lt;std::uint8_t&gt;(0));

// Append the checksum field-value to the message.
// First, add field number and field delimiter:
msg.append("10=");

// Then add checksum converted to ASCII characters,
// left-padded with zeroes:
msg.append(1, csum / 100 + '0');
msg.append(1, csum / 10 % 10 + '0');
msg.append(1, csum % 10 + '0');

// And finally, complete the message by adding a final
// SOH character:
msg.append(1, '\1');

// Print the message to standard output.
std::cout &lt;&lt; msg &lt;&lt; std::endl;
</code></pre>

<p>}
```</p>

<p>Note that some terminals may not be able to display SOH characters. It is possible that it would get displayed as <code>^A</code>, some other sequence, or not displayed at all. In OS X «Terminal», the above program would display the following:</p>

<p><code>
$ clang++ -std=c++11 -stdlib=libc++ -Wall -pedantic ./test.cpp
$ ./a.out
8=FIX.4.29=17835=849=PHLX56=PERS52=20071123-05:30:00.00011=ATOMNOCCC999090020=3150=E39=E55=MSFT167=CS54=138=1540=244=1558=PHLX EQUITY TESTING59=047=C32=031=0151=1514=06=010=128
</code></p>

<p>So when printing a FIX message, it might be useful to replace all occurrences of <code>01</code> with something else, for example a vertical bar. It is also possible to do it with command line utility called <code>tr</code>. This does not require a code change:</p>

<p><code>
$ ./a.out | tr '\1' '|'
8=FIX.4.2|9=178|35=8|49=PHLX|56=PERS|52=20071123-05:30:00.000|11=ATOMNOCCC9990900|20=3|150=E|39=E|55=MSFT|167=CS|54=1|38=15|40=2|44=15|58=PHLX EQUITY TESTING|59=0|47=C|32=0|31=0|151=15|14=0|6=0|10=128|
</code></p>

<p>That is pretty much all you need to know to successfully calculate a FIX checksum. There is also one little detail that might come handy — checksums are meant to help verify data integrity and make sure that no part of the message got corrupted during transmission from one application to another. These days, FIX messages are transmitted using TCP/IP or UDP. Both TCP/IP and UDP protocols guarantee data integrity out of the box and therefore a FIX checksum doesn’t make a lot of sense. Given that calculating FIX checksums requires a lot of CPU resources and is even likely to be the bottleneck, make sure that exchange or broker, with which you intend to communicate using FIX Protocol, require a checksum. There are a number of technically wise brokers and exchanges out there that do not require you to provide the correct checksum. If that is the case, simply put <code>10=000|</code> at the end of every message.</p>
]]></content>
  </entry>
  
</feed>
