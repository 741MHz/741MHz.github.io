<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tech | Ranting @ 741 MHz]]></title>
  <link href="http://741MHz.com/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://741MHz.com/"/>
  <updated>2013-12-01T22:59:28-05:00</updated>
  <id>http://741MHz.com/</id>
  <author>
    <name><![CDATA[741MHz.com]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++ and Right Angle Brackets]]></title>
    <link href="http://741MHz.com/right-angle-brackets/"/>
    <updated>2013-11-10T00:00:00-05:00</updated>
    <id>http://741MHz.com/right-angle-brackets</id>
    <content type="html"><![CDATA[<p>When it comes to computers, both programming and science have a &ldquo;longest match&rdquo; principe also known as &ldquo;maximal munch&rdquo;. This principle states that when creating some construct, as much of the available input as possible should be consumed. Which in turn leads to the fact that lexical syntax of many programming languages requires that tokens be built from the maximum possible number of characters from the input stream.</p>

<p>As a result of this, C++ has been suffering a minor, but persisting, annoying, and somewhat embarrassing problem that required programmers to avoid having two consecutive right angle brackets when writing templates. For example, the following code has been incorrect in C++ for decades:</p>

<p>```c++</p>

<pre><code>std::vector&lt;std::vector&lt;int&gt;&gt; matrix;
</code></pre>

<p>```</p>

<p>This is because the longest token in this expression is <code>&gt;&gt;</code>, which is a token for <a href="http://en.wikipedia.org/wiki/Logical_shift">right logical shift</a>, and it has nothing to do with templates. So the compiler would give an error. For example:</p>

<p>```</p>

<h1>g++ ./matrix.cc</h1>

<p>./matrix.cc:21:32: error: a space is required between consecutive right angle brackets (use &lsquo;> >&rsquo;)</p>

<pre><code>std::vector&lt;std::vector&lt;int&gt;&gt; matrix;
                           ^~
                           &gt; &gt;
</code></pre>

<p>```</p>

<p>And the programmers had to put a space between <code>&gt;</code> to fix it, like this: <code>std::vector&lt;std::vector&lt;int&gt; &gt; matrix;</code></p>

<p>This is not the only example of maximal munch drawbacks. Another notable case is unintended beginning of multi-line comment as in this program:</p>

<p>```c</p>

<h1>include &lt;stdio.h></h1>

<p>int main() {</p>

<pre><code>int a;
int *z;
int x;
int y;

a = 2;
z = &amp;a;
y = 10;
x = y/*z;

printf("%d\n", x);
</code></pre>

<p>}
```</p>

<p>For both humans and even a syntax highlighter it is clear that the intention of <code>x = y/*z</code> statement is to assigne <code>x</code> a result of dividing <code>y</code> by the value obtained through dereferencing <code>z</code> pointer. Yet <code>/*</code> is the longest match which corresponds to the beginning of the multiline comment, so the compiler would most likely fail:</p>

<p>```</p>

<blockquote><p>g++ ./example.cc
./example.cc:25:10: error: unterminated /* comment</p>

<pre><code>x = y/*z;
</code></pre>

<p>```</p></blockquote>

<p>For the good of all C++ developers, Daveed Vandevoorde from Edison Design Group has proposed three possible ways to fix C++ grammar to eliminate the problem of two consecutive right angle brackets in templates. One of them was chosen over other two and starting with C++11, programmers can now use <code>&gt;&gt;</code> in templates like this &ndash;  <code>std::vector&lt;std::vector&lt;std::vector&lt;int&gt;&gt;&gt;</code></p>

<p>It is important that this change also breaks backwards compatibility which could affect some programs. Consider the following program:</p>

<p>```c++</p>

<h1>include <iostream></h1>

<p>template<int I> struct X {</p>

<pre><code>static int const c = 2;
</code></pre>

<p>};</p>

<p>template&lt;> struct X<0> {</p>

<pre><code>typedef int c;
</code></pre>

<p>};</p>

<p>template<typename T> struct Y {</p>

<pre><code>static int const c = 3;
</code></pre>

<p>};</p>

<p>static int const c = 4;</p>

<p>int main() {</p>

<pre><code>std::cout &lt;&lt; (Y&lt;X&lt;1&gt; &gt;::c &gt;::c&gt;::c) &lt;&lt; '\n';
std::cout &lt;&lt; (Y&lt;X&lt; 1&gt;&gt;::c &gt;::c&gt;::c) &lt;&lt; '\n';
</code></pre>

<p>}
```</p>

<p>It is valid in both old and new C++. However, it would produce different results.</p>

<p>This is because in the old C++ <code>&gt;&gt;</code> was treated as the right shift operator that shifted 1 by the value of global <code>c</code> as part of <code>1&gt;&gt;::c</code> expression. But with a new grammar introduced in C++ this is no longer the case and so the same program would print <code>0</code> and <code>3</code> in pre-C++11, and two zeroes in C++11.</p>

<p>Some compiler developers, when started working on implementing new C++ standard, have put a special feature their compilers that would warn users about such cases. For example, clang compiler would issue a warning in case it runs into this code:</p>

<p>```
$ clang++ ./right_angle_brackets.cc &amp;&amp; ./test
./right_angle_brackets.cc:19:25: warning: use of right-shift operator (&lsquo;>>&rsquo;) in template argument will require</p>

<pre><code>  parentheses in C++11 [-Wc++11-compat]
std::cout &lt;&lt; (Y&lt;X&lt; 1&gt;&gt;::c &gt;::c&gt;::c) &lt;&lt; '\n';
                    ^
                   (     )
</code></pre>

<p>```</p>

<p>Hopefully, not many developers have intentionally used logical shifts as part of template parameters, and the amount of those cases are far less from those when an annoying extra space was required for no good reason.</p>

<p>As for the problem with comments &ndash; it still exists in both C and C++. But how much of a problem is it, really?</p>

<h2>References</h2>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Maximal_munch">Maximal much principle</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1757.html">N1757 &ndash; Right Angle Brackets</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Static Assert]]></title>
    <link href="http://741MHz.com/static-assert/"/>
    <updated>2013-05-07T00:00:00-04:00</updated>
    <id>http://741MHz.com/static-assert</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>Assertions is one of they key features of almost every programming language that help programmers verify their assumptions made when writing the code.
In C, assertion mechanism is provided by <a href="http://man7.org/linux/man-pages/man3/assert.3.html">assert()</a> preprocessor macro defined by <a href="http://en.wikipedia.org/wiki/Assert.h">assert.h</a> header file. C++ programs can also use it by including &ldquo;<a href="http://en.cppreference.com/w/cpp/header/cassert">cassert</a>&rdquo; header file. As an added benefit, assertions also serve as documentation of the internal details of the program enhancing the code maintainability. Here is a simple C++11 example:</p>

<p>```c++</p>

<h1>include <iostream></h1>

<h1>include <cassert></h1>

<p>int main(int argc, char* argv[]) {</p>

<pre><code>for (int i = 0; i &lt; argc; ++i) {
    assert(argv[i] != nullptr);
    std::cout &lt;&lt; argv[i] &lt;&lt; std::endl;
}
</code></pre>

<p>}
```
GNU C library also provides a convenient function to check for error numbers called &ldquo;<a href="http://man7.org/linux/man-pages/man3/assert_perror.3.html">assert_perror()</a>&rdquo;.</p>

<p>There are at least 71 more programming language that provide assertion mechanism. You can check them out along with examples at <a href="http://rosettacode.org/wiki/Assertions">http://rosettacode.org/wiki/Assertions</a></p>

<h2>The Problem</h2>

<p>The <code>assert()</code> macro in both C and C++ would only check for errors at <a href="http://en.wikipedia.org/wiki/Run_time_(program_lifecycle_phase">execution time</a>) when the program is actually running. By definition that implies that:</p>

<ul>
<li>It adds some overhead to the program execution (time, size or both).</li>
<li>The assertion may not be exercised leaving a program undetected for a while (in the worse case, the program may pass a testing stage only to be discover by the end user later).</li>
</ul>


<p>The above two points sound like are necessary evil. But what if we could get rid of those tradeoffs?</p>

<p>There are cases when there is enough information during <a href="http://en.wikipedia.org/wiki/Compile_time">compile-time</a> to detect a possible error. For example, macro definitions and <a href="http://msdn.microsoft.com/en-us/library/tby3xex3(v=vs.110">constant expressions</a>.aspx) are things that do not exist in compile-time.</p>

<p>If only there was a way to check constant expressions in compile-time it would have been always preferred over runtime checking.</p>

<p>Luckily, programmers have figured out a few different ways to do this.</p>

<h2>Workarounds</h2>

<h3>Preprocessor Assertions</h3>

<p>Both C and C++ preprocessors have <code>#error</code> directive that can be used to abort compilation with an error. It can be used to perform compile-time assertions.</p>

<p>For example, consider a simple C program that reads data from into a buffer whose size is specified using a standard <a href="http://www.gnu.org/software/libc/manual/html_node/Controlling-Buffering.html"><code>BUFSIZ</code> macro</a> and the programmer wants to make sure that buffer is at least 1024 bytes large. The code using assertions might look like this:</p>

<p>```c++</p>

<h1>include <cstdio></h1>

<h1>include <cassert></h1>

<p>int main(int argc, char* argv[]) {</p>

<pre><code>// Allocate buffer on stack:
char mybuffer[BUFSIZ];

// Make sure we have at least 1024 bytes:
assert(sizeof(mybuffer) &gt;= 1024);

// Read data into "mybuffer"...
</code></pre>

<p>}
```</p>

<p>Given that <code>BUFSIZ</code> is a macro, a better solution would be to use preprocessor and its <code>#error</code> directive to check for this at compile-time instead:</p>

<p>```c++</p>

<h1>include <cstdio></h1>

<h1>if BUFSIZ &lt; 1024</h1>

<h1>error Buffer size is too small</h1>

<h1>endif</h1>

<p>int main(int argc, char* argv[]) {</p>

<pre><code>// Allocate buffer on stack:
char mybuffer[BUFSIZ];

// Read data into "mybuffer"...
</code></pre>

<p>}
```</p>

<p>When the buffer size defined by <code>BUFSIZ</code> is large enough, the program would compile as normal. But when it isn&rsquo;t, the compile would refuse to compile the program spitting out an error that might look like this:</p>

<p><code>
$ g++ -Wall -pedantic ./assert_example.cc
./assert_example.cc:4:3: error: Buffer size is too small
</code></p>

<p>Unfortunately, this mechanism can be used with binary operands only. In other words, something like this would not work by definition:</p>

<p>```c
char mybuffer[BUFSIZ];</p>

<h1>if sizeof(mybuffer) &lt; 1024</h1>

<h1>error Buffer size is too small</h1>

<h1>endif</h1>

<p>```</p>

<p>This is because preprocessor knows nothing about <code>sizeof</code> operator and cannot use the result of this expression to compare it against 1024.</p>

<p>Of course, being limited to macros usage only is a big problem. And so people accepted the challenge and came up with another way to overcome this limitation&hellip;</p>

<h3>Negative Buffer Size</h3>

<p>C and C++ developers have been relying on the fact that it is impossible to have a buffer of negative size in order to implement compile time assertions. The mechanism is very simple &ndash; evaluate a constant expression and yield <code>1</code> if it evaluates as <code>true</code>, or <code>-1</code> otherwise, and use the result as size of the buffer. For example, let&rsquo;s say we want to make sure that size of the integer is exactly 4 bytes, we could write code like this:</p>

<p><code>c
typedef char assert_int_size[sizeof(int) == 4 ? 1 : -1];
</code></p>

<p>This approach, however, has its own limitations.</p>

<p>In C, it can be used in both function and non-function scopes, but cannot be used inside structs and unions.</p>

<p>Unlike C, C++ allows to have typedef statements, but there is another problem &ndash; if the static assertion is not dependent upon one or more template parameters, then the compiler is permitted to evaluate the static assertion at the point it is first seen, irrespective of whether the template is ever instantiated. In other words &ndash; it is hard to use with templates as programmers should always remember to use a template type in a condition.</p>

<h2>Core Language Support</h2>

<p>Over the years people have been working around issues associated with different workarounds to implement static assertions and realized that there is no way to implement them without a proper core language support.</p>

<h3>C++</h3>

<p>In 2004, Robert Klarer, Dr. John Maddock, Beman Dawes and Howard Hinnant wrote a proposal for adding a static assertion mechanism to the Core Language, known as <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1720.html">N1720</a>.</p>

<p>The proposal was accepted into the C++11 language specification and is implemented by the majority of C++ compilers today as &ldquo;<a href="http://en.cppreference.com/w/cpp/language/static_assert">static_assert()</a>&rdquo; keyword/function.</p>

<p>It comes with no strings attached and accepts two parameters &ndash; a compile-time expressions that is evaluates to either <code>true</code> or <code>false</code> and a message. If the expression evaluates to <code>false</code>, the compilation is aborted and specified message is shown as an error message. <code>static_assert()</code> can be used in any scope, including templates. For example:</p>

<p>```c++ Static Assert Example</p>

<h1>include <cstdio></h1>

<p>static_assert(BUFSIZ >= 1024, &ldquo;Buffer size is too small&rdquo;);</p>

<p>template <typename T>
struct Foo {</p>

<pre><code>static_assert(sizeof(int) == 4, "Int size is not 4 bytes");
</code></pre>

<p>};</p>

<p>int main(int argc, char* argv[]) {</p>

<pre><code>// Allocate buffer on stack:
char mybuffer[BUFSIZ];
static_assert(sizeof(mybuffer) &gt;= 1024, "Buffer size is too small");

// Read data into "mybuffer"...
</code></pre>

<p>}
```</p>

<h3>C</h3>

<p>In C, static assertions are introduced as part of <a href="http://en.wikipedia.org/wiki/C11_(C_standard_revision">ISO/IEC 9899:2011 standard</a>), informally known as C11. The mechanism is exactly the same as in C++, but the function name is <code>_Static_assert()</code>. For example:</p>

<p>```c C11 Static Assert Example</p>

<h1>include &lt;stdio.h></h1>

<p>_Static_assert(BUFSIZ >= 1024, &ldquo;Buffer size is too small&rdquo;);</p>

<p>struct Foo {</p>

<pre><code>char data[BUFSIZ];
</code></pre>

<p>};</p>

<p>union Bar {</p>

<pre><code>int x;
char y[4];
</code></pre>

<p>};</p>

<p>_Static_assert(sizeof(union Bar) == 4, &ldquo;Size of int is not 4 bytes&rdquo;);</p>

<p>int main(int argc, char* argv[]) {</p>

<pre><code>// Allocate buffer on stack:
char mybuffer[BUFSIZ];
_Static_assert(sizeof(mybuffer) &gt;= 1024, "Buffer size is too small");

// Read data into "mybuffer"...
</code></pre>

<p>}
```</p>

<p>It still cannot be used inside structs and unions, though.</p>

<h3>Note on error messages</h3>

<p>There is but one thing about <code>static_assert()</code> that can be pretty annoying &ndash; having to specify an error message even if it is an empty string. Of course, providing good error messages is the way to go. But there are a lot of cases when a condition used in assertion just does not need any extra words.</p>

<p>The first solution that immediately comes to mind is to use the macro like this:</p>

<p>```c++</p>

<h1>define STATIC_ASSERT(Expr) static_assert((Expr), #Expr)</h1>

<p>```</p>

<p>Note, however, that it won&rsquo;t work well with expressions that contain a comma, like this:</p>

<p><code>c++
STATIC_ASSERT(!std::is_same&lt;T, int&gt;::value);
</code></p>

<p>Of course, programmers can enclose an expression in extra pair of <code>()</code>, but there is a better to do this, using <a href="http://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html">variadic macros</a>. Here is a complete example:</p>

<p>```c++</p>

<h1>include &lt;type_traits></h1>

<h1>define STATIC_ASSERT_IMPL(Expr) static_assert((Expr), #Expr)</h1>

<h1>define STATIC_ASSERT(&hellip;) STATIC_ASSERT_IMPL((<strong>VA_ARGS</strong>))</h1>

<p>template <typename T>
struct Foo final {</p>

<pre><code>STATIC_ASSERT(!std::is_same&lt;T, int&gt;::value);
</code></pre>

<p>};</p>

<p>int main(int argc, char* argv[]) {</p>

<pre><code>STATIC_ASSERT(sizeof(int) == 4);
</code></pre>

<p>}
```</p>

<h2>See Also</h2>

<ul>
<li><a href="http://www.robertgamble.net/2012/01/c11-static-assertions.html">C11 Static Assertions</a> by Robert Gamble</li>
<li><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/lang/assert.html">Java: Programming with assertions</a></li>
<li><a href="http://www.boost.org/doc/libs/release/doc/html/boost_staticassert.html">Boost.StaticAssert library</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/vstudio/dd293588.aspx">MSDN on &ldquo;static_assert()&rdquo;</a></li>
<li><a href="http://www.drdobbs.com/compile-time-assertions/184401873">Compile-Time Assertions</a> by Ralf Holly</li>
</ul>


<h2>References</h2>

<ul>
<li><a href="http://en.wikipedia.org/wiki/C11_(C_standard_revision">C11 (C Standard Revision)</a>)</li>
<li><a href="http://gcc.gnu.org/wiki/C11Status">GCC C11 Status</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1720.html">N1720</a></li>
<li><a href="http://rosettacode.org/wiki/Assertions">Assertions</a> by RosettaCode.org</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Read it Aloud to Yourself]]></title>
    <link href="http://741MHz.com/read-it-aloud/"/>
    <updated>2013-05-07T00:00:00-04:00</updated>
    <id>http://741MHz.com/read-it-aloud</id>
    <content type="html"><![CDATA[<p>Once in a while I like to learn a new technology, a programming language or a trick to entertain myself and, hopefully, keep the mind open. To shift the perception on programming languages a little, I’ve decided to code some Ruby. The mind shift attempt was not successful this time. The language itself didn’t really impress me a lot — it is nice, well designed, has quite a community and a lot of stuff is built around it. But that’s about all there is in it for me. Almost. One of the books about Ruby that I stumbled upon is too damn good. It is the most entertaining and interesting read about programming language that I had in quite some time. It is called “<a href="http://mislav.uniqpath.com/poignant-guide/book/">Why’s (poignant) Guide to Ruby</a>” and is freely available online under the <a href="http://creativecommons.org/licenses/by-sa/2.5/">Attribution-ShareAlike license</a>. Here is an excerpt from a beautiful introduction to Ruby on Chapter 3:</p>

<blockquote><p>My conscience won’t let me call Ruby a computer language. That would imply that the language works primarily on the computer’s terms. That the language is designed to accommodate the computer, first and foremost. That therefore, we, the coders, are foreigners, seeking citizenship in the computer’s locale. It’s the computer’s language and we are translators for the world.
But what do you call the language when your brain begins to think in that language? When you start to use the language’s own words and colloquialisms to express yourself. Say, the computer can’t do that. How can it be the computer’s language? It is ours, we speak it natively!
We can no longer truthfully call it a computer language. It is coderspeak. It is the language of our thoughts.
Read the following aloud to yourself:
5.times { print &ldquo;Odelay!&rdquo; }
In English sentences, punctuation (such as periods, exclamations, parentheses) are silent. Punctuation adds meaning to words, helps give cues as to what the author intended by a sentence. So let’s read the above as: Five times print “Odelay!”</p></blockquote>

<p>There were more examples that, if you read them aloud to yourself, totally make sense to any person:</p>

<p><code>ruby Exit unless the word restaurant includes the word aura:
exit unless "restaurant".include? "aura"
</code></p>

<p><code>ruby With the words ‘toast’, ‘cheese’, and ‘wine’: take each food and print it capitalized:
['toast', 'cheese', 'wine'].each { |food| print food.capitalize  }
</code></p>

<p>This is not to mention beautiful Cartoon Foxes:</p>

<p><img class="<a" src="href="http://mislav.uniqpath.com/poignant-guide/images/the.foxes-3.png">http://mislav.uniqpath.com/poignant-guide/images/the.foxes-3.png</a>"></p>

<p>For a moment I thought it was pretty cool. But then I got back to earth. You see, programming in a human language is not fun at all and we all know it. There is a good non-programming life analogy to programming in a human language. It is called “The Law”. If you don’t believe me, go read your country’s tax, labor, criminal or any other law. You could read it as much as you want but chances are that you would either not understand it at all or misinterpret it unless you have a degree from a good law school. And those laws are written in proper English that you can read aloud to yourself. The point is that when it comes to precisely describing what should happen under what circumstances, there will be a domain specific language for it, and you will have to either master it yourself or hire a professional. The language itself doesn’t make things simpler and I would probably get around the law much better if it was written in a formal <a href="http://en.wikipedia.org/wiki/Turing_completeness">Turing-complete</a> language. And after all, I don’t really think like Ruby. Perhaps I’ve been doing low-level programming for too long now, I don’t know. It is definitely not the language of my thoughts. Not even close.</p>

<p>At any rate, Ruby is still a programming language that leaves a good impression as simple, fun and powerful tool that gets a lot of things done. I really enjoyed it during my crash course and thought it would be cool to write a C++ program in a way that you could read it aloud to your friends who are not programmers and have them understand what it does. Here is what I came up with for those first three Ruby examples:</p>

<p>```c++</p>

<h1>include &ldquo;ruby.hh&rdquo;</h1>

<p>int main() {</p>

<pre><code>// 5.times { print "Odelay!" }
5_times ^ print("Odelay!");

// exit unless "restaurant".include? "aura"
exit_unless ^ "restaurant"_includes("aura");

// ['toast', 'cheese', 'wine'].each { |food| print food.capitalize  }
each({ "toast", "cheese", "wine" }) ^ (print | capitalized);
</code></pre>

<p>}
```</p>

<p>And as it often happens, C++ did not come with batteries included this time, so I had to come up with a little mess consisting of lambdas, function objects, user-defined literals and initializer lists in order for this mambo-jumbo to work. Most of those are part of C++11 and without them it would have been a lot worse. Here is my terrible code turning C++ into a crazy Ruby-like thing:</p>

<p>```c++</p>

<h1>ifndef RUBY_HH</h1>

<h1>define RUBY_HH</h1>

<h1>include <cstdlib></h1>

<h1>include <string></h1>

<h1>include &lt;initializer_list></h1>

<p>enum fmt_flags {</p>

<pre><code>none,
capitalized
</code></pre>

<p>};</p>

<p>struct Repeater {</p>

<pre><code>unsigned long long n;

explicit inline Repeater(unsigned long long n) : n(n) {}

template &lt;typename F&gt;
void operator ^ (const F &amp;f) const {
    for (unsigned long long i = 0; i &lt; n; ++i)
        f();
}
</code></pre>

<p>};</p>

<p>inline Repeater operator"&ldquo; _times (unsigned long long n) {</p>

<pre><code>return Repeater(n);
</code></pre>

<p>}</p>

<p>struct printer {</p>

<pre><code>std::string s;

explicit printer(const std::string &amp;s) : s(s) { }

inline void operator()() const {
    std::puts(s.c_str());
}
</code></pre>

<p>};</p>

<p>struct fmt_printer {</p>

<pre><code>fmt_flags f;

explicit fmt_printer(fmt_flags f) : f(f) {
}

inline void operator()(const std::string &amp;x) const {
    auto s = x;
    switch (f) {
      case capitalized:
          for (auto &amp;c : s)
              c = std::toupper(c);
      case none:
          break;
    }
    std::puts(s.c_str());
}
</code></pre>

<p>};</p>

<p>auto print = <a href="const%20std::string%20&amp;s"></a> {</p>

<pre><code>return printer(s);
</code></pre>

<p>};</p>

<p>struct StringIncludesCheck {</p>

<pre><code>const char *haystack;
explicit StringIncludesCheck(const char *haystack)
    : haystack(haystack) { }

inline bool operator()(const char *needle) const {
    return std::strstr(haystack, needle) != nullptr;
}
</code></pre>

<p>};</p>

<p>inline StringIncludesCheck operator"&ldquo;
_includes(const char *haystack, long unsigned int) {</p>

<pre><code>return StringIncludesCheck(haystack);
</code></pre>

<p>}</p>

<p>struct ExiterUnless {</p>

<pre><code>inline void operator ^ (bool v) const {
    if (!v)
        std::exit(0);
}
</code></pre>

<p>};</p>

<p>static ExiterUnless exit_unless;</p>

<p>template <typename T>
struct EachFunc {</p>

<pre><code>std::initializer_list&lt;T&gt; elems;
explicit EachFunc(std::initializer_list&lt;T&gt; elems) : elems(elems) {}
template &lt;typename F&gt;
void operator^(F &amp;&amp;f) const {
    for (auto &amp;x : elems)
        f(x);
}
</code></pre>

<p>};</p>

<p>template <typename T>
EachFunc<T> each(std::initializer_list<T> elems) {</p>

<pre><code>return EachFunc&lt;T&gt;(elems);
</code></pre>

<p>}</p>

<p>fmt_printer operator|(decltype(print) printer, fmt_flags flags)
{</p>

<pre><code>return fmt_printer(flags);
</code></pre>

<p>}</p>

<h1>endif</h1>

<p>```</p>

<p>Luckily, this kind of stuff is rarely needed in the real world C++ programming. Most folks simply code up a few classes, throw a few virtual functions on top and get the job done. But there are some good cases when such a mind-blowing complexity comes handy. <a href="http://www.boost.org/doc/libs/release/doc/html/xpressive.html">Xpressive</a> is an excellent examples — it is a template regular-expression library that pretty much builds regular expressions in compile-time. Just check this beautiful usage example:</p>

<p>```c++</p>

<h1>include <iostream></h1>

<h1>include &lt;boost/xpressive/xpressive.hpp></h1>

<p>using namespace boost::xpressive;</p>

<p>int main()
{</p>

<pre><code>char const *str = "I was born on 5/30/1973 at 7am.";

// define some custom mark_tags with names more meaningful than s1, s2, etc.
mark_tag day(1), month(2), year(3), delim(4);

// this regex finds a date
cregex date = (month= repeat&lt;1,2&gt;(_d))           // find the month ...
           &gt;&gt; (delim= (set= '/','-'))            // followed by a delimiter ...
           &gt;&gt; (day=   repeat&lt;1,2&gt;(_d)) &gt;&gt; delim  // and a day followed by the same delimiter ...
           &gt;&gt; (year=  repeat&lt;1,2&gt;(_d &gt;&gt; _d));    // and the year.

cmatch what;

if( regex_search( str, what, date ) )
{
    std::cout &lt;&lt; what[0]     &lt;&lt; '\n'; // whole match
    std::cout &lt;&lt; what[day]   &lt;&lt; '\n'; // the day
    std::cout &lt;&lt; what[month] &lt;&lt; '\n'; // the month
    std::cout &lt;&lt; what[year]  &lt;&lt; '\n'; // the year
    std::cout &lt;&lt; what[delim] &lt;&lt; '\n'; // the delimiter
}
</code></pre>

<p>}
```</p>

<p>Either way, I don’t think I can make a good Ruby programmer because I tend to write my C++ as if it was C with code-generation built into the compiler and stick to dataflow programming model rather than object-oriented one. And I love it. As my buddy often say, «Cobol programmer could write a Cobol program in pretty much any programming language.»</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Like Python]]></title>
    <link href="http://741MHz.com/cpp-like-python/"/>
    <updated>2013-05-06T00:00:00-04:00</updated>
    <id>http://741MHz.com/cpp-like-python</id>
    <content type="html"><![CDATA[<p>Today I ran into a somewhat classy piece of code that was analyzing user’s answer to a <a href="https://en.wikipedia.org/wiki/Yes%E2%80%93no_question">Yes or No question</a>. The idea was to compare input to various possible answers disregarding the case. The code looked something like this:</p>

<p>```c++</p>

<h1>include <string></h1>

<h1>include &lt;strings.h></h1>

<h1>include <iostream></h1>

<p>static bool positive(const char *s)
{</p>

<pre><code>return (strcasecmp(s, "Y") == 0 ||
        strcasecmp(s, "Yes") == 0 ||
        strcasecmp(s, "OK") == 0 ||
        strcasecmp(s, "True") == 0 ||
        strcasecmp(s, "Sure") == 0 ||
        strcasecmp(s, "Of Course") == 0 ||
        strcasecmp(s, "Why not?") == 0);
</code></pre>

<p>}</p>

<p>int main()
{</p>

<pre><code>std::string s;

for (;;) {
    std::cout &lt;&lt; "Could you please give me $100? " &lt;&lt; std::flush;
    std::getline(std::cin, s);
    if (positive(s.c_str())) {
        std::cout &lt;&lt; "Thank you!" &lt;&lt; std::endl;
        break;
    } else {
        std::cout &lt;&lt; "We don't take «No» for an answer. Did you mean «Yes»?"
                  &lt;&lt; std::endl;
    }
}
</code></pre>

<p>}
```</p>

<p>What I wanted was to extend that funky <code>positive()</code> function to add more possibilities and it made me sad a little. Since I am writing Python scripts once in a while, I remembered about Python’s “in” statement. If I were to write this in Python, I’d do something like this:</p>

<p>```python</p>

<h1>!/usr/bin/env python</h1>

<h1>&ndash;<em>&ndash; coding: utf-8 &ndash;</em>&ndash;</h1>

<p>while True:</p>

<pre><code>answer = raw_input('Could you please give me $100? ')
if answer.lower() in ('y', 'yes', 'ok', 'true', 'sure', 'of course', 'why not?'):
    print "Thank You!"
    break
else:
    print "We don't take «No» for an answer. Did you mean «Yes»?"
</code></pre>

<p>```</p>

<p>Then I though, “Hey, C++ is by far a lot more powerful than Python syntax-wise, does this program really have to be that long and ugly?” Challenge accepted. A minute later, it looked even shorter than my Python version:</p>

<p>```c++
while (!in(lower(raw_input(&ldquo;Could you please give me $100? &rdquo;)),</p>

<pre><code>       "y", "yes", "ok", "true", "sure", "of course", "why not?"))
std::cout &lt;&lt; "We don't take «No» for an answer. Did you mean «Yes»?" &lt;&lt; std::endl;
</code></pre>

<p>std::cout &lt;&lt; &ldquo;Thank you!&rdquo; &lt;&lt; std::endl;
```</p>

<p>Well, of course this took some “magic” to work, which went to a reusable header. The complete program is a bit larger if put into a single source file:</p>

<p>```c++</p>

<h1>include <string></h1>

<h1>include <cctype></h1>

<h1>include <iostream></h1>

<p>static std::string raw_input(const char *prompt)
{</p>

<pre><code>std::string answer;
std::cout &lt;&lt; prompt &lt;&lt; std::flush;
std::getline(std::cin, answer);
return answer;
</code></pre>

<p>}</p>

<p>static std::string &amp;&amp;lower(std::string &amp;&amp;s)
{</p>

<pre><code>for (auto &amp;c : s)
    c = std::tolower(c);
return std::forward&lt;std::string&gt;(s);
</code></pre>

<p>}</p>

<p>static bool in(const std::string &amp;)
{</p>

<pre><code>return false;
</code></pre>

<p>}</p>

<p>template &lt;size_t N, typename &hellip;Args>
static bool in(const std::string &amp;s, const char (&amp;arg0)[N], Args &amp;&amp; &hellip;argN)
{</p>

<pre><code>return s == arg0 || in(s, std::forward&lt;Args&gt;(argN)...);
</code></pre>

<p>}</p>

<p>int main()
{</p>

<pre><code>while (!in(lower(raw_input("Could you please give me $100? ")),
           "y", "yes", "ok", "true", "sure", "of course", "why not?"))
    std::cout &lt;&lt; "We don't take «No» for an answer. Did you mean «Yes»?"
              &lt;&lt; std::endl;
std::cout &lt;&lt; "Thank you!" &lt;&lt; std::endl;
</code></pre>

<p>}
```</p>

<p><a href="http://en.wikipedia.org/wiki/Variadic_templates">Variadic templates</a> and <a href="http://en.wikipedia.org/wiki/Tail_call">tail recursion</a> can do magic (and compiler unrolls everything, I’ve checked).</p>

<p>I don’t want to start a language war or anything, but my opinion is that Python’s beauty is not in its simple or powerful syntax. Not at all.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How constant is a constant?]]></title>
    <link href="http://741MHz.com/constant/"/>
    <updated>2013-05-01T00:00:00-04:00</updated>
    <id>http://741MHz.com/constant</id>
    <content type="html"><![CDATA[<p>```c++</p>

<h1>include &lt;string.h></h1>

<h1>include &lt;stdio.h></h1>

<p>int main()
{</p>

<pre><code>char *data = "Bender is always sober.";
printf("Before: %s\n", data);
memcpy(data + 17, "drunk!", 6);
printf("After: %s\n", data);
return 0;
</code></pre>

<p>}
```</p>

<p>Do you remember those good old days of DOS when programmers used to write code like this? This trick was working like a champ back then. Today, however, you will only see this kind of code in questions asked by students burning the midnight oil learning C by examples from some really old books and perhaps in some embedded systems running on processors without a memory protection unit. The rest of code monkeys like you and me do not write this kind of code because the compilers generate a warning, the language standard says it invokes an undefined behavior and at the end of the day this is a pretty straightforward way to generate a segmentation fault and have our program bite on a <code>SIGSEGV</code> signal sent by the operating system’s kernel and take a solid core dump.</p>

<p>Why this doesn’t work now and how it used to work before? It is really simple — string literals like one used in the example are placed in a data segment of the program, the operating system then loads the program into memory and makes that memory write-protected by the means of <a href="http://en.wikipedia.org/wiki/Memory_management_unit">MMU</a>. DOS was not doing this, and so it worked fine in DOS times. It also works today if operating system doesn’t take care of this and write-protect the memory, or if the CPU has no MMU.</p>

<p>This all sounds nice and dandy but it raises one good question — are any constant objects actually constant? Ask any <a href="http://en.wikipedia.org/wiki/High-level_programming_language">HLL</a> programmer if it is possible to modify a constant string literal on a modern Intel architecture. The answer would likely be «No!» At least my colleagues said so, and all of them are brilliant developers with decades of experience. But every time I hear — «No, that’s just not possible», I take it as a challenge and cannot rest until I prove that it is. Nothing is impossible. So trust no one. The truth is that in fact it is possible. Check this out (do not try to repeat this at work):</p>

<p>```c++</p>

<h1>include &lt;sys/mman.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stddef.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;stdio.h></h1>

<p>int take_me_back_to_DOS_times(const void *ptr, size_t len);</p>

<p>int main()
{</p>

<pre><code>const char *data = "Bender is always sober.";
printf("Before: %s\n", data);
if (take_me_back_to_DOS_times(data, strlen(data)) != 0)
    perror("Time machine appears to be broken!");
memcpy((char *)data + 17, "drunk!", 6);
printf("After: %s\n", data);

return 0;
</code></pre>

<p>}</p>

<p>int take_me_back_to_DOS_times(const void *ptr, size_t len)
{</p>

<pre><code>int pagesize;
unsigned long long pg_off;
void *page;

pagesize = sysconf(_SC_PAGE_SIZE);
if (pagesize &lt; 0)
    return -1;
pg_off = (unsigned long long)ptr % (unsigned long long)pagesize;
page = ((char *)ptr - pg_off);
if (mprotect(page, len + pg_off, PROT_READ | PROT_WRITE | PROT_EXEC) == -1)
    return -1;
return 0;
</code></pre>

<p>}
```</p>

<p>Hopefully, the code is self-explanatory. But if in doubt — read a manual page about <a href="http://man7.org/linux/man-pages/man2/mprotect.2.html"><code>mprotect</code></a> system call. I have touched on memory protection in the beginning and how operating system is using it to make string literals constant. The above example uses the reverse approach and makes the memory writable again (just like a time machine taking the program to old good DOS times). The thing is, our commodity computers work with only two kinds of memory — <a href="http://en.wikipedia.org/wiki/Static_random-access_memory">SRAM</a> memory of CPU caches, which is fast and expensive, and a DRAM, which is slow but very cheap. Neither of those two kinds of memory is read-only. Some of the processors have neither memory protection nor memory management units, and it won’t even be possible to write-protect the memory to make it “look” constant (which can also be unprotected as well, as we have just witnessed). Therefore, there are no constants from the hardware point of view.</p>

<p>So what’s up with all those constant objects in programming languages? Theoretical computer science has a concept of <a href="http://en.wikipedia.org/wiki/Const-correctness"><em>const-correctness</em></a>, which is incorporated into many different languages. For instance, Java takes a lot of care to not allow programmers to modify constant objects. So do C and C++, for example. But the keyword here is “theoretically”.</p>

<blockquote><p>In theory, there is no difference between theory and practice. But, in practice, there is.</p>

<p>— <a href="http://en.wikiquote.org/wiki/Jan_L._A._van_de_Snepscheut">Jan L. A. van de Snepscheut</a></p></blockquote>

<p>Unlike higher-level languages like Java, both C and C++ are down to hardware and it doesn’t take a genius to simply get a memory address of some object and manipulate memory directly. And when you do that, there is nothing constant. This is not to mention that there are some legitimate cases when casting away the const is fine and well defined.</p>

<p>Don’t get me wrong. I am not saying it doesn’t make any sense or you should not use it. You definitely should. And if you violate the const-correctness rules then you are definitely taking a lot of risk. Not because it won’t work but because it may work differently from how you expect it to work. If that happens, you are the only one to blame because the standard simply say — «I told you, that’s undefined behavior!» But when it comes to theoretical computer science and const-correctness, there is one thing that bothers me — it is implemented only halfway. Consider standard C++ strings, for example. Let’s say I have a string that is declared as constant. According to C++ rules, I cannot cast away that const-ness. However, we all know that <code>std::string</code> stores its contents in dynamic memory, and therefore the string itself is originally non-constant. Now, everybody can interpret the laws and standards differently, but I find this code pretty legitimate and do not see how it is an undefined behavior:</p>

<p>```c++</p>

<h1>include <cstring></h1>

<h1>include <string></h1>

<h1>include <iostream></h1>

<p>static void print(const std::string &amp;str)
{</p>

<pre><code>// OK, the ”str” is constant, but the pointer to
// string it holds was never declared as constant,
// so we can cast it away and modify its contents
// using ”const_cast”:
char *p = const_cast&lt;char *&gt;(str.c_str());
memcpy(p + 17, "drunk!", 6);
std::cout &lt;&lt; str &lt;&lt; std::endl;
</code></pre>

<p>}</p>

<p>int main()
{</p>

<pre><code>const std::string str = "Bender is always sober.";
print(str);
return 0;
</code></pre>

<p>}
```</p>

<p>I also don’t like the idea of having somebody else modify my constant object using <a href="http://en.cppreference.com/w/cpp/language/const_cast"><code>const_cast</code></a> when I don’t want to, but C++ still says it is legal (because the object wasn’t originally declared as “const”):</p>

<p>```c++</p>

<h1>include <string></h1>

<h1>include <iostream></h1>

<p>static void some_bad_function_yet_legal(const std::string &amp;str)
{</p>

<pre><code>// OK, the ”str” is constant, but it wasn't declared
// as such in the first place, so we can use
// “const_cast” to change it:
std::string &amp;s = const_cast&lt;std::string &amp;&gt;(str);
s.resize(6);
</code></pre>

<p>}</p>

<p>int main()
{</p>

<pre><code>std::string str = "Bender is always sober.";

// Call a function that accepts a constant reference,
// who would think it modifies the string, right?
some_bad_function_yet_legal(str);

std::cout &lt;&lt; str &lt;&lt; std::endl;
return 0;
</code></pre>

<p>}
```</p>

<p>Sometimes it is legal, sometimes it is pronounced undefined behavior. Either way you end up with a broken program unless somebody took care and employed the MMU to protect your memory. It becomes even worse if it isn’t your code and you have to debug and chase the error, which could be pretty hard to do (luckily, we can have GDB <a href="http://stackoverflow.com/questions/58851/can-i-set-a-breakpoint-on-memory-access-in-gdb">break on memory access</a>). As an experiment, I wrote a little custom allocator that can protect and unprotect the memory. It makes it possible, for example, to make your string constant in a way that an attempt to modify its content would have the process receive <code>SIGSEGV</code>:</p>

<p>```c++</p>

<h1>include &lt;sys/mman.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include <cstddef></h1>

<h1>include <cstdlib></h1>

<h1>include <cstring></h1>

<h1>include <stdexcept></h1>

<h1>include <iostream></h1>

<p>template <typename T>
struct my_allocator {</p>

<pre><code>typedef std::size_t    size_type;
typedef std::ptrdiff_t difference_type;
typedef T*             pointer;
typedef const T*       const_pointer;
typedef T&amp;             reference;
typedef const T&amp;       const_reference;
typedef T              value_type;

template &lt;typename U&gt;
struct rebind { typedef my_allocator&lt;U&gt; other; };

pointer allocate(size_type n, const_pointer hint = nullptr)
{
    void *ptr;
    int pagesize = sysconf(_SC_PAGE_SIZE);
    if (pagesize &lt; 0)
        throw std::runtime_error("Cannot obtain a page size");
    if (posix_memalign(&amp;ptr, (std::size_t)pagesize, n * sizeof(T)) != 0)
        throw std::bad_alloc();
    return static_cast&lt;pointer&gt;(ptr);
}

void deallocate(pointer ptr, size_type s)
{
    std::free(ptr);
}

static void protect(const_pointer ptr, size_type len)
{
    int pagesize = sysconf(_SC_PAGE_SIZE);
    if (pagesize &lt; 0)
        throw std::runtime_error("Cannot obtain a page size");
    std::uintptr_t pg_off = (std::uintptr_t)ptr % (std::uintptr_t)pagesize;
    void *page = ((char *)ptr - pg_off);
    if (mprotect(page, len + pg_off, PROT_READ) == -1)
        throw std::runtime_error("Can't make memory read-only!");
}

static void unprotect(const_pointer ptr, size_type len)
{
    int pagesize = sysconf(_SC_PAGE_SIZE);
    if (pagesize &lt; 0)
        throw std::runtime_error("Cannot obtain a page size");
    std::uintptr_t pg_off = (std::uintptr_t)ptr % (std::uintptr_t)pagesize;
    void *page = ((char *)ptr - pg_off);
    if (mprotect(page, len + pg_off, PROT_READ | PROT_WRITE) == -1)
        throw std::runtime_error("Can't make memory read-only!");
}
</code></pre>

<p>};</p>

<p>template <typename T>
bool operator == (const my_allocator<T> &amp;, const my_allocator<T> &amp;) {</p>

<pre><code>return true;
</code></pre>

<p>}</p>

<p>template <typename T>
bool operator != (const my_allocator<T> &amp;, const my_allocator<T> &amp;) {</p>

<pre><code>return false;
</code></pre>

<p>}</p>

<p>typedef std::basic_string&lt; char, std::char_traits<char>,</p>

<pre><code>                       my_allocator&lt;char&gt; &gt; my_string;
</code></pre>

<p>static void some_bad_function(const my_string &amp;str)
{</p>

<pre><code>// OK, the ”str” is constant, but the pointer to
// string it holds was never declared as constant,
// so we can cast it away and modify its contents
// using ”const_cast”:
char *p = const_cast&lt;char *&gt;(str.c_str());
std::memcpy(p + 17, "drunk!", 6);
</code></pre>

<p>}</p>

<p>int main()
{</p>

<pre><code>try {
    const my_string str = "Bender is always sober.";

    my_string::allocator_type::protect(str.c_str(), str.size());
    some_bad_function(str); // This call results in SIGSEGV thanks to memory protection!
    std::cout &lt;&lt; str &lt;&lt; std::endl;
    my_string::allocator_type::unprotect(str.c_str(), str.size());
} catch(const std::exception &amp;e) {
    std::cerr &lt;&lt; "ERROR: " &lt;&lt; e.what() &lt;&lt; std::endl;
    return EXIT_FAILURE;
}
</code></pre>

<p>}
```</p>

<p>This of course doesn’t make it impossible to unprotect that memory. To make it so, we’d need some more sophisticated access control that possibly employs protection rings, etc. But this is as far as I am willing to go. I wish we had something like this done automatically when we declare or pass variables around as “const”. But this is not going to happen because moaning with memory protection is very expensive operation that would, if implemented, slow down the program and make it pretty much unusable. Maybe one day we’d get a special hardware that would make it a reality. But for now, let’s keep shooting ourselves in the foot. It is «<a href="/c-vs-cxx/">C/C++</a>», after all!</p>
]]></content>
  </entry>
  
</feed>
